package dev.rubentxu.pipeline.jenkins

import dev.rubentxu.pipeline.dsl.*
import dev.rubentxu.pipeline.logger.IPipelineLogger
import dev.rubentxu.pipeline.model.config.IPipelineConfig
import java.io.File

/**
 * DSL Engine for Jenkins Pipeline compatibility.
 * Simplified version for basic Jenkins compatibility.
 */
class JenkinsDslEngine(
    private val pipelineConfig: IPipelineConfig,
    private val logger: IPipelineLogger,
    private val enableCaching: Boolean = true
) : DslEngine<String> {

    override val engineId: String = "jenkins-dsl"
    override val engineVersion: String = "1.0.0"
    override val supportedExtensions: Set<String> = setOf(".jenkinsfile", ".jenkins", ".groovy")

    override fun getEngineInfo(): DslEngineInfo {
        return DslEngineInfo(
            engineId = engineId,
            engineName = "Jenkins DSL Engine",
            version = engineVersion,
            description = "Executes Jenkins Pipeline scripts with compatibility layer",
            supportedExtensions = supportedExtensions,
            capabilities = emptySet(),
            author = "Pipeline Team"
        )
    }

    override suspend fun compile(
        scriptFile: File,
        context: DslCompilationContext
    ): DslCompilationResult<String> {
        return try {
            val scriptContent = scriptFile.readText()
            compile(scriptContent, scriptFile.name, context)
        } catch (e: Exception) {
            logger.error("Failed to read Jenkins script file: ${e.message}")
            DslCompilationResult.Failure(
                listOf(
                    DslError(
                        "FILE_READ_ERROR",
                        "Failed to read Jenkins script file: ${e.message}",
                        cause = e
                    )
                )
            )
        }
    }

    override suspend fun compile(
        scriptContent: String,
        scriptName: String,
        context: DslCompilationContext
    ): DslCompilationResult<String> {
        return try {
            // Simple validation for Jenkins syntax
            val validation = validateJenkinsSyntax(scriptContent)
            
            when (validation) {
                is DslValidationResult.Valid -> {
                    DslCompilationResult.Success(
                        compiledScript = scriptContent,
                        metadata = DslCompilationMetadata(
                            compilationTimeMs = 0,
                            dependenciesResolved = 0,
                            warningsCount = 0
                        )
                    )
                }
                is DslValidationResult.Invalid -> {
                    DslCompilationResult.Failure(validation.errors)
                }
            }
        } catch (e: Exception) {
            logger.error("Compilation failed for Jenkins script: ${e.message}")
            DslCompilationResult.Failure(
                listOf(
                    DslError(
                        "COMPILATION_ERROR",
                        "Failed to compile Jenkins script: ${e.message}",
                        cause = e
                    )
                )
            )
        }
    }

    override suspend fun execute(
        compiledScript: String,
        context: DslExecutionContext
    ): DslExecutionResult<String> {
        return try {
            // Create a simple Jenkins pipeline and execute it
            val jenkinsPipeline = JenkinsPipelineBlock()
            
            // In a real implementation, we would parse the script and build the pipeline
            // For now, just return a success message
            
            DslExecutionResult.Success(
                result = "Jenkins pipeline executed successfully",
                metadata = DslExecutionMetadata(
                    executionTimeMs = 100,
                    memoryUsedMb = null,
                    threadsUsed = null,
                    eventsPublished = 0
                )
            )
        } catch (e: Exception) {
            logger.error("Execution failed for Jenkins script: ${e.message}")
            DslExecutionResult.Failure(
                DslError(
                    "EXECUTION_ERROR",
                    "Failed to execute Jenkins script: ${e.message}",
                    cause = e
                )
            )
        }
    }

    override suspend fun compileAndExecute(
        scriptFile: File,
        compilationContext: DslCompilationContext,
        executionContext: DslExecutionContext
    ): DslExecutionResult<String> {
        return try {
            val compilationResult = compile(scriptFile, compilationContext)

            when (compilationResult) {
                is DslCompilationResult.Success -> {
                    execute(compilationResult.compiledScript, executionContext)
                }
                is DslCompilationResult.Failure -> {
                    val error = compilationResult.errors.firstOrNull()
                        ?: DslError("COMPILATION_ERROR", "Compilation failed")
                    DslExecutionResult.Failure(error)
                }
            }
        } catch (e: Exception) {
            logger.error("Failed to compile and execute Jenkins script: ${e.message}")
            DslExecutionResult.Failure(
                DslError(
                    "SCRIPT_ERROR",
                    "Failed to process Jenkins script: ${e.message}",
                    cause = e
                )
            )
        }
    }

    override suspend fun validate(
        scriptContent: String,
        context: DslCompilationContext
    ): DslValidationResult {
        return validateJenkinsSyntax(scriptContent)
    }

    override fun createDefaultCompilationContext(): DslCompilationContext {
        return DslCompilationContext(
            imports = setOf(
                "dev.rubentxu.pipeline.jenkins.*",
                "dev.rubentxu.pipeline.dsl.*"
            ),
            allowedPackages = setOf(
                "kotlin.*",
                "java.lang.*",
                "java.util.*",
                "dev.rubentxu.pipeline.*"
            ),
            blockedPackages = setOf(
                "java.lang.reflect.*",
                "java.security.*",
                "sun.*"
            ),
            enableCaching = enableCaching,
            securityPolicy = DslSecurityPolicy.DEFAULT
        )
    }

    override fun createDefaultExecutionContext(): DslExecutionContext {
        return DslExecutionContext(
            workingDirectory = File(System.getProperty("user.dir")),
            environmentVariables = System.getenv(),
            variables = emptyMap(),
            resourceLimits = DslResourceLimits(
                maxMemoryMb = 512,
                maxCpuTimeMs = 300_000,
                maxWallTimeMs = 600_000,
                maxThreads = 10
            ),
            executionPolicy = DslExecutionPolicy(
                isolationLevel = DslIsolationLevel.THREAD,
                allowConcurrentExecution = true,
                enableEventPublishing = true
            )
        )
    }

    /**
     * Validate Jenkins-specific syntax
     */
    private fun validateJenkinsSyntax(scriptContent: String): DslValidationResult {
        val errors = mutableListOf<DslError>()

        // Check for required pipeline block
        if (!scriptContent.contains("pipeline")) {
            errors.add(DslError("MISSING_PIPELINE", "Jenkins script must contain a 'pipeline' block"))
        }

        // Check for required agent block
        if (!scriptContent.contains("agent")) {
            errors.add(DslError("MISSING_AGENT", "Jenkins pipeline must contain an 'agent' block"))
        }

        // Check for required stages block
        if (!scriptContent.contains("stages")) {
            errors.add(DslError("MISSING_STAGES", "Jenkins pipeline must contain a 'stages' block"))
        }

        return if (errors.isEmpty()) {
            DslValidationResult.Valid
        } else {
            DslValidationResult.Invalid(errors)
        }
    }
}