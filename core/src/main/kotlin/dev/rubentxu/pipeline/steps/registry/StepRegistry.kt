package dev.rubentxu.pipeline.steps.registry

import dev.rubentxu.pipeline.steps.annotations.*
import dev.rubentxu.pipeline.context.PipelineContext
import java.util.concurrent.ConcurrentHashMap
import kotlin.reflect.KFunction

/**
 * Central registry for @Step functions.
 * 
 * This registry discovers all @Step functions at runtime and provides
 * a unified interface for step execution, similar to how Jetpack Compose
 * manages @Composable functions.
 */
class StepRegistry {
    
    private val stepFunctions = ConcurrentHashMap<String, KFunction<*>>()
    private val stepMetadata = ConcurrentHashMap<String, StepInfo>()
    
    companion object {
        @Volatile
        private var INSTANCE: StepRegistry? = null
        
        fun getInstance(): StepRegistry {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: StepRegistry().also { 
                    INSTANCE = it
                    it.discoverSteps()
                }
            }
        }
    }
    
    /**
     * Discovers all @Step annotated functions (simplified implementation)
     */
    fun discoverSteps() {
        // For now, this is a simplified discovery mechanism
        // In a full implementation, this would use reflection or compiler-generated metadata
        registerBuiltInSteps()
    }
    
    /**
     * Registers a step function
     */
    fun registerStep(name: String, function: KFunction<*>, stepAnnotation: Step) {
        stepFunctions[name] = function
        stepMetadata[name] = StepInfo(
            name = name,
            description = stepAnnotation.description,
            category = stepAnnotation.category,
            securityLevel = stepAnnotation.securityLevel,
            function = function
        )
    }
    
    /**
     * Gets a step function by name
     */
    fun getStep(stepName: String): KFunction<*>? {
        return stepFunctions[stepName]
    }
    
    /**
     * Gets step metadata by name
     */
    fun getStepInfo(stepName: String): StepInfo? {
        return stepMetadata[stepName]
    }
    
    /**
     * Gets all available steps
     */
    fun getAllSteps(): List<StepInfo> {
        return stepMetadata.values.toList()
    }
    
    /**
     * Validates step parameters
     */
    fun validateStepParameters(stepName: String, params: Map<String, Any>): StepValidationResult {
        val stepInfo = stepMetadata[stepName] 
            ?: return StepValidationResult(false, listOf("Step not found: $stepName"))
        
        val errors = mutableListOf<String>()
        // TODO: Implement proper parameter validation
        return StepValidationResult(errors.isEmpty(), errors)
    }
    
    /**
     * Registers built-in steps (simplified implementation)
     */
    private fun registerBuiltInSteps() {
        // In a full implementation, this would be auto-generated by the compiler plugin
        // For now, we just log that built-in steps are available
        // The actual @Step functions are discovered through the annotation system
    }
}

/**
 * Information about a registered step
 */
data class StepInfo(
    val name: String,
    val description: String,
    val category: StepCategory,
    val securityLevel: SecurityLevel,
    val function: KFunction<*>
)

/**
 * Result of step validation
 */
data class StepValidationResult(
    val isValid: Boolean,
    val errors: List<String>
)