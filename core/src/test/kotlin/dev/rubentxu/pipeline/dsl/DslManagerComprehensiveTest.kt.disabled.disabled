package dev.rubentxu.pipeline.dsl

import dev.rubentxu.pipeline.PipelineConfigTest
import dev.rubentxu.pipeline.model.pipeline.PipelineResult
import dev.rubentxu.pipeline.logger.PipelineLogger
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.should
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.string.shouldContain
import io.kotest.matchers.types.shouldBeInstanceOf
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.runBlocking
import java.io.File
import java.nio.file.Files
import kotlin.script.experimental.api.*

/**
 * Comprehensive tests for DslManager - the core orchestrator of DSL operations.
 * Tests all major functionality including execution, validation, engine management, and security.
 */
class DslManagerComprehensiveTest : DescribeSpec({
    
    describe("DslManager Core Functionality") {
        
        val config = PipelineConfigTest()
        val logger = PipelineLogger.getLogger()
        
        beforeTest {
            // Setup clean state for each test
        }
        
        afterTest {
            // Cleanup after each test
        }
        
        it("should initialize with default engines") {
            val dslManager = DslManager(config, logger = logger)
            
            try {
                val engines = dslManager.getEngineInfo()
                engines shouldNotBe null
                engines.size shouldBe 1 // Default pipeline-dsl engine
                
                val pipelineEngine = engines.find { it.engineId == "pipeline-dsl" }
                pipelineEngine shouldNotBe null
                pipelineEngine?.engineName shouldBe "Pipeline DSL Engine"
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should register and manage custom engines") {
            val dslManager = DslManager(config, logger = logger)
            
            try {
                // Create a custom test engine
                val customEngine = TestDslEngine(
                    engineId = "test-engine",
                    engineName = "Test Engine",
                    supportedExtensions = setOf(".test.kts")
                )
                
                // Register the custom engine
                dslManager.registerEngine(customEngine)
                
                val engines = dslManager.getEngineInfo()
                engines.size shouldBe 2 // Default + custom
                
                val testEngine = dslManager.getEngine<String>("test-engine")
                testEngine shouldNotBe null
                testEngine?.engineId shouldBe "test-engine"
                
                // Unregister the custom engine
                dslManager.unregisterEngine("test-engine")
                
                val enginesAfterUnregister = dslManager.getEngineInfo()
                enginesAfterUnregister.size shouldBe 1
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should execute simple pipeline content successfully") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-test").toFile()
            
            try {
                val pipelineScript = """
                    import dev.rubentxu.pipeline.dsl.*
                    import pipeline.kotlin.extensions.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        stages {
                            stage("Test Stage") {
                                steps {
                                    echo("Hello from DslManager test!")
                                    writeFile("test-output.txt", "DslManager execution successful")
                                }
                            }
                        }
                    }
                """.trimIndent()
                
                val executionContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 30_000
                    )
                )
                
                val result = dslManager.executeContent<PipelineResult>(
                    scriptContent = pipelineScript,
                    engineId = "pipeline-dsl",
                    scriptName = "simple-test.pipeline.kts",
                    executionContext = executionContext
                )
                
                result.shouldBeInstanceOf<DslExecutionResult.Success<PipelineResult>>()
                
                // Verify the pipeline created the expected file
                val outputFile = File(tempDir, "test-output.txt")
                outputFile.exists() shouldBe true
                outputFile.readText() shouldBe "DslManager execution successful"
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should validate pipeline content correctly") {
            val dslManager = DslManager(config, logger = logger)
            
            try {
                // Valid pipeline
                val validPipeline = """
                    import dev.rubentxu.pipeline.dsl.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        stages {
                            stage("Valid Stage") {
                                steps {
                                    echo("This is valid")
                                }
                            }
                        }
                    }
                """.trimIndent()
                
                val validResult = dslManager.validateContent(validPipeline, "pipeline-dsl")
                validResult.shouldBeInstanceOf<DslValidationResult.Valid>()
                
                // Invalid pipeline (missing required blocks)
                val invalidPipeline = """
                    import dev.rubentxu.pipeline.dsl.*
                    
                    pipeline {
                        // Missing agent and stages
                    }
                """.trimIndent()
                
                val invalidResult = dslManager.validateContent(invalidPipeline, "pipeline-dsl")
                invalidResult.shouldBeInstanceOf<DslValidationResult.Invalid>()
                
                val invalid = invalidResult as DslValidationResult.Invalid
                invalid.errors.isNotEmpty() shouldBe true
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should execute pipeline from file") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-file-test").toFile()
            
            try {
                val pipelineContent = """
                    #!/usr/bin/env kotlin
                    import dev.rubentxu.pipeline.dsl.*
                    import pipeline.kotlin.extensions.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        environment {
                            "TEST_VAR" to "file_execution_test"
                            "BUILD_ID" to "123"
                        }
                        
                        stages {
                            stage("File Execution Test") {
                                steps {
                                    echo("Executing pipeline from file")
                                    echo("Environment: \${'$'}{env.TEST_VAR}")
                                    writeFile("file-execution-result.txt", "Pipeline executed from file successfully")
                                    
                                    // Test environment variable usage
                                    writeFile("build-info.txt", "Build ID: \${'$'}{env.BUILD_ID}")
                                }
                            }
                        }
                        
                        post {
                            always {
                                echo("Post execution cleanup")
                                writeFile("post-execution.txt", "Post execution completed")
                            }
                        }
                    }
                """.trimIndent()
                
                val pipelineFile = File(tempDir, "test-pipeline.kts")
                pipelineFile.writeText(pipelineContent)
                
                val executionContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 30_000
                    )
                )
                
                val result = dslManager.executeFile<PipelineResult>(
                    scriptFile = pipelineFile,
                    executionContext = executionContext
                )
                
                result.shouldBeInstanceOf<DslExecutionResult.Success<PipelineResult>>()
                
                // Verify execution results
                File(tempDir, "file-execution-result.txt").exists() shouldBe true
                File(tempDir, "build-info.txt").exists() shouldBe true
                File(tempDir, "post-execution.txt").exists() shouldBe true
                
                val buildInfo = File(tempDir, "build-info.txt").readText()
                buildInfo shouldContain "Build ID: 123"
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should handle execution errors gracefully") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-error-test").toFile()
            
            try {
                val errorPipeline = """
                    import dev.rubentxu.pipeline.dsl.*
                    import pipeline.kotlin.extensions.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        stages {
                            stage("Error Test") {
                                steps {
                                    echo("This step should work")
                                    
                                    // This should cause an error
                                    val undefinedVariable = nonExistentFunction()
                                    
                                    echo("This should not be reached")
                                }
                            }
                        }
                    }
                """.trimIndent()
                
                val executionContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 30_000
                    )
                )
                
                val result = dslManager.executeContent<PipelineResult>(
                    scriptContent = errorPipeline,
                    engineId = "pipeline-dsl",
                    scriptName = "error-test.pipeline.kts",
                    executionContext = executionContext
                )
                
                result.shouldBeInstanceOf<DslExecutionResult.Failure>()
                
                val failure = result as DslExecutionResult.Failure
                failure.error.message shouldContain "compilation"
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should enforce resource limits during execution") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-limits-test").toFile()
            
            try {
                val resourceIntensivePipeline = """
                    import dev.rubentxu.pipeline.dsl.*
                    import pipeline.kotlin.extensions.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        stages {
                            stage("Resource Test") {
                                steps {
                                    echo("Starting resource-intensive operations")
                                    
                                    // CPU intensive operation
                                    var sum = 0
                                    repeat(100000) { i ->
                                        sum += i * i % 1000
                                    }
                                    
                                    echo("CPU test completed: \${'$'}sum")
                                    writeFile("resource-test-result.txt", "Resource test completed")
                                }
                            }
                        }
                    }
                """.trimIndent()
                
                val restrictedContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 128, // Low memory limit
                        maxCpuTimeMs = 10_000, // 10 second CPU limit
                        maxWallTimeMs = 15_000, // 15 second wall time limit
                        maxThreads = 2
                    )
                )
                
                val result = dslManager.executeContent<PipelineResult>(
                    scriptContent = resourceIntensivePipeline,
                    engineId = "pipeline-dsl",
                    scriptName = "resource-test.pipeline.kts",
                    executionContext = restrictedContext
                )
                
                // Should either complete within limits or fail due to resource constraints
                result should { it is DslExecutionResult.Success || it is DslExecutionResult.Failure }
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should generate comprehensive execution reports") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-report-test").toFile()
            
            try {
                val reportPipeline = """
                    import dev.rubentxu.pipeline.dsl.*
                    import pipeline.kotlin.extensions.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        stages {
                            stage("Report Generation") {
                                steps {
                                    echo("Generating execution report")
                                    writeFile("execution-log.txt", "Pipeline execution started")
                                    
                                    // Simulate some work
                                    val timestamp = System.currentTimeMillis()
                                    writeFile("timestamp.txt", timestamp.toString())
                                    
                                    echo("Report generation completed")
                                }
                            }
                        }
                    }
                """.trimIndent()
                
                val executionContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 30_000
                    )
                )
                
                val result = dslManager.executeContent<PipelineResult>(
                    scriptContent = reportPipeline,
                    engineId = "pipeline-dsl",
                    scriptName = "report-test.pipeline.kts",
                    executionContext = executionContext
                )
                
                result.shouldBeInstanceOf<DslExecutionResult.Success<PipelineResult>>()
                
                // Generate and verify report
                val report = dslManager.generateReport()
                report shouldNotBe null
                
                val formattedReport = report.getFormattedReport()
                formattedReport shouldContain "DSL Execution Report"
                formattedReport shouldContain "pipeline-dsl"
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should handle concurrent pipeline executions") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-concurrent-test").toFile()
            
            try {
                val concurrentPipeline = { id: Int ->
                    """
                        import dev.rubentxu.pipeline.dsl.*
                        import pipeline.kotlin.extensions.*
                        
                        pipeline {
                            agent {
                                docker { image = "openjdk:21-jdk" }
                            }
                            
                            stages {
                                stage("Concurrent Test $id") {
                                    steps {
                                        echo("Executing concurrent pipeline $id")
                                        
                                        // Simulate some work
                                        Thread.sleep(100)
                                        
                                        writeFile("concurrent-result-$id.txt", "Pipeline $id completed")
                                    }
                                }
                            }
                        }
                    """.trimIndent()
                }
                
                val executionContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 30_000
                    ),
                    executionPolicy = DslExecutionPolicy(
                        allowConcurrentExecution = true
                    )
                )
                
                // Execute multiple pipelines concurrently
                val results = (1..3).map { id ->
                    dslManager.executeContent<PipelineResult>(
                        scriptContent = concurrentPipeline(id),
                        engineId = "pipeline-dsl",
                        scriptName = "concurrent-test-$id.pipeline.kts",
                        executionContext = executionContext
                    )
                }
                
                // All should succeed
                results.forEach { result ->
                    result.shouldBeInstanceOf<DslExecutionResult.Success<PipelineResult>>()
                }
                
                // Verify all results were created
                (1..3).forEach { id ->
                    File(tempDir, "concurrent-result-$id.txt").exists() shouldBe true
                }
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
        
        it("should provide execution statistics and monitoring") {
            val dslManager = DslManager(config, logger = logger)
            val tempDir = Files.createTempDirectory("dsl-manager-stats-test").toFile()
            
            try {
                val monitoringPipeline = """
                    import dev.rubentxu.pipeline.dsl.*
                    import pipeline.kotlin.extensions.*
                    
                    pipeline {
                        agent {
                            docker { image = "openjdk:21-jdk" }
                        }
                        
                        stages {
                            stage("Monitoring Test") {
                                steps {
                                    echo("Testing execution monitoring")
                                    
                                    // Simulate measurable work
                                    repeat(1000) { i ->
                                        if (i % 100 == 0) {
                                            echo("Progress: \${'$'}i/1000")
                                        }
                                    }
                                    
                                    writeFile("monitoring-completed.txt", "Monitoring test completed")
                                }
                            }
                        }
                    }
                """.trimIndent()
                
                val executionContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 30_000
                    )
                )
                
                val result = dslManager.executeContent<PipelineResult>(
                    scriptContent = monitoringPipeline,
                    engineId = "pipeline-dsl",
                    scriptName = "monitoring-test.pipeline.kts",
                    executionContext = executionContext
                )
                
                result.shouldBeInstanceOf<DslExecutionResult.Success<PipelineResult>>()
                
                // Verify monitoring data is available
                val report = dslManager.generateReport()
                
                report.totalExecutions shouldBe 1
                report.activeExecutions shouldBe 0
                report.registeredEngines shouldBe 1
                
                tempDir.deleteRecursively()
                
            } finally {
                runBlocking { dslManager.shutdown() }
            }
        }
    }
})

/**
 * Test DSL Engine implementation for testing purposes
 */
private class TestDslEngine(
    override val engineId: String,
    override val engineName: String,
    override val supportedExtensions: Set<String>
) : DslEngine<String> {
    
    override val engineVersion: String = "1.0.0"
    
    override suspend fun compile(
        scriptFile: File,
        context: DslCompilationContext
    ): DslCompilationResult<String> {
        // Create a dummy CompiledScript for testing
        val compiledScript = object : CompiledScript {
            override val compilationConfiguration = ScriptCompilationConfiguration()
            override suspend fun invoke(scriptEvaluationConfiguration: ScriptEvaluationConfiguration?): ResultWithDiagnostics<EvaluationResult> {
                return ResultWithDiagnostics.Success(EvaluationResult(ResultValue.Value(name = "test", value = "test result", type = "")))
            }
        }
        return DslCompilationResult.Success(
            compiledScript,
            DslCompilationMetadata(100L, false, 0, 0)
        )
    }
    
    override suspend fun compile(
        scriptContent: String,
        scriptName: String,
        context: DslCompilationContext
    ): DslCompilationResult<String> {
        return compile(File(scriptName), context)
    }
    
    override suspend fun execute(
        compiledScript: CompiledScript,
        context: DslExecutionContext
    ): DslExecutionResult<String> {
        return DslExecutionResult.Success(
            "Test execution result",
            DslExecutionMetadata(50L)
        )
    }
    
    override suspend fun validate(
        scriptContent: String,
        context: DslCompilationContext
    ): DslValidationResult {
        return DslValidationResult.Valid
    }
    
    override suspend fun compileAndExecute(
        scriptFile: File,
        compilationContext: DslCompilationContext,
        executionContext: DslExecutionContext
    ): DslExecutionResult<String> {
        val compiled = compile(scriptFile, compilationContext)
        return when (compiled) {
            is DslCompilationResult.Success -> execute(compiled.compiledScript, executionContext)
            is DslCompilationResult.Failure -> DslExecutionResult.Failure(compiled.errors.first())
        }
    }
    
    override fun getEngineInfo(): DslEngineInfo {
        return DslEngineInfo(
            engineId = engineId,
            engineName = engineName,
            version = engineVersion,
            description = "Test DSL Engine for unit testing",
            author = "Test Suite",
            supportedExtensions = supportedExtensions,
            capabilities = emptySet()
        )
    }
    
    override fun createDefaultCompilationContext(): DslCompilationContext {
        return DslCompilationContext()
    }
    
    override fun createDefaultExecutionContext(): DslExecutionContext {
        return DslExecutionContext()
    }
    
}