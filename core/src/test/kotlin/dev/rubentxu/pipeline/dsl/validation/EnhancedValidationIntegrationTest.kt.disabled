package dev.rubentxu.pipeline.dsl.validation

import dev.rubentxu.pipeline.dsl.*
import dev.rubentxu.pipeline.logger.PipelineLogger
import dev.rubentxu.pipeline.model.config.IPipelineConfig
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.should
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.collections.shouldNotBeEmpty
import kotlinx.coroutines.test.runTest
import java.io.File
import java.nio.file.Files

/**
 * Integration tests demonstrating the enhanced DSL validation system
 * working with the DslManager and real pipeline scenarios
 */
class EnhancedValidationIntegrationTest : StringSpec({
    
    "should demonstrate comprehensive validation workflow" {
        runTest {
            val logger = PipelineLogger.getLogger()
            
            // Create a mock config
            val config = object : IPipelineConfig {}
            
            val dslManager = DslManager(config, logger = logger)
            
            try {
                // Test 1: Valid pipeline script
                logger.info("üß™ Testing valid pipeline script validation")
                
                val validPipelineScript = """
                    pipeline {
                        agent any
                        
                        environment {
                            BUILD_NUMBER = "1.0.0"
                            DEPLOY_ENV = "staging"
                        }
                        
                        stages {
                            stage('Checkout') {
                                steps {
                                    echo "Checking out source code"
                                    checkout scm
                                }
                            }
                            
                            stage('Build') {
                                steps {
                                    echo "Building application"
                                    sh './gradlew build'
                                }
                            }
                            
                            stage('Test') {
                                steps {
                                    echo "Running tests"
                                    sh './gradlew test'
                                }
                                post {
                                    always {
                                        publishTestResults testResultsPattern: 'build/test-results/**/*.xml'
                                    }
                                }
                            }
                            
                            stage('Deploy') {
                                when {
                                    branch 'main'
                                }
                                steps {
                                    echo "Deploying to staging"
                                    sh './scripts/deploy.sh staging'
                                }
                            }
                        }
                        
                        post {
                            success {
                                echo "Pipeline completed successfully!"
                            }
                            failure {
                                echo "Pipeline failed!"
                            }
                        }
                    }
                """.trimIndent()
                
                val validReport = dslManager.validateContentWithEnhancedReporting(
                    scriptContent = validPipelineScript,
                    engineId = "pipeline-dsl",
                    scriptName = "valid-pipeline.pipeline.kts"
                )
                
                logger.info("üìä Valid Pipeline Validation Results:")
                logger.info(validReport.getFormattedReport())
                
                validReport.isValid shouldBe true
                validReport.errorCount shouldBe 0
                
                // Test 2: Problematic script with security issues
                logger.info("üß™ Testing problematic script with security issues")
                
                val problematicScript = """
                    import java.lang.Runtime
                    import java.net.Socket
                    import java.lang.reflect.Method
                    
                    pipeline {
                        agent any
                        
                        stages {
                            stage('Dangerous Operations') {
                                steps {
                                    echo "Starting dangerous operations"
                                    
                                    // Direct system access - DANGEROUS
                                    Runtime.getRuntime().exec("rm -rf /tmp/*")
                                    
                                    // Network access without permission
                                    val socket = Socket("malicious.com", 1337)
                                    
                                    // Reflection usage
                                    val method = String::class.java.getMethod("valueOf", Any::class.java)
                                    
                                    // Infinite loop - PERFORMANCE ISSUE
                                    while(true) {
                                        Thread.sleep(1000)
                                        println("Running forever...")
                                    }
                                    
                                    // System exit - DANGEROUS
                                    System.exit(1)
                                }
                            // Missing closing brace - SYNTAX ERROR
                    }
                """.trimIndent()
                
                val problematicReport = dslManager.validateContentWithEnhancedReporting(
                    scriptContent = problematicScript,
                    engineId = "pipeline-dsl",
                    scriptName = "problematic-pipeline.pipeline.kts",
                    executionContext = DslExecutionContext(
                        resourceLimits = DslResourceLimits(
                            maxMemoryMb = 5000, // Excessive
                            maxCpuTimeMs = 600_000, // Excessive
                            maxThreads = 100 // Excessive
                        )
                    )
                )
                
                logger.info("üö® Problematic Script Validation Results:")
                logger.info(problematicReport.getFormattedReport())
                
                problematicReport.isValid shouldBe false
                problematicReport.errorCount should { it > 0 }
                problematicReport.recommendations.shouldNotBeEmpty()
                
                // Verify specific issues were detected
                val issuesCodes = problematicReport.issues.map { it.code }
                issuesCodes.contains("DANGEROUS_API_USAGE") shouldBe true
                issuesCodes.contains("UNMATCHED_BRACES") shouldBe true
                
                // Test 3: Script with quick fixes
                logger.info("üß™ Testing validation with quick fixes")
                
                val scriptWithFixableIssues = """
                    pipeline {
                        stage("test") {
                            steps {
                                Thread.sleep(1000)
                                System.exit(0
                            // Missing closing parenthesis and brace
                    }
                """.trimIndent()
                
                val engine = dslManager.getEngine<Any>("pipeline-dsl")
                if (engine != null) {
                    val reportWithFixes = engine.validateWithQuickFixes(
                        scriptContent = scriptWithFixableIssues,
                        scriptName = "fixable-script.kts",
                        sandboxManager = dslManager.sandboxManager,
                        logger = logger
                    )
                    
                    logger.info("üîß Quick Fixes Available:")
                    logger.info(reportWithFixes.getFormattedReportWithFixes())
                    
                    reportWithFixes.quickFixes.shouldNotBeEmpty()
                    reportWithFixes.quickFixes.any { it.title.contains("closing") } shouldBe true
                }
                
                // Test 4: File validation
                logger.info("üß™ Testing file validation")
                
                val tempDir = Files.createTempDirectory("validation-test").toFile()
                val scriptFile = File(tempDir, "test-pipeline.pipeline.kts")
                
                scriptFile.writeText("""
                    pipeline {
                        agent any
                        stages {
                            stage('Example') {
                                steps {
                                    echo 'Hello from file validation'
                                }
                            }
                        }
                    }
                """.trimIndent())
                
                val fileReport = dslManager.validateFileWithEnhancedReporting(scriptFile)
                
                logger.info("üìÅ File Validation Results:")
                logger.info(fileReport.getFormattedReport())
                
                fileReport.isValid shouldBe true
                fileReport.scriptName shouldBe "test-pipeline.pipeline.kts"
                
                // Cleanup
                tempDir.deleteRecursively()
                
                logger.info("‚úÖ Enhanced validation integration tests completed successfully!")
                
            } finally {
                dslManager.shutdown()
            }
        }
    }
    
    "should demonstrate batch validation" {
        runTest {
            val logger = PipelineLogger.getLogger()
            
            val config = object : IPipelineConfig {}
            
            val dslManager = DslManager(config, logger = logger)
            
            try {
                val engine = dslManager.getEngine<Any>("pipeline-dsl")
                if (engine != null) {
                    val scriptsToValidate = listOf(
                        "println('Hello World')" to "simple.kts",
                        "pipeline { agent any }" to "minimal-pipeline.pipeline.kts",
                        "import java.lang.Runtime\nRuntime.getRuntime().exec('ls')" to "dangerous.kts",
                        "" to "empty.kts"
                    )
                    
                    logger.info("üß™ Running batch validation on ${scriptsToValidate.size} scripts")
                    
                    val batchResults = engine.validateBatch(
                        scripts = scriptsToValidate,
                        sandboxManager = dslManager.sandboxManager,
                        logger = logger
                    )
                    
                    batchResults.size shouldBe scriptsToValidate.size
                    
                    batchResults.forEachIndexed { index, report ->
                        logger.info("üìä Batch Result ${index + 1}: ${report.scriptName} - Valid: ${report.isValid}")
                        logger.info("   Errors: ${report.errorCount}, Warnings: ${report.warningCount}")
                    }
                    
                    // Verify results
                    batchResults[0].isValid shouldBe true  // Simple script
                    batchResults[1].isValid shouldBe true  // Minimal pipeline
                    batchResults[2].isValid shouldBe false // Dangerous script
                    batchResults[3].isValid shouldBe false // Empty script
                    
                    logger.info("‚úÖ Batch validation completed successfully!")
                }
                
            } finally {
                dslManager.shutdown()
            }
        }
    }
})