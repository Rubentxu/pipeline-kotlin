package dev.rubentxu.pipeline.execution

import dev.rubentxu.pipeline.dsl.*
import dev.rubentxu.pipeline.logger.PipelineLogger
import dev.rubentxu.pipeline.PipelineConfigTest
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.should
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.types.shouldBeInstanceOf
import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.runTest

/**
 * Tests for resource limit enforcement
 */
class ResourceLimitEnforcerTest : StringSpec({
    
    "should enforce memory limits during execution" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 512, // Reasonable limit to avoid issues
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 5_000,
                    maxThreads = 5
                )
                
                val result = enforcer.enforceResourceLimits(
                    executionId = "memory-test",
                    limits = limits
                ) {
                    // Simple operation that should succeed
                    delay(10)
                    "success"
                }
                
                // Should succeed with reasonable limits
                result shouldNotBe null
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should enforce wall time limits during execution" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 512,
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 500, // Short wall time limit
                    maxThreads = 5
                )
                
                val result = enforcer.enforceResourceLimits(
                    executionId = "wall-time-test",
                    limits = limits
                ) {
                    // Simulate long-running operation
                    delay(1000) // This should exceed the wall time limit
                    "completed"
                }
                
                // Should fail due to wall time limit
                result.shouldBeInstanceOf<ResourceLimitedResult.Failure>()
                result.violation.type shouldBe ResourceLimitType.WALL_TIME
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should allow execution within limits" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 512,
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 5_000,
                    maxThreads = 10
                )
                
                val result = enforcer.enforceResourceLimits(
                    executionId = "success-test",
                    limits = limits
                ) {
                    // Simple operation within limits
                    delay(100)
                    val calculation = (1..1000).sum()
                    "Result: $calculation"
                }
                
                result.shouldBeInstanceOf<ResourceLimitedResult.Success<String>>()
                result.result shouldBe "Result: 500500"
                result.resourceStats.executionId shouldBe "success-test"
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should track resource usage during execution" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 512,
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 5_000,
                    maxThreads = 10
                )
                
                val result = enforcer.enforceResourceLimits(
                    executionId = "tracking-test",
                    limits = limits
                ) {
                    delay(200) // Give time for monitoring
                    
                    // Check that we can get usage stats during execution
                    val usage = enforcer.getResourceUsage("tracking-test")
                    usage shouldNotBe null
                    usage?.executionId shouldBe "tracking-test"
                    
                    "completed"
                }
                
                result.shouldBeInstanceOf<ResourceLimitedResult.Success<String>>()
                
                // Check final resource stats
                val stats = result.resourceStats
                stats.totalWallTimeMs should { it > 0 }
                stats.limitsApplied shouldBe limits
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should handle execution termination" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 512,
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 10_000, // Long enough to not timeout naturally
                    maxThreads = 10
                )
                
                // Start an execution
                val executionJob = async {
                    enforcer.enforceResourceLimits(
                        executionId = "termination-test",
                        limits = limits
                    ) {
                        delay(5000) // Long delay
                        "should not complete"
                    }
                }
                
                // Wait a bit then terminate
                delay(100)
                val terminated = enforcer.terminateExecution("termination-test")
                terminated shouldBe true
                
                // Wait for the job to complete
                val result = executionJob.await()
                
                // Should complete but possibly with failure due to termination
                result shouldNotBe null
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should handle multiple concurrent executions" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 512,
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 5_000,
                    maxThreads = 5
                )
                
                val jobs = (1..3).map { i ->
                    async {
                        enforcer.enforceResourceLimits(
                            executionId = "concurrent-test-$i",
                            limits = limits
                        ) {
                            delay(300)
                            "Result $i"
                        }
                    }
                }
                
                // Check that all executions are tracked
                delay(100)
                val activeExecutions = enforcer.getAllActiveExecutions()
                activeExecutions.size should { it >= 0 } // May have completed by now
                
                // Wait for all to complete
                val results = jobs.map { it.await() }
                
                results.size shouldBe 3
                results.forEach { result ->
                    result.shouldBeInstanceOf<ResourceLimitedResult.Success<String>>()
                }
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should handle CPU intensive operations within limits" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 256,
                    maxCpuTimeMs = 5_000, // 5 second CPU limit
                    maxWallTimeMs = 10_000,
                    maxThreads = 2
                )
                
                val result = enforcer.enforceResourceLimits(
                    executionId = "cpu-test",
                    limits = limits
                ) {
                    // CPU intensive but reasonable operation
                    var sum = 0
                    repeat(100000) { i ->
                        sum += i * i % 1000
                    }
                    "CPU test completed: $sum"
                }
                
                // Should either succeed or fail due to CPU limits
                result should { it is ResourceLimitedResult.Success || it is ResourceLimitedResult.Failure }
                
                if (result is ResourceLimitedResult.Failure) {
                    result.violation.type should { it == ResourceLimitType.CPU_TIME || it == ResourceLimitType.WALL_TIME }
                }
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should handle memory intensive operations" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val enforcer = ResourceLimitEnforcer(logger)
            
            try {
                val limits = DslResourceLimits(
                    maxMemoryMb = 64, // Low memory limit
                    maxCpuTimeMs = 10_000,
                    maxWallTimeMs = 5_000,
                    maxThreads = 2
                )
                
                val result = enforcer.enforceResourceLimits(
                    executionId = "memory-intensive-test",
                    limits = limits
                ) {
                    // Memory allocation that might exceed limits
                    val largeList = mutableListOf<String>()
                    repeat(10000) { i ->
                        largeList.add("Memory test string $i".repeat(10))
                    }
                    "Memory test completed with ${largeList.size} items"
                }
                
                // Should either succeed within limits or fail due to memory constraints
                result should { it is ResourceLimitedResult.Success || it is ResourceLimitedResult.Failure }
                
                if (result is ResourceLimitedResult.Failure) {
                    result.violation.type shouldBe ResourceLimitType.MEMORY
                }
                
            } finally {
                enforcer.shutdown()
            }
        }
    }
    
    "should integrate with DslManager for resource-limited execution" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val config = PipelineConfigTest()
            val dslManager = DslManager(config, logger = logger)
            
            try {
                val executionContext = DslExecutionContext(
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 5_000,
                        maxWallTimeMs = 3_000,
                        maxThreads = 3
                    )
                )
                
                val simpleScript = """
                    val result = (1..100).sum()
                    println("Calculation result: \${'$'}result")
                    "Success: \${'$'}result"
                """.trimIndent()
                
                // Test basic execution with resource limits
                val result = dslManager.executeContent<String>(
                    scriptContent = simpleScript,
                    engineId = "pipeline-dsl",
                    scriptName = "integration-test",
                    executionContext = executionContext
                )
                
                result shouldNotBe null
                result.shouldBeInstanceOf<DslExecutionResult.Success<String>>()
                
            } finally {
                dslManager.shutdown()
            }
        }
    }
})