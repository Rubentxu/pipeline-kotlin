package dev.rubentxu.pipeline.model.pipeline

import dev.rubentxu.pipeline.PipelineConfigTest
import dev.rubentxu.pipeline.events.EndEvent
import dev.rubentxu.pipeline.events.EventManager
import dev.rubentxu.pipeline.events.StartEvent
import dev.rubentxu.pipeline.steps.EnvVars
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.matchers.collections.shouldContain
import io.kotest.matchers.string.shouldContain
import io.mockk.*
import kotlinx.coroutines.test.runTest
import java.nio.file.Path

class PipelineTest : DescribeSpec({

    describe("Pipeline") {
        
        beforeEach {
            // Clear any existing events
            clearAllMocks()
        }
        
        afterEach {
            unmockkAll()
        }

        it("should initialize with correct properties") {
            val agent = AnyAgent("test-agent")
            val env = EnvVars(mutableMapOf("TEST_VAR" to "test_value"))
            val postExecution = PostExecution()
            val config = PipelineConfigTest()
            val stages = listOf<StageExecutor>()

            val pipeline = Pipeline(
                agent = agent,
                stages = stages,
                env = env,
                postExecution = postExecution,
                pipelineConfig = config
            )

            pipeline.agent shouldBe agent
            pipeline.stages shouldBe stages
            pipeline.env shouldBe env
            pipeline.postExecution shouldBe postExecution
            pipeline.currentStage shouldBe "initial pipeline"
            pipeline.workingDir shouldNotBe null
            pipeline.stageResults shouldHaveSize 0
        }

        it("should set working directory to current user directory") {
            val pipeline = createTestPipeline()
            
            val expectedWorkingDir = Path.of(System.getProperty("user.dir"))
            pipeline.workingDir shouldBe expectedWorkingDir
        }

        it("should register events correctly") = runTest {
            val pipeline = createTestPipeline()
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            val testEvent = StartEvent("test-stage", System.currentTimeMillis())
            
            pipeline.registerEvent(testEvent)
            
            coVerify { EventManager.notify(testEvent) }
        }

        it("should execute single stage successfully") = runTest {
            val mockStage = mockk<StageExecutor>()
            every { mockStage.name } returns "Test Stage"
            coEvery { mockStage.run(any()) } just Runs
            
            val pipeline = createTestPipeline(stages = listOf(mockStage))
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            pipeline.executeStages()
            
            // Verify stage was executed
            coVerify { mockStage.run(pipeline) }
            
            // Verify events were registered
            coVerify { EventManager.notify(ofType<StartEvent>()) }
            coVerify { EventManager.notify(ofType<EndEvent>()) }
            
            // Verify stage result was recorded
            pipeline.stageResults shouldHaveSize 1
            pipeline.stageResults[0].status shouldBe Status.SUCCESS
            pipeline.stageResults[0].stageName shouldBe "Test Stage"
        }

        it("should execute multiple stages in sequence") = runTest {
            val stage1 = mockk<StageExecutor>()
            val stage2 = mockk<StageExecutor>()
            val stage3 = mockk<StageExecutor>()
            
            every { stage1.name } returns "Stage 1"
            every { stage2.name } returns "Stage 2"
            every { stage3.name } returns "Stage 3"
            
            coEvery { stage1.run(any()) } just Runs
            coEvery { stage2.run(any()) } just Runs
            coEvery { stage3.run(any()) } just Runs
            
            val pipeline = createTestPipeline(stages = listOf(stage1, stage2, stage3))
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            pipeline.executeStages()
            
            // Verify all stages were executed in order
            coVerifyOrder {
                stage1.run(pipeline)
                stage2.run(pipeline)
                stage3.run(pipeline)
            }
            
            // Verify all stages completed successfully
            pipeline.stageResults shouldHaveSize 3
            pipeline.stageResults.all { it.status == Status.SUCCESS } shouldBe true
        }

        it("should stop execution when stage fails") = runTest {
            val stage1 = mockk<StageExecutor>()
            val stage2 = mockk<StageExecutor>()
            val stage3 = mockk<StageExecutor>()
            
            every { stage1.name } returns "Stage 1"
            every { stage2.name } returns "Stage 2"
            every { stage3.name } returns "Stage 3"
            
            coEvery { stage1.run(any()) } just Runs
            coEvery { stage2.run(any()) } throws Exception("Stage 2 failed")
            coEvery { stage3.run(any()) } just Runs
            
            val pipeline = createTestPipeline(stages = listOf(stage1, stage2, stage3))
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            pipeline.executeStages()
            
            // Verify only first two stages were executed
            coVerify { stage1.run(pipeline) }
            coVerify { stage2.run(pipeline) }
            coVerify(exactly = 0) { stage3.run(pipeline) }
            
            // Verify stage results
            pipeline.stageResults shouldHaveSize 2
            pipeline.stageResults[0].status shouldBe Status.SUCCESS
            pipeline.stageResults[1].status shouldBe Status.FAILURE
        }

        it("should update currentStage during execution") = runTest {
            val stage1 = mockk<StageExecutor>()
            val stage2 = mockk<StageExecutor>()
            
            every { stage1.name } returns "Build Stage"
            every { stage2.name } returns "Test Stage"
            
            val pipeline = createTestPipeline(stages = listOf(stage1, stage2))
            var capturedStages = mutableListOf<String>()
            
            coEvery { stage1.run(any()) } answers {
                capturedStages.add(pipeline.currentStage)
            }
            coEvery { stage2.run(any()) } answers {
                capturedStages.add(pipeline.currentStage)
            }
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            pipeline.executeStages()
            
            capturedStages shouldContain "Build Stage"
            capturedStages shouldContain "Test Stage"
        }

        it("should execute post-execution after all stages") = runTest {
            val stage = mockk<StageExecutor>()
            every { stage.name } returns "Test Stage"
            coEvery { stage.run(any()) } just Runs
            
            val mockPostExecution = mockk<PostExecution>()
            coEvery { mockPostExecution.run(any(), any()) } just Runs
            
            val pipeline = createTestPipeline(
                stages = listOf(stage),
                postExecution = mockPostExecution
            )
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            pipeline.executeStages()
            
            // Verify post-execution was called with correct parameters
            coVerify { mockPostExecution.run(pipeline, pipeline.stageResults) }
        }

        it("should execute post-execution even when stages fail") = runTest {
            val stage = mockk<StageExecutor>()
            every { stage.name } returns "Failing Stage"
            coEvery { stage.run(any()) } throws Exception("Stage failed")
            
            val mockPostExecution = mockk<PostExecution>()
            coEvery { mockPostExecution.run(any(), any()) } just Runs
            
            val pipeline = createTestPipeline(
                stages = listOf(stage),
                postExecution = mockPostExecution
            )
            
            mockkObject(EventManager)
            coEvery { EventManager.notify(any()) } just Runs
            
            pipeline.executeStages()
            
            // Verify post-execution was still called
            coVerify { mockPostExecution.run(pipeline, any()) }
            
            // Verify failure was recorded
            pipeline.stageResults shouldHaveSize 1
            pipeline.stageResults[0].status shouldBe Status.FAILURE
        }

        it("should measure execution time for each stage") = runTest {
            val stage = mockk<StageExecutor>()
            every { stage.name } returns "Timed Stage"
            
            // Simulate stage that takes some time
            coEvery { stage.run(any()) } coAnswers {
                kotlinx.coroutines.delay(10) // 10ms delay
            }
            
            val pipeline = createTestPipeline(stages = listOf(stage))
            
            mockkObject(EventManager)
            val capturedEvents = mutableListOf<EndEvent>()
            coEvery { EventManager.notify(any()) } answers {
                val event = firstArg<Any>()
                if (event is EndEvent) {
                    capturedEvents.add(event)
                }
            }
            
            pipeline.executeStages()
            
            // Verify timing was captured
            capturedEvents shouldHaveSize 1
            capturedEvents[0].duration shouldNotBe 0L
            capturedEvents[0].duration shouldBe >(0L)
        }

        it("should work with different agent types") {
            val dockerAgent = DockerAgent(image = "ubuntu:latest")
            val anyAgent = AnyAgent("local")
            val kubernetesAgent = KubernetesAgent(yaml = "k8s-config")
            
            val dockerPipeline = createTestPipeline(agent = dockerAgent)
            val anyPipeline = createTestPipeline(agent = anyAgent)
            val kubernetesPipeline = createTestPipeline(agent = kubernetesAgent)
            
            dockerPipeline.agent shouldBe dockerAgent
            anyPipeline.agent shouldBe anyAgent
            kubernetesPipeline.agent shouldBe kubernetesAgent
        }

        it("should handle environment variables correctly") {
            val env = EnvVars(mutableMapOf(
                "BUILD_NUMBER" to "123",
                "BRANCH_NAME" to "main",
                "WORKSPACE" to "/tmp/workspace"
            ))
            
            val pipeline = createTestPipeline(env = env)
            
            pipeline.env["BUILD_NUMBER"] shouldBe "123"
            pipeline.env["BRANCH_NAME"] shouldBe "main"
            pipeline.env["WORKSPACE"] shouldBe "/tmp/workspace"
        }

        it("should support configuration through Configurable interface") {
            val pipeline = createTestPipeline()
            val config = mapOf(
                "timeout" to "300",
                "retries" to "3"
            )
            
            // This should not throw an exception
            pipeline.configure(config)
        }
    }
})

private fun createTestPipeline(
    agent: Agent = AnyAgent("test"),
    stages: List<StageExecutor> = emptyList(),
    env: EnvVars = EnvVars(mutableMapOf()),
    postExecution: PostExecution = PostExecution(),
    config: PipelineConfigTest = PipelineConfigTest()
): Pipeline {
    return Pipeline(
        agent = agent,
        stages = stages,
        env = env,
        postExecution = postExecution,
        pipelineConfig = config
    )
}