package dev.rubentxu.pipeline.security

import dev.rubentxu.pipeline.dsl.*
import dev.rubentxu.pipeline.logger.PipelineLogger
import dev.rubentxu.pipeline.model.config.IPipelineConfig
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.should
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.types.shouldBeInstanceOf
import kotlinx.coroutines.test.runTest
import java.io.File
import java.nio.file.Files

/**
 * Example test demonstrating the GraalVM Isolate sandbox functionality
 */
class SandboxExampleTest : StringSpec({
    
    "should demonstrate secure execution with resource monitoring" {
        runTest {
            val logger = PipelineLogger.getLogger()
            
            // Create a mock config
            val config = object : IPipelineConfig {}
            
            val dslManager = DslManager(config, logger = logger)
            
            try {
                val tempDir = Files.createTempDirectory("sandbox-example").toFile()
                
                // Create a high-security execution context
                val secureContext = createHighSecurityExecutionContext(tempDir)
                
                val exampleScript = """
                    // This script demonstrates secure execution
                    console.log("Starting secure execution");
                    
                    var result = "Security sandbox working correctly!";
                    var iterations = 0;
                    
                    // Do some work to test resource monitoring
                    for (var i = 0; i < 1000; i++) {
                        iterations++;
                    }
                    
                    console.log("Completed " + iterations + " iterations");
                    result;
                """.trimIndent()
                
                logger.info("üîí Starting secure script execution example")
                
                val result = dslManager.executeContentSecurely<String>(
                    scriptContent = exampleScript,
                    engineId = "pipeline-dsl",
                    scriptName = "security-example.kts",
                    executionContext = secureContext
                )
                
                result.shouldBeInstanceOf<DslExecutionResult.Success<String>>()
                result as DslExecutionResult.Success
                
                logger.info("‚úÖ Secure execution completed successfully")
                logger.info("üìä Execution time: ${result.metadata.executionTimeMs}ms")
                logger.info("üíæ Memory used: ${result.metadata.memoryUsedMb ?: 0}MB")
                logger.info("üßµ Threads used: ${result.metadata.threadsUsed ?: 0}")
                
                // Verify the result
                result.result shouldNotBe null
                result.metadata.executionTimeMs should { it > 0 }
                
                tempDir.deleteRecursively()
                
            } finally {
                dslManager.shutdown()
            }
        }
    }
    
    "should demonstrate different isolation levels" {
        runTest {
            val logger = PipelineLogger.getLogger()
            
            val config = object : IPipelineConfig {}
            
            val dslManager = DslManager(config, logger = logger)
            
            try {
                val tempDir = Files.createTempDirectory("isolation-levels").toFile()
                
                val script = """
                    console.log("Testing isolation level");
                    "isolation test completed";
                """.trimIndent()
                
                // Test Thread-level isolation
                logger.info("üßµ Testing THREAD-level isolation")
                val threadContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    environmentVariables = mapOf("ISOLATION_LEVEL" to "THREAD"),
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 256,
                        maxCpuTimeMs = 15_000,
                        maxWallTimeMs = 30_000,
                        maxThreads = 2
                    ),
                    executionPolicy = DslExecutionPolicy(
                        isolationLevel = DslIsolationLevel.THREAD,
                        allowConcurrentExecution = false,
                        enableEventPublishing = true
                    )
                )
                
                val threadResult = dslManager.executeContentSecurely<String>(
                    scriptContent = script,
                    engineId = "pipeline-dsl",
                    scriptName = "thread-isolation.kts",
                    executionContext = threadContext
                )
                
                threadResult.shouldBeInstanceOf<DslExecutionResult.Success<String>>()
                logger.info("‚úÖ Thread-level isolation test completed")
                
                // Test Process-level isolation
                logger.info("üîí Testing PROCESS-level isolation")
                val processContext = DslExecutionContext(
                    workingDirectory = tempDir,
                    environmentVariables = mapOf("ISOLATION_LEVEL" to "PROCESS"),
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 128,
                        maxCpuTimeMs = 10_000,
                        maxWallTimeMs = 20_000,
                        maxThreads = 1
                    ),
                    executionPolicy = DslExecutionPolicy(
                        isolationLevel = DslIsolationLevel.PROCESS,
                        allowConcurrentExecution = false,
                        enableEventPublishing = true
                    )
                )
                
                val processResult = dslManager.executeContentSecurely<String>(
                    scriptContent = script,
                    engineId = "pipeline-dsl",
                    scriptName = "process-isolation.kts",
                    executionContext = processContext
                )
                
                // Process isolation may fail in this environment, but that's expected
                logger.info("üîç Process-level isolation test completed (result: ${processResult::class.simpleName})")
                
                tempDir.deleteRecursively()
                
            } finally {
                dslManager.shutdown()
            }
        }
    }
    
    "should demonstrate security policy validation" {
        runTest {
            val logger = PipelineLogger.getLogger()
            val sandboxManager = SandboxManager(logger)
            
            try {
                logger.info("üõ°Ô∏è Testing security policy validation")
                
                // Valid policy
                val validPolicy = createSecureExecutionContext(
                    maxMemoryMb = 256,
                    maxCpuTimeMs = 15_000
                )
                
                val validResult = sandboxManager.validateSecurityPolicy(validPolicy)
                validResult.isValid shouldBe true
                logger.info("‚úÖ Valid policy passed validation")
                
                // Invalid policy - excessive resources
                val invalidPolicy = DslExecutionContext(
                    workingDirectory = Files.createTempDirectory("policy-test").toFile(),
                    environmentVariables = emptyMap(),
                    resourceLimits = DslResourceLimits(
                        maxMemoryMb = 5000, // Exceeds limit
                        maxCpuTimeMs = 600_000, // Exceeds limit
                        maxWallTimeMs = 60_000,
                        maxThreads = 50 // Exceeds limit
                    ),
                    executionPolicy = DslExecutionPolicy(
                        isolationLevel = DslIsolationLevel.THREAD,
                        allowConcurrentExecution = false,
                        enableEventPublishing = true
                    )
                )
                
                val invalidResult = sandboxManager.validateSecurityPolicy(invalidPolicy)
                invalidResult.isValid shouldBe false
                invalidResult.issues shouldNotBe emptyList<String>()
                
                logger.info("‚ùå Invalid policy correctly rejected: ${invalidResult.issues}")
                
            } finally {
                sandboxManager.shutdown()
            }
        }
    }
})