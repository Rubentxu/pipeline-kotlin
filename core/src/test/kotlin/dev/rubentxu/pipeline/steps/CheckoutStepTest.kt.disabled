package dev.rubentxu.pipeline.steps

import dev.rubentxu.pipeline.PipelineConfigTest
import dev.rubentxu.pipeline.context.StepExecutionContext
import dev.rubentxu.pipeline.logger.IPipelineLogger
import dev.rubentxu.pipeline.model.pipeline.*
import dev.rubentxu.pipeline.model.scm.*
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.string.shouldContain
import io.kotest.matchers.string.shouldStartWith
import io.kotest.assertions.throwables.shouldThrow
import io.mockk.*
import kotlinx.coroutines.test.runTest
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

class CheckoutStepTest : DescribeSpec({

    describe("CheckoutStep") {
        
        beforeEach {
            clearAllMocks()
        }
        
        afterEach {
            unmockkAll()
        }

        it("should initialize with correct context") {
            val mockContext = createMockContext()
            
            val checkoutStep = CheckoutStep(mockContext)
            
            checkoutStep shouldNotBe null
        }

        it("should execute GitScm checkout successfully") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main"
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockRepo = mockk<org.eclipse.jgit.lib.Repository>()
            val mockCloneCommand = mockk<org.eclipse.jgit.api.CloneCommand>()
            val mockCheckoutCommand = mockk<org.eclipse.jgit.api.CheckoutCommand>()
            val mockObjectId = mockk<org.eclipse.jgit.lib.ObjectId>()
            
            every { org.eclipse.jgit.api.Git.cloneRepository() } returns mockCloneCommand
            every { mockCloneCommand.setURI(any()) } returns mockCloneCommand
            every { mockCloneCommand.setDirectory(any()) } returns mockCloneCommand
            every { mockCloneCommand.setBranch(any()) } returns mockCloneCommand
            every { mockCloneCommand.call() } returns mockGit
            
            every { mockGit.checkout() } returns mockCheckoutCommand
            every { mockCheckoutCommand.setName(any()) } returns mockCheckoutCommand
            every { mockCheckoutCommand.call() } returns mockk()
            
            every { mockGit.repository } returns mockRepo
            every { mockRepo.resolve("HEAD") } returns mockObjectId
            every { mockObjectId.name } returns "abc123commit"
            every { mockGit.close() } just Runs
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            result.commitId shouldBe "abc123commit"
            result.branch shouldBe "main"
            result.url shouldBe "https://github.com/test/repo.git"
        }

        it("should throw exception for unsupported SCM type") = runTest {
            val mockContext = createMockContext()
            val unsupportedScm = object : Scm() {
                override val url = "https://example.com/repo"
                override val credentialsId = null
            }
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val exception = shouldThrow<UnsupportedOperationException> {
                checkoutStep.execute(unsupportedScm)
            }
            
            exception.message shouldContain "SCM type"
            exception.message shouldContain "is not supported"
        }

        it("should handle existing repository correctly") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "develop"
            )
            
            // Mock existing repository
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns true  // Repository exists
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockRepo = mockk<org.eclipse.jgit.lib.Repository>()
            val mockCheckoutCommand = mockk<org.eclipse.jgit.api.CheckoutCommand>()
            val mockObjectId = mockk<org.eclipse.jgit.lib.ObjectId>()
            
            every { org.eclipse.jgit.api.Git.open(any<File>()) } returns mockGit
            every { mockGit.checkout() } returns mockCheckoutCommand
            every { mockCheckoutCommand.setName("develop") } returns mockCheckoutCommand
            every { mockCheckoutCommand.call() } returns mockk()
            
            every { mockGit.repository } returns mockRepo
            every { mockRepo.resolve("HEAD") } returns mockObjectId
            every { mockObjectId.name } returns "def456commit"
            every { mockGit.close() } just Runs
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            result.commitId shouldBe "def456commit"
            result.branch shouldBe "develop"
            
            verify { org.eclipse.jgit.api.Git.open(any<File>()) }
            verify(exactly = 0) { org.eclipse.jgit.api.Git.cloneRepository() }
        }

        it("should handle workspace wiping") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main",
                extensions = listOf(WipeWorkspace(wipeWorkspace = true))
            )
            
            // Mock file operations
            val mockPath = mockk<Path>()
            val mockFile = mockk<File>()
            mockkStatic(Files::class)
            mockkStatic(Paths::class)
            
            every { Paths.get(any<String>()) } returns mockPath
            every { mockPath.resolve(any<String>()) } returns mockPath
            every { Files.exists(mockPath) } returns true
            every { Files.createDirectories(any()) } returns mockPath
            every { mockPath.toAbsolutePath() } returns mockPath
            every { mockPath.toString() } returns "/test/workspace"
            every { mockPath.toFile() } returns mockFile
            every { mockFile.deleteRecursively() } returns true
            
            // Mock Git operations
            setupBasicGitMocks()
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            verify { mockFile.deleteRecursively() }
        }

        it("should apply clone options correctly") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main",
                extensions = listOf(
                    CloneOption(
                        shallow = true,
                        noTags = true,
                        timeout = 30
                    )
                )
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations with clone options
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockCloneCommand = mockk<org.eclipse.jgit.api.CloneCommand>()
            
            every { org.eclipse.jgit.api.Git.cloneRepository() } returns mockCloneCommand
            every { mockCloneCommand.setURI(any()) } returns mockCloneCommand
            every { mockCloneCommand.setDirectory(any()) } returns mockCloneCommand
            every { mockCloneCommand.setBranch(any()) } returns mockCloneCommand
            every { mockCloneCommand.setCloneAllBranches(false) } returns mockCloneCommand
            every { mockCloneCommand.setCloneSubmodules(false) } returns mockCloneCommand
            every { mockCloneCommand.setNoTags() } returns mockCloneCommand
            every { mockCloneCommand.setTimeout(30) } returns mockCloneCommand
            every { mockCloneCommand.call() } returns mockGit
            
            setupBasicGitOperations(mockGit)
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            verify { mockCloneCommand.setCloneAllBranches(false) }
            verify { mockCloneCommand.setNoTags() }
            verify { mockCloneCommand.setTimeout(30) }
        }

        it("should handle credentials from environment") = runTest {
            val mockContext = createMockContext(
                environment = mapOf(
                    "GIT_USERNAME" to "testuser",
                    "GIT_PASSWORD" to "testpass"
                )
            )
            val gitScm = GitScm(
                url = "https://github.com/test/private-repo.git",
                branch = "main",
                credentialsId = "git-credentials"
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockCloneCommand = mockk<org.eclipse.jgit.api.CloneCommand>()
            val mockCredentialsProvider = mockk<org.eclipse.jgit.transport.CredentialsProvider>()
            
            every { org.eclipse.jgit.api.Git.cloneRepository() } returns mockCloneCommand
            every { mockCloneCommand.setURI(any()) } returns mockCloneCommand
            every { mockCloneCommand.setDirectory(any()) } returns mockCloneCommand
            every { mockCloneCommand.setBranch(any()) } returns mockCloneCommand
            every { mockCloneCommand.setCredentialsProvider(any()) } returns mockCloneCommand
            every { mockCloneCommand.call() } returns mockGit
            
            setupBasicGitOperations(mockGit)
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            verify { mockCloneCommand.setCredentialsProvider(any()) }
        }

        it("should handle submodule operations") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main",
                extensions = listOf(
                    SubmoduleOption(
                        disableSubmodules = false,
                        recursiveSubmodules = true
                    )
                )
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations with submodules
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockSubmoduleInitCommand = mockk<org.eclipse.jgit.api.SubmoduleInitCommand>()
            val mockSubmoduleUpdateCommand = mockk<org.eclipse.jgit.api.SubmoduleUpdateCommand>()
            
            setupBasicGitMocks(mockGit)
            
            every { mockGit.submoduleInit() } returns mockSubmoduleInitCommand
            every { mockSubmoduleInitCommand.call() } returns mockk()
            every { mockGit.submoduleUpdate() } returns mockSubmoduleUpdateCommand
            every { mockSubmoduleUpdateCommand.call() } returns mockk()
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            verify { mockGit.submoduleInit() }
            verify { mockGit.submoduleUpdate() }
        }

        it("should handle submodule failures gracefully") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main",
                extensions = listOf(SubmoduleOption(disableSubmodules = false))
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations with submodule failure
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockSubmoduleInitCommand = mockk<org.eclipse.jgit.api.SubmoduleInitCommand>()
            
            setupBasicGitMocks(mockGit)
            
            every { mockGit.submoduleInit() } returns mockSubmoduleInitCommand
            every { mockSubmoduleInitCommand.call() } throws RuntimeException("Submodule failed")
            
            val checkoutStep = CheckoutStep(mockContext)
            
            // Should not throw exception - submodule failures are handled gracefully
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true // Main checkout should still succeed
        }

        it("should skip submodules when disabled") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main",
                extensions = listOf(SubmoduleOption(disableSubmodules = true))
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            setupBasicGitMocks(mockGit)
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            verify(exactly = 0) { mockGit.submoduleInit() }
        }

        it("should handle unknown commit ID gracefully") = runTest {
            val mockContext = createMockContext()
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main"
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations with null commit
            mockkStatic("org.eclipse.jgit.api.Git")
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            val mockRepo = mockk<org.eclipse.jgit.lib.Repository>()
            val mockCloneCommand = mockk<org.eclipse.jgit.api.CloneCommand>()
            val mockCheckoutCommand = mockk<org.eclipse.jgit.api.CheckoutCommand>()
            
            every { org.eclipse.jgit.api.Git.cloneRepository() } returns mockCloneCommand
            every { mockCloneCommand.setURI(any()) } returns mockCloneCommand
            every { mockCloneCommand.setDirectory(any()) } returns mockCloneCommand
            every { mockCloneCommand.setBranch(any()) } returns mockCloneCommand
            every { mockCloneCommand.call() } returns mockGit
            
            every { mockGit.checkout() } returns mockCheckoutCommand
            every { mockCheckoutCommand.setName(any()) } returns mockCheckoutCommand
            every { mockCheckoutCommand.call() } returns mockk()
            
            every { mockGit.repository } returns mockRepo
            every { mockRepo.resolve("HEAD") } returns null  // No commit found
            every { mockGit.close() } just Runs
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            result.commitId shouldBe "unknown"
        }

        it("should handle different Git token types") = runTest {
            val mockContext = createMockContext(
                environment = mapOf(
                    "GIT_USERNAME" to "testuser",
                    "GIT_TOKEN" to "ghp_token123"  // Using token instead of password
                )
            )
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "main",
                credentialsId = "github-token"
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            setupBasicGitMocks(mockGit)
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
        }

        it("should handle checkout without credentials gracefully") = runTest {
            val mockContext = createMockContext(environment = emptyMap())
            val gitScm = GitScm(
                url = "https://github.com/test/public-repo.git",
                branch = "main",
                credentialsId = "missing-credentials"
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            setupBasicGitMocks(mockGit)
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true  // Should work for public repos
        }

        it("should log checkout operations correctly") = runTest {
            val mockLogger = mockk<IPipelineLogger>()
            every { mockLogger.info(any()) } just Runs
            every { mockLogger.error(any()) } just Runs
            
            val mockContext = createMockContext(logger = mockLogger)
            val gitScm = GitScm(
                url = "https://github.com/test/repo.git",
                branch = "feature-branch"
            )
            
            // Mock file operations
            mockkStatic(Files::class)
            every { Files.exists(any()) } returns false
            every { Files.createDirectories(any()) } returns mockk()
            
            // Mock Git operations
            val mockGit = mockk<org.eclipse.jgit.api.Git>()
            setupBasicGitMocks(mockGit)
            
            val checkoutStep = CheckoutStep(mockContext)
            
            val result = checkoutStep.execute(gitScm)
            
            result.success shouldBe true
            verify { mockLogger.info(match { it.contains("checkout https://github.com/test/repo.git") }) }
            verify { mockLogger.info(match { it.contains("Cloning repository from") }) }
            verify { mockLogger.info(match { it.contains("Checkout completed successfully") }) }
        }
    }
})

private fun createMockContext(
    workingDirectory: String = "/test/workspace",
    environment: Map<String, String> = emptyMap(),
    logger: IPipelineLogger = mockk(relaxed = true)
): StepExecutionContext {
    val mockPipeline = mockk<Pipeline>()
    every { mockPipeline.workingDir } returns Paths.get(workingDirectory)
    every { mockPipeline.env } returns EnvVars(environment.toMutableMap())
    
    return StepExecutionContext.create(
        pipeline = mockPipeline,
        logger = logger,
        workingDirectory = workingDirectory,
        environment = environment
    )
}

private fun setupBasicGitMocks(mockGit: org.eclipse.jgit.api.Git? = null) {
    mockkStatic("org.eclipse.jgit.api.Git")
    val git = mockGit ?: mockk<org.eclipse.jgit.api.Git>()
    val mockCloneCommand = mockk<org.eclipse.jgit.api.CloneCommand>()
    
    every { org.eclipse.jgit.api.Git.cloneRepository() } returns mockCloneCommand
    every { mockCloneCommand.setURI(any()) } returns mockCloneCommand
    every { mockCloneCommand.setDirectory(any()) } returns mockCloneCommand
    every { mockCloneCommand.setBranch(any()) } returns mockCloneCommand
    every { mockCloneCommand.call() } returns git
    
    setupBasicGitOperations(git)
}

private fun setupBasicGitOperations(mockGit: org.eclipse.jgit.api.Git) {
    val mockRepo = mockk<org.eclipse.jgit.lib.Repository>()
    val mockCheckoutCommand = mockk<org.eclipse.jgit.api.CheckoutCommand>()
    val mockObjectId = mockk<org.eclipse.jgit.lib.ObjectId>()
    
    every { mockGit.checkout() } returns mockCheckoutCommand
    every { mockCheckoutCommand.setName(any()) } returns mockCheckoutCommand
    every { mockCheckoutCommand.call() } returns mockk()
    
    every { mockGit.repository } returns mockRepo
    every { mockRepo.resolve("HEAD") } returns mockObjectId
    every { mockObjectId.name } returns "test123commit"
    every { mockGit.close() } just Runs
}