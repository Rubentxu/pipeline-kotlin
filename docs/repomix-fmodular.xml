This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.groovy, **/*.yaml
- Files matching these patterns are excluded: **/*test.groovy, **/*Spec.groovy
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
bin/
  main/
    es/
      giss/
        framework/
          configuration/
            config/
              adapters/
                ArtifactsRepositoryDefaultConfigAdapter.groovy
                BackendConfigAdapter.groovy
                DefaultProjectConfigAdapter.groovy
                EmailsXmlConfigAdapter.groovy
                JenkinsFileConfigAdapter.groovy
                LocalPipelineYamlConfigAdapter.groovy
                PipelineYamlConfigAdapter.groovy
                ReleaseConfigAdapter.groovy
              provider/
                ArtifactsHelmXmlReader.groovy
              vo/
                IdentifiersEnum.groovy
          core/
            cdi/
              annotations/
                Inject.groovy
                PipelineComponent.groovy
                Qualifier.groovy
              dependencies/
                DependencyGraph.groovy
                DependencyKey.groovy
                DependencyResolver.groovy
                IDependencyResolver.groovy
                Node.groovy
              scanner/
                fiters/
                  AcceptEverythingResourceFilter.groovy
                  AnnotatedClassResourceFilter.groovy
                  ChainedResourceFilter.groovy
                  ExtendsClassResourceFilter.groovy
                interfaces/
                  ResourceFilter.groovy
                  ResourceLoader.groovy
                  ResourceVisitor.groovy
                ClassesInPackageScanner.groovy
                PackageScanner.groovy
              ConfigurationPriority.groovy
              ContextSinglenton.groovy
              IServiceLocator.groovy
              ServicesFactory.groovy
            config/
              ConfigClient.groovy
            events/
              interfaces/
                DataModel.groovy
                PipelineModel.groovy
                ProjectDescriptorModel.groovy
                TelemetryModel.groovy
              CoreEvent.groovy
              PipelineEvent.groovy
              ProjectEvent.groovy
              TelemetryEvent.groovy
            interfaces/
              AssignableArtifactsRepository.groovy
              AutomationToolDefinition.groovy
              Configurable.groovy
              Derivable.groovy
              IBuildAutomationTool.groovy
              IConfigAdapter.groovy
              IConfigClient.groovy
              Identifiable.groovy
              IDeployAutomationTool.groovy
              IGitService.groovy
              ILogger.groovy
              Initializable.groovy
              INotificationSender.groovy
              IPipelineContext.groovy
              IReleaseStages.groovy
              IResourceParser.groovy
              IStage.groovy
              ISteps.groovy
              ITool.groovy
              IToolsStrategy.groovy
              IToolVersionable.groovy
              ModelCloneable.groovy
              StructuredResource.groovy
              Versionable.groovy
            logger/
              AnsiColor.groovy
              Logger.groovy
              LogLevel.groovy
            storage/
              interfaces/
                Effect.groovy
                Mutation.groovy
                OverrideHandler.groovy
                Selector.groovy
                StateObserver.groovy
              mutations/
                ObservabilityHubMutation.groovy
                PipelineDefinitionMutation.groovy
                ProjectDescriptorMutation.groovy
                ReleaseDescriptorMutation.groovy
              overrides/
                SemanticVersionOverrideHandler.groovy
              ObjectCreator.groovy
              ObjectMerger.groovy
              Store.groovy
            tools/
              interfaces/
                IGitTool.groovy
                ISemanticRelease.groovy
                IToolsManager.groovy
                IWorkspaceTool.groovy
              restClients/
                interfaces/
                  IGitLabTool.groovy
                  IRestClient.groovy
                CredentialType.groovy
                GitLabTool.groovy
                RestClient.groovy
              strategies/
                AlternativesToolsManagerStrategy.groovy
                AsdfToolsManagerStrategy.groovy
                CustomScriptToolsManagerStrategy.groovy
                GraalVmToolsManagerStrategy.groovy
              GitTool.groovy
              ProxyHost.groovy
              ReleaseController.groovy
              ToolsManager.groovy
              WorkspaceTool.groovy
            utils/
              interfaces/
                IExpressionEvaluator.groovy
              ArtifactsHelmXmlReader.groovy
              ExpressionEvaluator.groovy
              MapUtils.groovy
            vo/
              events/
                StageSkippedEvent.groovy
                StageStarted.groovy
              observability/
                events/
                  ProcessedCofigAdaptersEvent.groovy
                  StageCompletedEvent.groovy
                  StageErrorEvent.groovy
                  StageSkippedEvent.groovy
                  StageStarted.groovy
                  StageUnstableEvent.groovy
                ObservabilityHub.groovy
                TelemetryMap.groovy
              pipeline/
                AlternativesToolsDescriptor.groovy
                AsdfToolsManagerDescriptor.groovy
                CacheDescriptor.groovy
                CustomScriptManagerDescriptor.groovy
                GraalVmToolsDescriptor.groovy
                JobStatus.groovy
                PipelineDefinition.groovy
                PipelineSettings.groovy
                PipelineStatus.groovy
                ProxySettings.groovy
                ToolsManagerDescriptor.groovy
              project/
                strategies/
                  BuildStrategy.groovy
                  DeployStrategy.groovy
                  ProjectActionStrategy.groovy
                  PublishStrategy.groovy
                  RollbackStrategy.groovy
                  TestStrategy.groovy
                  UndeployStrategy.groovy
                ArtifactsRepository.groovy
                ArtifactsRepositoryType.groovy
                ArtifactType.groovy
                DeployTarget.groovy
                Email.groovy
                Metadata.groovy
                Notification.groovy
                ProjectConfigurationFile.groovy
                ProjectDescriptor.groovy
                ProjectSettings.groovy
                ProjectStatus.groovy
                ProjectTool.groovy
                ScannerToolModel.groovy
                ScannerToolResult.groovy
                SourceRepository.groovy
                StructuredResourceMetadata.groovy
                VendorService.groovy
              release/
                events/
                  ReleaseEvent.groovy
                interfaces/
                  ChangeType.groovy
                  IChangeSet.groovy
                  IGitCommit.groovy
                  ReleaseModel.groovy
                Approval.groovy
                ApprovalRule.groovy
                Artifact.groovy
                Changelog.groovy
                CodeReviewer.groovy
                ConventionalCommit.groovy
                DeployEnvironment.groovy
                GitCommit.groovy
                GitCommitContext.groovy
                GitflowPhase.groovy
                GitlabUser.groovy
                MergeRequest.groovy
                ReleaseConfig.groovy
                ReleaseDescriptor.groovy
                ReleasePromotion.groovy
                ReleaseStatus.groovy
                SemanticVersion.groovy
              resources/
                http/
                  FormDataCollection.groovy
                  HttpResponse.groovy
                  RequestOptions.groovy
              CollectionResources.groovy
              ConfigToolFileStrategy.groovy
              GenericResource.groovy
              WatchFiles.groovy
            GitStages.groovy
            PipelineContext.groovy
            ReleaseStages.groovy
            Stage.groovy
            Steps.groovy
    cdi.groovy
    config.groovy
    errorHandler.groovy
    gitlab.groovy
    gitTool.groovy
    is.groovy
    jsonPath.groovy
    loggerTool.groovy
    not.groovy
    releaseStages.groovy
    restClient.groovy
    when.groovy
    workspace.groovy
  test/
    es/
      giss/
        framework/
          core/
            config/
              ConfigAdapterHelmTool.groovy
              ConfigAdapterMaventTool.groovy
              ConfigAdapterMaventToolOther.groovy
              ConfigAdapterToolsManager.groovy
            storage/
              TestArtifact.groovy
            utils/
              TestHelmDeployStrategy.groovy
    fixtures/
      core/
        cdi/
          config/
            adapters/
              ExampleConfigAdapter.groovy
              TestConfigAdapter.groovy
            notAnnotated/
              NotAnnotatedConfigAdapter.groovy
            notQualified/
              ExampleConfigAdapter.groovy
              TestConfigAdapter.groovy
          cyclicdependencies/
            interfaces/
              IAnimalCD.groovy
              ICarCD.groovy
              ICompanyCD.groovy
              IHumanCD.groovy
              IVehicleCD.groovy
            AnimalCarCD.groovy
            CarCompanyCD.groovy
            DuckCD.groovy
            GissCD.groovy
            TaxiDriverCD.groovy
            TruckDriverCD.groovy
          interfaces/
            IBook.groovy
            IDummy.groovy
            IGreeting.groovy
          legacy/
            interfaces/
              IExampleA.groovy
              IExampleB.groovy
              IExampleC.groovy
              IExampleE.groovy
              IExampleH.groovy
              IExampleZ.groovy
            ExampleA.groovy
            ExampleB.groovy
            ExampleC.groovy
            ExampleD.groovy
            ExampleE.groovy
            ExampleH.groovy
          nocyclicdependencies/
            interfaces/
              IAnimal.groovy
              ICar.groovy
              ICompany.groovy
              IHuman.groovy
              IVehicle.groovy
            AnimalCar.groovy
            CarCompany.groovy
            Duck.groovy
            Giss.groovy
            TaxiDriver.groovy
            TruckDriver.groovy
          withdiprovider/
            BookAnnotated.groovy
            DummyNotAnnotated.groovy
            GreetingNotAnnotated.groovy
          AnnotatedClass.groovy
          AnnotatedClassWithoutPipelineComponent.groovy
          AnnotatedClassWithQualifier.groovy
        TestStage.groovy
    naua/
      pipeline.yaml
  testFixtures/
    es/
      giss/
        framework/
          fixtures/
            mocks/
              credentials/
                Credentials.groovy
                ProviderCredentialsMock.groovy
              AssertFailException.groovy
              HttpClientMock.groovy
              HttpResponseMock.groovy
              MethodInvocation.groovy
              MethodInvocationRecorder.groovy
              NamedArgsMethodInvocation.groovy
              PositionalArgsMethodInvocation.groovy
              StepsMock.groovy
              TestContext.groovy
              TestException.groovy
    naua/
      pipeline.yaml
src/
  es/
    giss/
      framework/
        configuration/
          config/
            adapters/
              BackendConfigAdapter.groovy
              DefaultProjectDescriptorConfigAdapter.groovy
              EmailsXmlConfigAdapter.groovy
              JenkinsFileConfigAdapter.groovy
            provider/
              ArtifactsHelmXmlReader.groovy
            BackendRestClient.groovy
        core/
          cdi/
            annotations/
              Inject.groovy
              PipelineComponent.groovy
              Qualifier.groovy
            dependencies/
              DependencyGraph.groovy
              DependencyKey.groovy
              DependencyResolver.groovy
              IDependencyResolver.groovy
              Node.groovy
            scanner/
              fiters/
                AcceptEverythingResourceFilter.groovy
                AnnotatedClassResourceFilter.groovy
                ChainedResourceFilter.groovy
                ExtendsClassResourceFilter.groovy
              interfaces/
                ResourceFilter.groovy
                ResourceLoader.groovy
                ResourceVisitor.groovy
              ClassesInPackageScanner.groovy
              PackageScanner.groovy
            ConfigurationPriority.groovy
            ContextSinglenton.groovy
            IServiceLocator.groovy
          config/
            ConfigClient.groovy
          events/
            interfaces/
              DataModel.groovy
              PipelineModel.groovy
              ProjectDescriptorModel.groovy
              TelemetryModel.groovy
            ConfiguredPipelineEvent.groovy
            ConfiguredProjectDescriptorEvent.groovy
            PipelineEvent.groovy
            TelemetryEvent.groovy
          interfaces/
            AssignableArtifactsRepository.groovy
            AutomationToolDefinition.groovy
            Configurable.groovy
            IArtifactRepositoryType.groovy
            IArtifactType.groovy
            IBuildAutomationTool.groovy
            IConfigAdapter.groovy
            IConfigClient.groovy
            Identifiable.groovy
            IDeployAutomationTool.groovy
            ILogger.groovy
            Initializable.groovy
            INotificationSender.groovy
            IPipelineContext.groovy
            IStage.groovy
            ISteps.groovy
            ITool.groovy
            IToolVersionable.groovy
            Versionable.groovy
          logger/
            AnsiColor.groovy
            Logger.groovy
            LogLevel.groovy
          storage/
            interfaces/
              Effect.groovy
              Mutation.groovy
              Selector.groovy
            mutations/
              PipelineMutation.groovy
              ProjectDescriptorMutation.groovy
            Store.groovy
          tools/
            interfaces/
              IGitTool.groovy
              IToolsManager.groovy
              IWorkspaceTool.groovy
            restClients/
              interfaces/
                IGitLabTool.groovy
                IRestClient.groovy
              CredentialType.groovy
              GitLabTool.groovy
              RestClient.groovy
            GitTool.groovy
            ProxyHost.groovy
            ToolsManager.groovy
            WorkspaceTool.groovy
          utils/
            interfaces/
              IExpressionEvaluator.groovy
            ExpressionEvaluator.groovy
            MapUtils.groovy
            XmlUtils.groovy
          vo/
            events/
              ArtifactCreatedEvent.groovy
              StageCompletedEvent.groovy
              StageErrorEvent.groovy
              StageStarted.groovy
            observability/
              ObservabilityHub.groovy
              TelemetryMap.groovy
            pipeline/
              AlternativesToolsDescriptor.groovy
              AsdfToolsManagerDescriptor.groovy
              CacheDescriptor.groovy
              PipelineDefinition.groovy
              PipelineSettings.groovy
              ProxySettings.groovy
              ToolsManagerDescriptor.groovy
            project/
              strategies/
                BuildStrategy.groovy
                DeployStrategy.groovy
                ProjectActionStrategy.groovy
                ProjectActionStrategyManager.groovy
                PublishStrategy.groovy
                RollbackStrategy.groovy
                TestStrategy.groovy
                UndeployStrategy.groovy
              Artifact.groovy
              ArtifactsRepository.groovy
              DeployTarget.groovy
              Email.groovy
              Metadata.groovy
              Notification.groovy
              ProjectDescriptor.groovy
              ProjectSettings.groovy
              ProjectStatus.groovy
              ProjectTool.groovy
              ScannerTool.groovy
              SourceRepository.groovy
            resources/
              http/
                FormDataCollection.groovy
                HttpResponse.groovy
                RequestOptions.groovy
              ProjectDefinitionFile.groovy
            WatchFiles.groovy
          PipelineContext.groovy
          Stage.groovy
          Steps.groovy
test/
  groovy/
    es/
      giss/
        framework/
          core/
            config/
              ConfigAdapterHelmTool.groovy
              ConfigAdapterMaventTool.groovy
              ConfigAdapterMaventToolOther.groovy
              ConfigAdapterToolsManager.groovy
    fixtures/
      core/
        cdi/
          config/
            adapters/
              ExampleConfigAdapter.groovy
              TestConfigAdapter.groovy
            notAnnotated/
              NotAnnotatedConfigAdapter.groovy
            notQualified/
              ExampleConfigAdapter.groovy
              TestConfigAdapter.groovy
          cyclicdependencies/
            interfaces/
              IAnimalCD.groovy
              ICarCD.groovy
              ICompanyCD.groovy
              IHumanCD.groovy
              IVehicleCD.groovy
            AnimalCarCD.groovy
            CarCompanyCD.groovy
            DuckCD.groovy
            GissCD.groovy
            TaxiDriverCD.groovy
            TruckDriverCD.groovy
          interfaces/
            IBook.groovy
            IDummy.groovy
            IGreeting.groovy
          legacy/
            interfaces/
              IExampleA.groovy
              IExampleB.groovy
              IExampleC.groovy
              IExampleE.groovy
              IExampleH.groovy
              IExampleZ.groovy
            ExampleA.groovy
            ExampleB.groovy
            ExampleC.groovy
            ExampleD.groovy
            ExampleE.groovy
            ExampleH.groovy
          nocyclicdependencies/
            interfaces/
              IAnimal.groovy
              ICar.groovy
              ICompany.groovy
              IHuman.groovy
              IVehicle.groovy
            AnimalCar.groovy
            CarCompany.groovy
            Duck.groovy
            Giss.groovy
            TaxiDriver.groovy
            TruckDriver.groovy
          withdiprovider/
            BookAnnotated.groovy
            DummyNotAnnotated.groovy
            GreetingNotAnnotated.groovy
          AnnotatedClass.groovy
          AnnotatedClassWithoutPipelineComponent.groovy
          AnnotatedClassWithQualifier.groovy
        TestStage.groovy
testFixtures/
  groovy/
    es/
      giss/
        framework/
          fixtures/
            mocks/
              credentials/
                Credentials.groovy
                ProviderCredentialsMock.groovy
              AssertFailException.groovy
              HttpClientMock.groovy
              HttpResponseMock.groovy
              MethodInvocation.groovy
              MethodInvocationRecorder.groovy
              NamedArgsMethodInvocation.groovy
              PositionalArgsMethodInvocation.groovy
              StepsMock.groovy
              TestContext.groovy
              TestException.groovy
            support/
              MapUtils.groovy
vars/
  cdi.groovy
  config.groovy
  gitlab.groovy
  gitTool.groovy
  jsonPath.groovy
  loggerTool.groovy
  restClient.groovy
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="bin/main/es/giss/framework/core/cdi/annotations/Inject.groovy">
package es.giss.framework.core.cdi.annotations

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.FIELD])
@interface Inject {

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/annotations/PipelineComponent.groovy">
package es.giss.framework.core.cdi.annotations

import es.giss.framework.core.cdi.ConfigurationPriority

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target


@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE])
@interface PipelineComponent {

    String name() default ''

    ConfigurationPriority priority() default ConfigurationPriority.LOWEST

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/annotations/Qualifier.groovy">
package es.giss.framework.core.cdi.annotations

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.FIELD, ElementType.PARAMETER])
@interface Qualifier {

    String value() default ''

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/dependencies/DependencyGraph.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.Qualifier

import java.lang.annotation.Annotation
import java.lang.reflect.Constructor

class DependencyGraph {

    private final Map<DependencyKey, Node> graph = [:]

    @NonCPS
    Node addNode(DependencyKey key, Class<?> clazz) {
        if (graph.containsKey(key)) {
            throw new Exception("""The interfaz ${key.type.simpleName} is already registered with qualifier name '${key.name}'.
              Please ensure that the class ${clazz.name} is annotated with @PipelineComponent and the qualifier name is unique.                                   
            """)
        }
        Node node = new Node(key, clazz)
        graph.put(key, node)
        return node
    }

    @NonCPS
    List<Node> resolveDependencies() {
        for (Node node : graph.values()) {
            addDependencies(node)
        }
        return sortNodesByDependencies()
    }

    @NonCPS
    private void addDependencies(Node node) {
        Class<?> clazz = node.getClazz()
        Constructor<?> constructor = clazz.getConstructors()[0]
        Annotation[][] paramAnnotations = constructor.getParameterAnnotations()
        Class<?>[] paramTypes = constructor.getParameterTypes()

        for (int i = 0; i < paramTypes.length; i++) {
            String name = ''
            for (Annotation annotation : paramAnnotations[i]) {
                if (annotation instanceof Qualifier) {
                    name = ((Qualifier) annotation).value()
                }
            }

            DependencyKey keyDependency = resolveDependencyKey(paramTypes[i], name, node.getKey().getPriority())
            Node paramNode = graph.get(keyDependency)

            if (paramNode == null) {
                throw new Exception("Dependency not found: ${keyDependency} for ${node.clazz.name}. Check if the class exists or the qualifier name is correct")
            }
            node.addDependency(paramNode)
        }
    }

    @NonCPS
    private List<Node> sortNodesByDependencies() {
        Set<Class> references = findCyclicReferences()

        if (references.size() > 0) {
            throw new Exception("Circular dependency detected: ${references.collect { it.name }.join(' depends on ')}")
        }

        List<Node> nodes = new ArrayList<>(graph.values())
        List<Node> sortedNodes = new ArrayList<>(nodes.size())
        Set<Node> visited = [] as Set

        for (Node node : nodes) {
            topologicalSort(node, visited, sortedNodes)
        }

        return sortedNodes.reverse()
    }

    @NonCPS
    private void topologicalSort(Node node, Set<Node> visited, List<Node> sortedNodes) {
        if (!visited.any { it.key == node.key }) {
            visited.add(node)

            for (Node dependency : node.getDependencies()) {
                topologicalSort(dependency, visited, sortedNodes)
            }
            sortedNodes.add(0, node)
        }
    }

    @NonCPS
    private Set<Class> findCyclicReferences() {
        Set<Node> visited = [] as Set
        Set<Node> recursionStack = [] as Set

        for (Node node : graph.values()) {
            if (detectCycle(node, visited, recursionStack)) {
                return recursionStack.collect { it.clazz }
            }
        }
        return [] as Set
    }

    @NonCPS
    private boolean detectCycle(Node node, Set<Node> visited, Set<Node> recursionStack) {
        if (recursionStack.contains(node)) {
            return true
        }

        if (visited.contains(node)) {
            return false
        }

        visited.add(node)
        recursionStack.add(node)

        for (Node dependency : node.getDependencies()) {
            if (detectCycle(dependency, visited, recursionStack)) {
                return true
            }
        }

        recursionStack.remove(node)
        return false
    }

    @NonCPS
    static DependencyKey resolveDependencyKey(Class type, String name, ConfigurationPriority priority = ConfigurationPriority.LOW) {
        DependencyKey dependencyKey = new DependencyKey(type, name, priority)
        return dependencyKey
    }

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/dependencies/DependencyKey.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority


class DependencyKey {

    String name
    Class<?> type
    ConfigurationPriority priority

    DependencyKey(
            Class<?> type,
            String name = '',
            ConfigurationPriority priority = ConfigurationPriority.LOW
    ) {
        this.name = name
        this.type = type
        this.priority = priority
    }

    @NonCPS
    @Override
    boolean equals(Object obj) {
        if (obj == null) {
            return false
        }
        if (obj instanceof DependencyKey) {
            DependencyKey other = (DependencyKey) obj
            return name.equals(other.name) && type.equals(other.type)
        }
        return false
    }

    @NonCPS
    @Override
    int hashCode() {
        return Objects.hash(name, type.name)
    }

    @NonCPS
    @Override
    String toString() {
        return "DependencyKey name: $name, type: $type, priority: $priority"
    }

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/dependencies/DependencyResolver.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier

import java.lang.reflect.Field
import java.util.concurrent.ConcurrentHashMap

class DependencyResolver implements IDependencyResolver {
    private Map<DependencyKey, Object> instances
    private DependencyGraph graph

    DependencyResolver() {
        graph = new DependencyGraph()
        instances = new ConcurrentHashMap<>()
    }

    @NonCPS
    Map<DependencyKey, Object> getInstances() {
        return instances
    }

    @NonCPS
    int getSizedInstances() {
        return instances.size()
    }


    @NonCPS
    def <T> T getInstance(Class<T> type, String name = '') {
        DependencyKey keyDependency = DependencyGraph.resolveDependencyKey(type, name)
        def instance = instances.get(keyDependency) as T
        if (instance == null) {
            throw new Exception("Dependency not found for type: '${type.simpleName}' and Qualifier name: '${name}'. Check if the class exists or the qualifier name is correct. Current Instances Names: ${instances.keySet().collect { it.name }}.")
        }
        return instance
    }

    @NonCPS
    void register(Class<?> type, Class<?> dependencyClass) {
        def annotation = dependencyClass.getAnnotation(PipelineComponent)
        if (annotation == null) {
            throw new IllegalArgumentException("The class ${dependencyClass.name} is not annotated with @PipelineComponent. Please annotate the class with @PipelineComponent.")
        }
        def name = annotation?.name()
        def priority = annotation?.priority()
        DependencyKey dependencyKey = DependencyGraph.resolveDependencyKey(type, name, priority)
        registerWithKey(dependencyKey, dependencyClass)
    }

    @NonCPS
    void registerWithKey(DependencyKey dependencyKey, Class<?> componentClass) {
        if (!instances.containsKey(dependencyKey)) {
            ensureIsInstanceOf(dependencyKey.type, componentClass)
            graph.addNode(dependencyKey, componentClass)
        }
    }


    @NonCPS
    void initialize() {
        // Only process the nodes that are not already initialized
        List<Node> nodes = graph.resolveDependencies().findAll { this.instances[it.key] == null }

        nodes.each { node ->
            def instance = createNewInstanceByConstructor(node)
            if(instance == null) {
                throw new Exception("The class ${node.getClazz().name} does not have a public constructor. Please ensure that the class has a public constructor.")
            }
            if(this.instances.containsKey(node.key)) {
                throw new Exception("The class ${node.getClazz().name} is already registered. Please ensure that the class annotated with @PipelineComponent and the qualifier name is unique.")
            }
            this.instances[node.key] = instance
        }

        nodes.each { node ->
            injectDependenciesByFields(this.instances[node.key])
        }
    }

    @NonCPS
    void registerCoreComponent(Class<?> type, Object instance) {
        DependencyKey key = DependencyGraph.resolveDependencyKey(type, '')
        instances.put(key, instance)
        graph.addNode(key, instance.getClass())
    }

    @NonCPS
    protected Object createNewInstanceByConstructor(Node node) {
        def clazz = node.getClazz()
        def constructor = clazz.getConstructors()[0]
        def dependencies = node.getDependencies().collect { this.instances[it.key] }
        return constructor.newInstance(dependencies.toArray())
    }

    @NonCPS
    protected void injectDependenciesByFields(Object instance) {
        for (def instanceClass = instance.class; instanceClass != null; instanceClass = instanceClass.getSuperclass()) {
            for (Field field : instanceClass.declaredFields) {
                if (!isAnnotated(field)) {
                    continue
                }
                Qualifier qualifierAnnotation = field.getAnnotation(Qualifier)
                def fieldType = field.getType()
                Object dependency
                if (qualifierAnnotation) {
                    dependency = getInstance(fieldType, qualifierAnnotation.value())
                } else {
                    dependency = getInstance(fieldType)
                }

                ensureIsInstanceOf(fieldType, dependency.getClass())

                field.setAccessible(true)
                field.set(instance, dependency)
            }
        }
    }

    @NonCPS
    private void ensureIsInstanceOf(Class<?> type, Class<?> dependency) {
        if (!type.isAssignableFrom(dependency)) {
            throw new IllegalArgumentException("The registered class ${dependency.name} does not implement the dependency interface ${type.simpleName}. Please ensure that the registered class is an implementation of the dependency interface.")
        }
    }

    @NonCPS
    private static Boolean isAnnotated(Field field) {
        return !field.synthetic && field.getAnnotation(Inject)
    }

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/dependencies/IDependencyResolver.groovy">
package es.giss.framework.core.cdi.dependencies

interface IDependencyResolver {
    Map<DependencyKey, Object> getInstances()
    int getSizedInstances()
    def <T> T getInstance(Class<T> type)
    def <T> T getInstance(Class<T> type, String name)
    void register(Class<?> type, Class<?> dependencyClass)
    void initialize()
    void registerCoreComponent(Class<?> type, Object instance)
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/dependencies/Node.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS

class Node {

    private final DependencyKey key
    private final Class<?> clazz
    private final List<Node> dependencies

    Node(DependencyKey key, Class<?> clazz) {
        this.key = key
        this.clazz = clazz
        this.dependencies = []
    }

    @NonCPS
    void addDependency(Node node) {
        this.dependencies.add(node)
    }

    @NonCPS
    List<Node> getDependencies() {
        return dependencies
    }

    @NonCPS
    Class<?> getClazz() {
        return clazz
    }

    @NonCPS
    DependencyKey getKey() {
        return key
    }

    @NonCPS
    @Override
    boolean equals(Object obj) {
        if (obj == null) {
            return false
        }

        if (obj instanceof Node) {
            Node other = (Node) obj
            def collectKeyAndClass = { node -> [node.key, node.clazz] }
            return key.equals(other.key) &&
                    clazz.equals(other.clazz) &&
                    dependencies.size() == other.dependencies.size() &&
                    dependencies.collect(collectKeyAndClass) == other.dependencies.collect(collectKeyAndClass)
        }
        return false
    }

    @NonCPS
    @Override
    int hashCode() {
        return key.hashCode() + clazz.hashCode() + dependencies.collect { [it?.key, it?.clazz] }.hashCode()
    }

    @NonCPS
    @Override
    String toString() {
        return "Node key: $key, clazz: $clazz"
    }

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/fiters/AcceptEverythingResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

class AcceptEverythingResourceFilter<T> implements ResourceFilter<T> {
    @NonCPS
    @Override
    boolean acceptScannedResource(T item) {
        return true
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/fiters/AnnotatedClassResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

import java.lang.annotation.Annotation

class AnnotatedClassResourceFilter implements ResourceFilter<Class<?>> {

    protected Class<? extends Annotation> annotationClass;

    AnnotatedClassResourceFilter(Class<? extends Annotation> annotationClass) {
        this.annotationClass = annotationClass;
    }

    @NonCPS
    @Override
    public boolean acceptScannedResource(Class<?> item) {
        return item.isAnnotationPresent(annotationClass);
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/fiters/ChainedResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

class ChainedResourceFilter<T> implements ResourceFilter<T> {

    enum Mode {
        And, Or, Not
    }

    protected List<ResourceFilter<T>> filters
    protected Mode mode

    ChainedResourceFilter(Mode mode, ResourceFilter<T>... filters) {

        if (filters == null || filters.length == 0) {
            throw new IllegalArgumentException("no filters provided")
        }

        this.filters = Arrays.asList(filters)
        this.mode = mode
    }

    @NonCPS
    @Override
    boolean acceptScannedResource(T item) {

        for (ResourceFilter<T> filter : filters) {
            boolean accepted = filter.acceptScannedResource(item)

            if (accepted) {
                if (mode == Mode.Or) {
                    return true
                }

                if (mode == Mode.Not) {
                    return false
                }
            } else if (mode == Mode.And) {
                return false
            }
        }

        // And and Not are fail-fast, so if we reach the end, then our criteria is met.
        // Or would have already returned if it were successful.
        return mode == Mode.And || mode == Mode.Not
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/fiters/ExtendsClassResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

import java.lang.reflect.Modifier

class ExtendsClassResourceFilter implements ResourceFilter<Class<?>> {

    protected Class baseClass
    protected boolean concreteOnly

    ExtendsClassResourceFilter(Class baseClass, boolean concreteOnly) {
        this.baseClass = baseClass
        this.concreteOnly = concreteOnly
    }

    @NonCPS
    @Override
    boolean acceptScannedResource(Class item) {
        return baseClass.isAssignableFrom(item) && (!concreteOnly || !(item.isInterface() || Modifier.isAbstract(item.getModifiers())))
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/interfaces/ResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.interfaces

interface ResourceFilter<T> {

    /**
     * Convenience implementation that doesn't filter anything.
     * Provided as a class instead of a static final member to take advantage of generics.*/

    /**
     * Convenience implementation that filters everything.
     * Provided as a class instead of a static final member to take advantage of generics.*/
    boolean acceptScannedResource(T item);
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/interfaces/ResourceLoader.groovy">
package es.giss.framework.core.cdi.scanner.interfaces


import java.util.jar.JarEntry
import java.util.jar.JarFile

interface ResourceLoader<T> {

    T loadFromJarfile(String packageName, JarFile jarFile, JarEntry entry);

    T loadFromFilesystem(String packageName, File directory, String fileName);
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/interfaces/ResourceVisitor.groovy">
package es.giss.framework.core.cdi.scanner.interfaces

interface ResourceVisitor<T> {

    /**
     * called once for each resources that has been loaded and passed all filter criteria.
     * @param resource as loaded by a {@link ResourceLoader} implementation.
     */
    void visit(T resource);
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/ClassesInPackageScanner.groovy">
package es.giss.framework.core.cdi.scanner

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.fiters.AnnotatedClassResourceFilter
import es.giss.framework.core.cdi.scanner.fiters.ChainedResourceFilter
import es.giss.framework.core.cdi.scanner.fiters.ExtendsClassResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceLoader
import org.apache.commons.lang.StringUtils

import java.lang.annotation.Annotation
import java.util.jar.JarEntry
import java.util.jar.JarFile

class ClassesInPackageScanner extends PackageScanner<Class<?>> {

    ClassesInPackageScanner() {
        this(getDefaultClassLoader(), false)
    }

    ClassesInPackageScanner(ClassLoader classLoader, boolean includeInnerClasses) {
        super(new ClassResourceLoader(classLoader, includeInnerClasses))
    }

    @NonCPS
    Set<Class<?>> findAnnotatedClasses(String packageName, Class<? extends Annotation> annoClass) throws IOException {
        return scanWithExtraFilter(packageName, new AnnotatedClassResourceFilter(annoClass));
    }


    @NonCPS
    <T> Set<Class<? extends T>> findImplementers(String packageName, Class<T> baseClass) throws IOException {
        // javac fails to compile without the generic clue
        //noinspection RedundantTypeArguments
        return this.<T> scanWithExtraFilter(packageName, new ExtendsClassResourceFilter(baseClass, true))
    }


    @NonCPS
    protected <T> Set<Class<? extends T>> scanWithExtraFilter(String packageName, ResourceFilter<Class<?>> extraFilter) throws IOException {

        ResourceFilter<Class<?>> currentFilter = this.resourceFilter
        try {
            this.resourceFilter = new ChainedResourceFilter<Class<?>>(ChainedResourceFilter.Mode.And,
                    extraFilter,
                    currentFilter)

            Set classes = scan(packageName)

            //noinspection unchecked
            return (Set<Class<? extends T>>) classes
        } finally {
            this.resourceFilter = currentFilter
        }
    }

    static class ClassResourceLoader implements ResourceLoader<Class<?>> {


        protected ClassLoader classLoader
        protected boolean includeInnerClasses

        ClassResourceLoader(ClassLoader classLoader, boolean includeInnerClasses) {
            this.classLoader = classLoader
            this.includeInnerClasses = includeInnerClasses
        }


        @NonCPS
        @Override
        Class<?> loadFromJarfile(String packageName, JarFile jarFile, JarEntry entry) {
            return loadClassFromFile(packageName, StringUtils.substringAfterLast(entry.getName(), "/"))
        }

        @NonCPS
        @Override
        Class<?> loadFromFilesystem(String packageName, File directory, String fileName) {
            return loadClassFromFile(packageName, fileName)
        }

        @SuppressWarnings('grvy:org.codenarc.rule.logging.PrintlnRule')
        @NonCPS
        protected Class<?> loadClassFromFile(String packageName, String fileName) {
            if (((fileName.endsWith(".groovy") || fileName.endsWith(".class")) && (includeInnerClasses || fileName.indexOf("\$") < 0))) {
                try {
                    GroovyClassLoader cLoader = new GroovyClassLoader(classLoader)
                    return cLoader.loadClass(packageName + "." + StringUtils.substringBeforeLast(fileName, "."))
                } catch (Exception e) {
                    println("Error classNotFound $e.message")
                }
            }

            return null
        }
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/scanner/PackageScanner.groovy">
package es.giss.framework.core.cdi.scanner

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.fiters.AcceptEverythingResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceLoader
import es.giss.framework.core.cdi.scanner.interfaces.ResourceVisitor
import org.apache.commons.io.FileUtils
import org.apache.commons.lang.StringUtils

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.regex.Matcher
import java.util.regex.Pattern

class PackageScanner<T> {
    protected ClassLoader classLoader
    protected ResourceLoader<T> resourceLoader
    protected boolean recursive = true
    protected ResourceFilter<T> resourceFilter = new AcceptEverythingResourceFilter<T>()

    /**
     * Creates an instance with the {@link ResourceLoader} and a default {@link ClassLoader}.
     * @param resourceLoader
     */
    PackageScanner(ResourceLoader<T> resourceLoader) {
        this(getDefaultClassLoader(), resourceLoader)
    }

    /**
     * Advanced : use this constructor if you need to specify the {@link ClassLoader}.
     * @param classLoader
     * @param resourceLoader
     */
    PackageScanner(ClassLoader classLoader, ResourceLoader<T> resourceLoader) {
        this.classLoader = classLoader
        this.resourceLoader = resourceLoader
    }

    @NonCPS
    PackageScanner<T> setResourceFilter(ResourceFilter<T> resourceFilter) {
        this.resourceFilter = resourceFilter
        return this
    }

    /**
     * performs an exhaustive recursive scan under package <code>packageName</code>.
     * @param packageName
     * @return
     * @throws IOException
     */
    @NonCPS
    Set<T> scan(String packageName) throws IOException {
        final Set<T> result = new HashSet<T>()
        visit({
            result.add(it)
        } as ResourceVisitor, packageName)

        return result
    }

    @NonCPS
    void visit(ResourceVisitor<T> visitor, String packageName) throws IOException {

        // on windows, the Sun JVM uses uses '/' and not '\' (File.separatorChar) in the classpath
        // thanks to jeremy chone (http://www.bitsandbuzz.com/) for this insight.
        //
        // NOTE : for non-Sun JVMs, i have not idea what the behavior is.  but i'm not going to lose
        // any sleep over it. ;)
        packageName = packageName.replace('.', '/')
        Pattern packageDirMatcher = Pattern.compile("(" + Pattern.quote(packageName) + "(/.*)?)\$")

        Enumeration<URL> dirs = classLoader.getResources(packageName)

        while (dirs.hasMoreElements()) {
            String path = URLDecoder.decode(dirs.nextElement().getPath(), "UTF-8")

            if (path.contains(".jar!") || path.contains("zip!")) {
                String jarName = path.substring("file:".length())
                jarName = jarName.substring(0, jarName.indexOf('!'))

                JarFile jarFile = new JarFile(jarName)
                visitJarFile(jarFile, packageName, visitor)

            } else {
                File dir = new File(path)
                Matcher dirMatcher = packageDirMatcher.matcher(path)

                if (dirMatcher.find()) {
                    visitDirectory(dir, packageDirMatcher, visitor)
                }
            }
        }
    }

    @NonCPS
    protected void visitJarFile(JarFile jarFile, String packageNameForJarPath, ResourceVisitor<T> visitor) {

        Enumeration<JarEntry> entries = jarFile.entries()
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement()

            String entryPackage = StringUtils.substringBeforeLast(entry.getName(), "/")
            if (packageNameForJarPath.equals(entryPackage) || (recursive && entryPackage.startsWith(packageNameForJarPath))) {

                String packageName = entryPackage.replace('/', '.')
                if (!entry.isDirectory()) {

                    T resource = resourceLoader.loadFromJarfile(packageName, jarFile, entry)
                    if (resource != null && resourceFilter.acceptScannedResource(resource)) {
                        visitor.visit(resource)
                    }
                }
            }
        }
    }

    @NonCPS
    protected void visitDirectory(File dir, Pattern packageDirMatcher, ResourceVisitor<T> visitor) {

        for (Object obj : FileUtils.listFiles(dir, null, recursive)) {
            File file = (File) obj

            // because the JVM appears to use '/' on all platforms in the classpath entries, this pattern
            // always ends up with '/' and never File.separatorChar.  so, on windows, we'll need to modify
            // our search pattern.
            String absolutePath = file.getParentFile().getAbsolutePath()
            if (File.separatorChar != '/') {
                absolutePath = absolutePath.replace(File.separatorChar, '/' as char)
            }

            Matcher dirMatcher = packageDirMatcher.matcher(absolutePath)
            if (dirMatcher.find()) {
                String packageNameForDir = dirMatcher.group(1).replace('/', '.')


                T resource = resourceLoader.loadFromFilesystem(packageNameForDir, file.getParentFile(), file.getName())
                if (resource != null && resourceFilter.acceptScannedResource(resource)) {
                    visitor.visit(resource)
                }

            }
        }
    }

    @NonCPS
    static ClassLoader getDefaultClassLoader() {
        return PackageScanner.class.getClassLoader()
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/ConfigurationPriority.groovy">
package es.giss.framework.core.cdi

enum ConfigurationPriority {

    HIGHEST(1), HIGH(2), MEDIUM(5), LOW(10), LOWEST(15), EXCLUDED(20)

    final Integer value

    private ConfigurationPriority(Integer value) {
        this.value = value
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/ContextSinglenton.groovy">
package es.giss.framework.core.cdi


import es.giss.framework.core.PipelineContext

class ContextSinglenton {
    private static PipelineContext instance

    private ContextSinglenton() {
        // constructor privado
    }

    static synchronized PipelineContext getContext() {
        if (instance == null) {
            throw new IllegalStateException('Pipeline context not created')
        }
        return instance
    }

    static synchronized PipelineContext createPipelineContext(
            Script steps,
            List<String> scanPackageNames = ['es.giss.framework']) {
        if (instance == null) {
            instance = new PipelineContext(steps)
            instance.registerComponentsFromPackages(scanPackageNames)
            instance.registerConfigAdaptersFromPackages(scanPackageNames)
            instance.registerDataModelsFromPackages(scanPackageNames)
            instance.initializePipelineDefaultStore()
            instance.initializeProjectDescriptorStore()
            instance.initializeTelemetryStore()
            instance.initializeReleaseStore()
        }
        return instance
    }

    static def getComponent(Class<?> clazz) {
        return instance.getComponent(clazz)
    }
}
</file>

<file path="bin/main/es/giss/framework/core/cdi/IServiceLocator.groovy">
package es.giss.framework.core.cdi


interface IServiceLocator extends Serializable {

    void registerComponentsFromPackages()

    void registerComponentsFromPackages(List<String> packageNames)

    void registerConfigAdaptersFromPackages()

    void registerConfigAdaptersFromPackages(List<String> packageName)

    def <T> T getComponent(Class<T> type, String name)

    def <T> T getComponent(Class<T> type)

}
</file>

<file path="bin/main/es/giss/framework/core/cdi/ServicesFactory.groovy">
package es.giss.framework.core.cdi

class ServicesFactory {
    private static Map<String, Class<?>> classRegistry = [:]

    static void registerClass(String key, Class<?> clazz) {
        classRegistry[key] = clazz
    }

    static <T> T createInstanceFromMap(String key, Map params) {
        Class<?> clazz = classRegistry[key]
        if (!clazz) {
            throw new IllegalArgumentException("No class registered for key: $key")
        }

        return createInstanceFromMap(clazz, params)
    }

    static <T> T createInstanceFromMap(Class<T> clazz, Map params) {
        try {
            T instance = clazz.newInstance()
            params.each { k, v ->
                def field = clazz.getDeclaredField(k.toString())
                field.setAccessible(true)
                field.set(instance, v)
            }
            return instance
        } catch (Exception e) {
            throw new RuntimeException("Failed to create instance of ${clazz.name}", e)
        }
    }

    static Map<String, Class<?>> getClassRegistry() {
        return classRegistry
    }
}
</file>

<file path="bin/main/es/giss/framework/core/config/ConfigClient.groovy">
package es.giss.framework.core.config

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Stage
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IConfigClient
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.vo.observability.TelemetryMap
import es.giss.framework.core.vo.observability.events.ProcessedCofigAdaptersEvent

@PipelineComponent
class ConfigClient extends Stage implements IConfigClient {

    private List<IConfigAdapter> adapters = []

    @Override
    void addAdapter(IConfigAdapter adapter) {
        adapters.add(adapter)
    }

    @Override
    void loadData() {
        List<IConfigAdapter> sortedAdapters = sortAdapters(adapters)
        logger.printPrettyLog(LogLevel.DEBUG, "Adapters loaded", sortedAdapters.collect { " ${it.getClass().simpleName} (Prioridad: ${getPriority(it)}, Depende de: ${it.dependsOn() ?: 'Ninguno'})" })

        sortedAdapters.each { adapter ->
            processAdapter(adapter)
        }

        logger.debug("Adapters loaded: ${adapters.size()} adapters names: ${adapters.collect { it.getClass().simpleName }.toString()}")
        pipeline.dispatch(new TelemetryEvent(payload: new TelemetryMap(configAdapter: adapters.collect { it.getClass().simpleName })))
    }

    @NonCPS
    List<IConfigAdapter> sortAdapters(List<IConfigAdapter> adapters) {
        // Primero, ordenamos por prioridad descendente
        List<IConfigAdapter> sortedAdapters = adapters.sort { b, a -> getPriority(a) <=> getPriority(b) }

        // Luego, para cada grupo de adaptadores con la misma prioridad, aplicamos el ordenamiento por dependencias
        List<IConfigAdapter> result = []
        Map<Integer, List<IConfigAdapter>> adaptersByPriority = sortedAdapters.groupBy { getPriority(it) }

        adaptersByPriority.each { priority, adapterList ->
            result.addAll(sortAdaptersByDependencies(adapterList))
        }

        return result
    }

    @NonCPS
    List<IConfigAdapter> sortAdaptersByDependencies(List<IConfigAdapter> adapters) {
        Map<String, IConfigAdapter> adapterMap = adapters.collectEntries { [(it.getClass().simpleName): it] }
        List<IConfigAdapter> sorted = []
        Set<String> visited = new HashSet<>()

        adapters.each { adapter ->
            if (!visited.contains(adapter.getClass().simpleName)) {
                visitAdapter(adapter, adapterMap, sorted, visited)
            }
        }

        return sorted
    }

    @NonCPS
    void visitAdapter(IConfigAdapter adapter, Map<String, IConfigAdapter> adapterMap, List<IConfigAdapter> sorted, Set<String> visited) {
        String adapterName = adapter.getClass().simpleName
        visited.add(adapterName)

        String dependsOn = adapter.dependsOn()
        if (dependsOn && adapterMap.containsKey(dependsOn) && !visited.contains(dependsOn)) {
            visitAdapter(adapterMap[dependsOn], adapterMap, sorted, visited)
        }

        if (!sorted.contains(adapter)) {
            sorted.add(adapter)
        }
    }

    void processAdapter(IConfigAdapter adapter) {
        try {
            adapter.resolveConfiguration(pipeline)
            String adapterName = getAdapterName(adapter)
            if (adapterName) {
                pipeline.dispatch(
                        new TelemetryEvent(payload: new ProcessedCofigAdaptersEvent(name: adapterName))
                )
            }

            logger.debug("Configuration loaded from adapter ${adapter.getClass().name}")
        } catch (Exception e) {
            logger.warn("Error processing adapter ${adapter.getClass().name}. Error Message: ${e.message}")
            pipeline.dispatch(new TelemetryEvent(payload: new TelemetryMap(error: "Error processing adapter ${adapter.getClass().name}. Error Message: ${e.message}")))
        }
    }

    String getAdapterName(IConfigAdapter adapter) {
        PipelineComponent annotation = adapter.getClass().getAnnotation(PipelineComponent)
        annotation ? annotation.name() : ''
    }

    @Override
    void configureEntities(List<Map> config = []) {
        stage('Resolve Configurations') {
            loadData()
            if (pipeline.isDevelopmentMode() && config) {
                logger.info("ConfigClient", "Configuracin en Modo Desarrollo")
                pipeline.updateDataModelsFromMap(config)
            }

        }
        stage('Configure Components') {
            pipeline.configureServicesByPriority()
        }
    }

    @NonCPS
    int getPriority(Object a) {
        PipelineComponent pipelineComponent = a.class.getAnnotation(PipelineComponent)
        return pipelineComponent?.priority().value ?: 1000
    }
}
</file>

<file path="bin/main/es/giss/framework/core/events/interfaces/DataModel.groovy">
package es.giss.framework.core.events.interfaces

import es.giss.framework.core.interfaces.ModelCloneable

interface DataModel extends Serializable, ModelCloneable {

    Map<String, Object> toMap()

}
</file>

<file path="bin/main/es/giss/framework/core/events/interfaces/PipelineModel.groovy">
package es.giss.framework.core.events.interfaces

interface PipelineModel extends DataModel {}
</file>

<file path="bin/main/es/giss/framework/core/events/interfaces/ProjectDescriptorModel.groovy">
package es.giss.framework.core.events.interfaces

interface ProjectDescriptorModel extends DataModel {}
</file>

<file path="bin/main/es/giss/framework/core/events/interfaces/TelemetryModel.groovy">
package es.giss.framework.core.events.interfaces

interface TelemetryModel extends DataModel {

    String getId()

}
</file>

<file path="bin/main/es/giss/framework/core/events/CoreEvent.groovy">
package es.giss.framework.core.events

abstract class CoreEvent<T> implements Serializable {
    String description = ''
    long timeMillis = new Date().time
    T payload

}
</file>

<file path="bin/main/es/giss/framework/core/events/PipelineEvent.groovy">
package es.giss.framework.core.events

import es.giss.framework.core.events.interfaces.PipelineModel

class PipelineEvent extends CoreEvent<PipelineModel> {}
</file>

<file path="bin/main/es/giss/framework/core/events/ProjectEvent.groovy">
package es.giss.framework.core.events

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectEvent extends CoreEvent<ProjectDescriptorModel> {}
</file>

<file path="bin/main/es/giss/framework/core/events/TelemetryEvent.groovy">
package es.giss.framework.core.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class TelemetryEvent extends CoreEvent<TelemetryModel> {}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/AssignableArtifactsRepository.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.project.ArtifactsRepository

interface AssignableArtifactsRepository {

    ArtifactsRepository getArtifactsRepository()

    void setArtifactsRepository(ArtifactsRepository artifactsRepository)

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/AutomationToolDefinition.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.project.ProjectConfigurationFile

import java.nio.file.Path

interface AutomationToolDefinition <F extends ProjectConfigurationFile> {

    void setFileDefinitionPath(Path fileDefinitionPath)

    F readFileDefinition()

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/Configurable.groovy">
package es.giss.framework.core.interfaces



interface Configurable {

    void configure(IPipelineContext context)
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/Derivable.groovy">
package es.giss.framework.core.interfaces

interface Derivable {
    String getType()

    void setType(String type)
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IBuildAutomationTool.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.project.ProjectConfigurationFile
import es.giss.framework.core.vo.project.strategies.BuildStrategy
import es.giss.framework.core.vo.project.strategies.PublishStrategy
import es.giss.framework.core.vo.project.strategies.TestStrategy
import es.giss.framework.core.vo.release.Artifact

interface IBuildAutomationTool<A extends Artifact, F extends ProjectConfigurationFile> extends ITool,
        AutomationToolDefinition<F>, IToolVersionable {

    boolean test(TestStrategy testStrategy)

    A build(BuildStrategy buildStrategy)

    void publish(PublishStrategy publishStrategy, A artifact)

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IConfigAdapter.groovy">
package es.giss.framework.core.interfaces


interface IConfigAdapter  {

    String dependsOn()

    void resolveConfiguration(IPipelineContext context)

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IConfigClient.groovy">
package es.giss.framework.core.interfaces

interface IConfigClient {

    void addAdapter(IConfigAdapter adapter)

    void loadData()

    void configureEntities()

    void configureEntities(List<Map> config)
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/Identifiable.groovy">
package es.giss.framework.core.interfaces

interface Identifiable {

    String getId()

    void setId(String id)
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IDeployAutomationTool.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.release.Artifact
import es.giss.framework.core.vo.project.ProjectConfigurationFile
import es.giss.framework.core.vo.project.strategies.DeployStrategy
import es.giss.framework.core.vo.project.strategies.RollbackStrategy
import es.giss.framework.core.vo.project.strategies.UndeployStrategy

interface IDeployAutomationTool<A extends Artifact, F extends ProjectConfigurationFile>
        extends ITool, AutomationToolDefinition<F>, IToolVersionable {

    void deploy(DeployStrategy deployStrategy, A artifact)

    void undeploy(UndeployStrategy unDeployStrategy, A artifact)

    void rollback(RollbackStrategy rollBackStrategy, A artifact)

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IGitService.groovy">
package es.giss.framework.core.interfaces

interface IGitService {

    void cloneInAgent()

    void cloneInAgent(String url, String reference)

    void cloneInAgent(String url, String reference, String credentialsId)

    void cloneInAgent(String url, String reference, String credentialsId, String cloneDir)

    void cloneInAgent(String url, String reference, String credentialsId, String cloneDir, Boolean shallowClone)
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/ILogger.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.logger.LogLevel

interface ILogger extends Configurable {

    void setLogLevel(LogLevel level)

    void info(String message)

    void warn(String message)

    void debug(String message)

    void error(String message)

    void fatal(String message)

    void info(String tag, String message)

    void warn(String tag, String message)

    void debug(String tag, String message)

    void error(String tag, String message)

    void fatal(String tag, String message)

    void executeWhenDebug(Closure body)

    def <T> void printPrettyLog(LogLevel level, T obj)

    def <T> void printPrettyLog(LogLevel level, String title, T obj)

    void logPrettyMessages(LogLevel level, List<String> messages)

    void logPrettyError(List<String> msgs)

    void flushLogs()

    String getLogFromFile()

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/Initializable.groovy">
package es.giss.framework.core.interfaces

interface Initializable {
    void initialize()
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/INotificationSender.groovy">
package es.giss.framework.core.interfaces

interface INotificationSender {

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IPipelineContext.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.cdi.IServiceLocator
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.events.interfaces.DataModel
import es.giss.framework.core.events.interfaces.PipelineModel
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

interface IPipelineContext extends IServiceLocator {

    Set<String> getSkipStages()

    void addSkipStage(String stage)

    void injectEnvironmentVariables(Map<String, String> envVars)

    void configureServicesByPriority()

    void setAutoCancelled(Boolean autoCancel)

    boolean isAutoCancelled()

    void setDebugMode(boolean debugMode)

    boolean isDebugMode()

    Map groupInstancesByPriority()

    String resolveControllerName()

    String getEnvironment()

    String resolveControllerDomain()

    String getAppNamespace()

    Store<? extends StructuredResource> getStore(Class<? extends StructuredResource> modelClass)

    void addStore(Class<? extends StructuredResource> modelClass, Store<? extends StructuredResource> store)

    void dispatch(CoreEvent event)

    void initializePipelineDefaultStore(PipelineModel... models)

    void initializeProjectDescriptorStore(ProjectDescriptorModel... models)

    void initializeTelemetryStore(TelemetryModel... models)

    void initializeReleaseStore(ReleaseModel... models)

    Map modelDataToMap()

    void updateDataModels(DataModel ...dataModels)

    void updateDataModelsFromMap(data)

    String getCurrentPipelineUserName()

    String getCurrentPipelineUserId()

    boolean isDevelopmentMode()

    Set<Class<?>> getScannedPipelineComponents()

    void registerDataModelsFromPackages()

    void registerDataModelsFromPackages(List<String> packageNames)

    Map getBuildTriggerCause()

    Class<?> findClassBySimpleName(String simpleName)

    Class<?> findClassBySimpleName(String packageName, String simpleName)



}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IReleaseStages.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.vo.release.GitCommitContext

interface IReleaseStages extends Configurable {

    void releaseSnapshot()
    void releaseMaster()
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IResourceParser.groovy">
package es.giss.framework.core.interfaces


import java.nio.file.Path

interface IResourceParser<T extends StructuredResource> {

    T parse(Path resourcePath)

    T parse(String content)

    String getType()
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IStage.groovy">
package es.giss.framework.core.interfaces

interface IStage {
    def stage(String name, Closure body)
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/ISteps.groovy">
package es.giss.framework.core.interfaces


interface ISteps {

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/ITool.groovy">
package es.giss.framework.core.interfaces

interface ITool extends Configurable {

    Integer executeWithStatus(String command, options)

    String execute(String command, options)


}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IToolsStrategy.groovy">
package es.giss.framework.core.interfaces


interface IToolsStrategy extends ITool {

    void setToolVersion(String tool, String version)

    boolean filterTool(String tool)

    int priority()

}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/IToolVersionable.groovy">
package es.giss.framework.core.interfaces

interface IToolVersionable {

    void useToolVersion(String version)

    String getToolVersion()
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/ModelCloneable.groovy">
package es.giss.framework.core.interfaces

interface ModelCloneable {
    Object clone()
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/StructuredResource.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.events.interfaces.DataModel
import es.giss.framework.core.vo.project.StructuredResourceMetadata

interface StructuredResource extends DataModel {

    String apiVersion()

    String getKind()

    StructuredResourceMetadata getMetadata()

    def getSpec()

    def status()
}
</file>

<file path="bin/main/es/giss/framework/core/interfaces/Versionable.groovy">
package es.giss.framework.core.interfaces

interface Versionable {

    String getCurrentVersion()

    void useVersion(String version)

}
</file>

<file path="bin/main/es/giss/framework/core/logger/AnsiColor.groovy">
package es.giss.framework.core.logger

import com.cloudbees.groovy.cps.NonCPS

enum AnsiColor implements Serializable {
    RESET('\u001B[0m'),
    BOLD('\u001B[1m'),
    ITALIC('\u001B[3m'),
    EMPTY_STYLE(''),
    RED('\u001B[38;5;1m'),
    GREEN('\u001B[32m'),
    DARK_GREEN('\u001B[38;5;28m'),
    YELLOW('\u001B[38;5;208m'),
    MAGENTA('\u001B[35m'),
    DARK_MAGENTA('\u001B[38;5;5m'),
    BLUE('\u001B[34m'),
    DARK_BLUE('\u001B[38;5;25m'),
    CYAN('\u001B[36m'),
    DARK_CYAN('\u001B[38;5;39m'),





    final String colorCode

    AnsiColor(String colorCode) {
        this.colorCode = colorCode
    }

    @NonCPS
    @Override
    String toString() {
        return this.colorCode
    }
}
</file>

<file path="bin/main/es/giss/framework/core/logger/Logger.groovy">
package es.giss.framework.core.logger

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.storage.Store
import es.giss.framework.core.vo.pipeline.PipelineDefinition

@PipelineComponent
class Logger implements ILogger {

    private LogLevel level = LogLevel.INFO
    protected Script steps
    private List<String> logBuffer = []

    Logger(Script steps) {
        this.steps = steps
    }

    void logMessage(LogLevel level, String tag, String message) {
        if (isLoggable(level)) {
            String header = "${level.getColor().colorCode}${level.getStyle().colorCode}[${level}] "
            String tagFormatted = tag ? "[${tag}] " : ''
            String body = message
            String footer = AnsiColor.RESET.colorCode

            steps.ansiColor('xterm') {
                String msg = "${header}${tagFormatted}${body}${footer}"
                this.steps.echo msg
                this.logBuffer.add(msg)
            }
        }
    }

    protected Boolean isLoggable(LogLevel level) {
        return level.levelNumber <= this.level.levelNumber
    }

    @Override
    void setLogLevel(LogLevel level) {
        this.level = level
        info("Logger configured with log level: ${this.level}")
    }

    @Override
    void info(String message) {
        info('', message)
    }

    @Override
    void warn(String message) {
        warn('', message)
    }

    @Override
    void debug(String message) {
        debug('', message)
    }

    @Override
    void error(String message) {
        error('', message)
    }

    @Override
    void error(String tag, String message) {
        logMessage(LogLevel.ERROR, tag, message)
    }

    @Override
    void fatal(String tag, String message) {
        logMessage(LogLevel.FATAL, tag, message)
    }

    @Override
    void fatal(String message) {
        fatal('', message)
    }

    @Override
    void info(String tag, String message) {
        logMessage(LogLevel.INFO, tag, message)
    }

    @Override
    void warn(String tag, String message) {
        logMessage(LogLevel.WARN, tag, message)
    }

    @Override
    void debug(String tag, String message) {
        logMessage(LogLevel.DEBUG, tag, message)
    }

    @Override
    void executeWhenDebug(Closure body) {
        if (level == LogLevel.DEBUG) {
            info("Executing debug closure")
            body()
        }
    }

    @Override
    <T> void printPrettyLog(LogLevel level, T obj) {
        if (isLoggable(level)) {
            logMessage(level, '', extendPrettyPrint(obj, 0, new StringBuilder()).toString())
        }
    }

    @Override
    <T> void printPrettyLog(LogLevel level, String title, T obj) {
        if (isLoggable(level)) {
            StringBuilder sb = new StringBuilder()
            sb.append(title).append('\n')
            sb.append('='.multiply(title.length() + 8)).append('\n')
            logMessage(level, '', extendPrettyPrint(obj, 0, sb).toString())
        }
    }

    protected <T> StringBuilder extendPrettyPrint(T obj, Integer level = 0, StringBuilder sb) {
        def indent = { lev -> sb.append('  ' * lev) }
        if (obj instanceof Map) {
            sb.append('{\n')
            obj.each { name, value ->
                // if(name.contains('.'))  return // skip keys like "a.b.c", which are redundant
                indent(level + 1).append(name)
                (value instanceof Map) ? sb.append(' ') : sb.append(' = ')
                extendPrettyPrint(value, level + 1, sb)
                sb.append('\n')
            }
            indent(level).append('}')
        } else if (obj instanceof List) {
            sb.append('[\n')
            obj.eachWithIndex { value, index ->
                indent(level + 1)
                def isLatestElement = (index == obj.size() - 1)
                isLatestElement ? extendPrettyPrint(value, level + 1, sb) : extendPrettyPrint(value, level + 1, sb).append(',')
                sb.append('\n')
            }
            indent(level).append(']')
        } else if (obj instanceof String) {
            sb.append('"').append(obj).append('"')
        } else {
            sb.append(obj)
        }
        return sb
    }

    @Override
    void logPrettyMessages(LogLevel level, List<String> messages) {
        logMessage(level, createPrettyMessage(messages))
    }

    @Override
    void logPrettyError(List<String> msgs) {
        error(createPrettyMessage(msgs))
    }

    @NonCPS
    static String createPrettyMessage(List<String> msgs) {
        return [
                '===========================================',
                flattenMessage(null, msgs.findAll { !it?.isEmpty() }).join('\n'),
                '===========================================',
        ].join('\n')
    }

    @NonCPS
    protected static List<String> flattenMessage(def list, def msgs) {
        list = list ?: []
        if (!(msgs instanceof String) && !(msgs instanceof GString)) {
            msgs.each { msg ->
                list = flattenMessage(list, msg)
            }
        } else {
            list += msgs
        }
        return list
    }

    @Override
    void configure(IPipelineContext context) {
        Store pipelineStore = context.getStore(PipelineDefinition.class)
        Boolean isDebugMode = pipelineStore.select { PipelineDefinition it -> it.spec.settings.debugMode }
        if (isDebugMode) {
            setLogLevel(LogLevel.DEBUG)
        }
    }

    @Override
    void flushLogs() {
        String buildName = getBuildName()
        String logFile = "${steps.env.WORKSPACE}@tmp/${buildName}.log"

        // Escribir el buffer al archivo usando printf para mejor manejo de caracteres especiales
        String logsToWrite = logBuffer.collect { it.replace("'", "'\\''") }.join('\\n')
        Integer result = steps.sh(script: """
                    #!/bin/bash 
                    set -e
                    set +x               
                    printf '%b' '${logsToWrite}\\n' >> ${logFile}
                """, returnStatus: true)
        if (result != 0) {
            warn('Logger', "Error writing logs to file: ${logFile}")
        }

        logBuffer.clear()
    }

    @Override
    String getLogFromFile() {
        String buildName = getBuildName()
        String logFile = "${steps.env.WORKSPACE}@tmp/${buildName}.log"
        try {
            String result = steps.sh(script: """
                                        #!/bin/bash 
                                        set -e
                                        set +x
                                        cat ${logFile} || { touch ${logFile}; echo "Log Content file not found: ${logFile}"; exit 1; }
                                    """, returnStdout: true)
            if (!result) {
                warn('Logger', "Log Content file not found: ${logFile}")
            }
            return result ?: 'Log Content file not found'
        } catch (Exception e) {
            warn('Logger', "Log Content file not found: ${logFile}")
            return 'Log Content file not found'
        }

    }

    String getBuildName() {
        return steps.env.BUILD_ID ?: 'currentBuild'
    }
}
</file>

<file path="bin/main/es/giss/framework/core/logger/LogLevel.groovy">
package es.giss.framework.core.logger

import com.cloudbees.groovy.cps.NonCPS


enum LogLevel implements Serializable {
    FATAL(100, AnsiColor.RED, AnsiColor.BOLD),
    ERROR(200, AnsiColor.RED, AnsiColor.BOLD),
    WARN(300, AnsiColor.YELLOW, AnsiColor.ITALIC),
    INFO(400, AnsiColor.DARK_BLUE, AnsiColor.EMPTY_STYLE),
    DEBUG(500, AnsiColor.DARK_GREEN, AnsiColor.ITALIC),
    SYSTEM(600, AnsiColor.DARK_CYAN, AnsiColor.ITALIC),
    SYSTEM_ERROR(600, AnsiColor.MAGENTA, AnsiColor.BOLD)

    final int levelNumber
    final AnsiColor color
    final AnsiColor style

    LogLevel(int levelNumber, AnsiColor color, AnsiColor style) {
        this.levelNumber = levelNumber
        this.color = color
        this.style = style
    }

    @NonCPS
    @Override
    String toString() {
        return this.name()
    }
}
</file>

<file path="bin/main/es/giss/framework/core/storage/interfaces/Effect.groovy">
package es.giss.framework.core.storage.interfaces

import es.giss.framework.core.events.CoreEvent

interface Effect {
    void handleEvent(CoreEvent event)
}
</file>

<file path="bin/main/es/giss/framework/core/storage/interfaces/Mutation.groovy">
package es.giss.framework.core.storage.interfaces

import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.interfaces.StructuredResource

interface Mutation<State extends StructuredResource> {

    State apply(State state, CoreEvent event)

    def <T> T updateField(T current, T updated)
}
</file>

<file path="bin/main/es/giss/framework/core/storage/interfaces/OverrideHandler.groovy">
package es.giss.framework.core.storage.interfaces

interface OverrideHandler<T> {
    boolean shouldHandle(def currentValue, def overrideValue)
    T handle(T currentValue, T overrideValue)
}
</file>

<file path="bin/main/es/giss/framework/core/storage/interfaces/Selector.groovy">
package es.giss.framework.core.storage.interfaces


import es.giss.framework.core.interfaces.StructuredResource

interface Selector<State extends StructuredResource, T> {
    T select(State state)
}
</file>

<file path="bin/main/es/giss/framework/core/storage/interfaces/StateObserver.groovy">
package es.giss.framework.core.storage.interfaces

interface StateObserver<State> {
    void onStateChanged(State newState)
}
</file>

<file path="bin/main/es/giss/framework/core/storage/mutations/ObservabilityHubMutation.groovy">
package es.giss.framework.core.storage.mutations

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.storage.interfaces.Mutation
import es.giss.framework.core.storage.ObjectMerger
import es.giss.framework.core.vo.observability.ObservabilityHub
import es.giss.framework.core.vo.observability.ObservabilitySpec
import es.giss.framework.core.vo.observability.TelemetryMap
import es.giss.framework.core.vo.observability.events.*

class ObservabilityHubMutation implements Mutation<ObservabilityHub> {

    @NonCPS
    @Override
    ObservabilityHub apply(ObservabilityHub state, CoreEvent event) {
        try {
            def payload = event.payload
            switch (payload.getClass()) {
                case TelemetryMap:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    telemetry: [payload] as List<TelemetryMap>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ProcessedCofigAdaptersEvent:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    processedConfigAdapters: [payload] as List<ProcessedCofigAdaptersEvent>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case StageCompletedEvent:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    stageCompletions: [payload] as List<StageCompletedEvent>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case StageErrorEvent:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    stageErrors: [payload] as List<StageErrorEvent>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case StageSkippedEvent:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    stageSkips: [payload] as List<StageSkippedEvent>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case StageStarted:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    stageStarts: [payload] as List<StageStarted>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case StageUnstableEvent:
                    ObservabilityHub newState = new ObservabilityHub(
                            spec: new ObservabilitySpec(
                                    stageUnstable: [payload] as List<StageUnstableEvent>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                default:
                    return state
            }
        } catch (Exception e) {
            ObservabilityHub newState = new ObservabilityHub(
                    status:[ errors: [e.message] as List<String>]
            )
            return ObjectMerger.mergeObjects(state, newState)
        }
    }

    @NonCPS
    @Override
    def <T> T updateField(T current, T updated) {
        return updated && updated != current ? updated : current
    }
}
</file>

<file path="bin/main/es/giss/framework/core/storage/mutations/PipelineDefinitionMutation.groovy">
package es.giss.framework.core.storage.mutations

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.storage.interfaces.Mutation
import es.giss.framework.core.storage.ObjectMerger
import es.giss.framework.core.vo.pipeline.*

//@CompileStatic
class PipelineDefinitionMutation implements Mutation<PipelineDefinition> {


    @NonCPS
    @Override
    PipelineDefinition apply(PipelineDefinition state, CoreEvent event) {
        try {
            def payload = event.payload
            switch (payload.getClass()) {
                case PipelineDefinition:
                    return ObjectMerger.mergeObjects(state, payload as PipelineDefinition)

                case PipelineSettings:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: new PipelineSpec(
                                    settings: payload as PipelineSettings
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case CacheDescriptor:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: new PipelineSpec(
                                    cache: payload as CacheDescriptor
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case AlternativesToolsDescriptor:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: new PipelineSpec(
                                    toolsManager: new ToolsManagerDescriptor(
                                            alternatives: payload as AlternativesToolsDescriptor
                                    )
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case GraalVmToolsDescriptor:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: new PipelineSpec(
                                    toolsManager: new ToolsManagerDescriptor(
                                            graalVmTools: payload as GraalVmToolsDescriptor
                                    )
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case AsdfToolsManagerDescriptor:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: new PipelineSpec(
                                    toolsManager: new ToolsManagerDescriptor(
                                            asdf: payload as AsdfToolsManagerDescriptor
                                    )
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case CustomScriptManagerDescriptor:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: new PipelineSpec(
                                    toolsManager: new ToolsManagerDescriptor(
                                            customScript: payload as CustomScriptManagerDescriptor
                                    )
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case PipelineSpec:
                    PipelineDefinition newState = new PipelineDefinition(
                            spec: payload as PipelineSpec
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case JobStatus:
                    PipelineDefinition newState = new PipelineDefinition(
                            status: new PipelineStatus(
                                    jobStatus: payload as JobStatus
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                default:
                    return state
            }
        } catch (Exception e) {
            PipelineDefinition newState = new PipelineDefinition(
                    status: new PipelineStatus(
                            errors: [e.message] as List<String>
                    )
            )
            return ObjectMerger.mergeObjects(state, newState)

        }
        return state
    }

    @NonCPS
    @Override
    def <T> T updateField(T current, T updated) {
        return updated && updated != current ? updated : current
    }

}
</file>

<file path="bin/main/es/giss/framework/core/storage/mutations/ProjectDescriptorMutation.groovy">
package es.giss.framework.core.storage.mutations

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.storage.interfaces.Mutation
import es.giss.framework.core.storage.ObjectMerger
import es.giss.framework.core.vo.project.*
import es.giss.framework.core.vo.project.strategies.*

//@CompileStatic
class ProjectDescriptorMutation implements Mutation<ProjectDescriptor> {


    @NonCPS
    @Override
    ProjectDescriptor apply(ProjectDescriptor state, CoreEvent event) {
        try {
            def payload = event.payload
            switch (payload.getClass()) {
                case ProjectSettings:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    settings: payload as ProjectSettings
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case SourceRepository:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    sourceRepositories: [payload as SourceRepository] as List<SourceRepository>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case Notification:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    notifications: payload as Notification
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ProjectTool:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    tools: [payload as ProjectTool] as List<ProjectTool>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ArtifactsRepository:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    artifactsRepositories: [payload as ArtifactsRepository] as List<ArtifactsRepository>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case DeployTarget:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    deployTargets: [payload as DeployTarget] as List<DeployTarget>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ScannerToolModel:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    scannerTools: [payload as ScannerToolModel] as List<ScannerToolModel>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)


                case BuildStrategy:
                case DeployStrategy:
                case PublishStrategy:
                case RollbackStrategy:
                case UndeployStrategy:
                case TestStrategy:
                    ProjectActionStrategy strategy = payload as ProjectActionStrategy
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    tools: [new ProjectTool(
                                            id: strategy.toolId,
                                            strategies: [payload as ProjectActionStrategy] as List<ProjectActionStrategy>
                                    )] as List<ProjectTool>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ProjectConfigurationFile:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            status: new ProjectStatus(
                                    projectConfigurationFiles: [payload as ProjectConfigurationFile] as List<ProjectConfigurationFile>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ScannerToolResult:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            status: new ProjectStatus(
                                    scannerToolResult: [payload as ScannerToolResult] as List<ScannerToolResult>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case VendorService:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: new ProjectSpec(
                                    vendorServices: [payload as VendorService] as List<VendorService>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ProjectSpec:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            spec: payload as ProjectSpec
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ProjectDescriptor:
                    return ObjectMerger.mergeObjects(state, payload as ProjectDescriptor)

                case ProjectStatus:
                    ProjectDescriptor newState = new ProjectDescriptor(
                            status: payload as ProjectStatus
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                default:
                    throw new IllegalArgumentException("Event payload type not supported: ${payload.getClass()}")
                    break
            }
        } catch (Exception e) {
            ProjectDescriptor newState = new ProjectDescriptor(
                    status: new ProjectStatus(
                            errors: [e.message] as List<String>
                    )
            )
            return ObjectMerger.mergeObjects(state, newState)

        }
        return state

    }


    @NonCPS
    @Override
    def <T> T updateField(T current, T updated) {
        return updated && updated != current ? updated : current
    }


}
</file>

<file path="bin/main/es/giss/framework/core/storage/mutations/ReleaseDescriptorMutation.groovy">
package es.giss.framework.core.storage.mutations

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.storage.interfaces.Mutation
import es.giss.framework.core.storage.ObjectMerger
import es.giss.framework.core.vo.release.*

class ReleaseDescriptorMutation implements Mutation<ReleaseDescriptor> {

    @NonCPS
    @Override
    ReleaseDescriptor apply(ReleaseDescriptor state, CoreEvent event) {
        try {
            def payload = event.payload
            switch (payload.getClass()) {
                case ReleaseDescriptor:
                    return ObjectMerger.mergeObjects(state, payload as ReleaseDescriptor)

                case ReleaseSpec:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: payload as ReleaseSpec
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case SemanticVersion:
                    SemanticVersion version = payload as SemanticVersion
                    if(version.major == 0 && version.minor == 0 && version.patch == 0) {
                        return state
                    }
                    return new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    version: payload as SemanticVersion
                            )
                    )

                case Changelog:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    changeLog: payload as Changelog
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case GitflowPhase:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    currentFlowPhase: payload as GitflowPhase
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ReleasePromotion:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    releasePromotion: payload as ReleasePromotion
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ReleaseConfig:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    releaseConfigs: [payload as ReleaseConfig] as List<ReleaseConfig>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ReleaseStatus:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            status: payload as ReleaseStatus
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case ApprovalRule:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    approvalRules: [payload as ApprovalRule] as List<ApprovalRule>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case Artifact:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    releaseArtifacts: [payload as Artifact] as List<Artifact>
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                case MergeRequest:
                    ReleaseDescriptor newState = new ReleaseDescriptor(
                            spec: new ReleaseSpec(
                                    mergeRequest : payload as MergeRequest
                            )
                    )
                    return ObjectMerger.mergeObjects(state, newState)

                default:
                    throw new IllegalArgumentException("Event payload type not supported: ${payload.getClass()}")
                    break
            }
        } catch (Exception e) {
            ReleaseDescriptor newState = new ReleaseDescriptor(
                    status: new ReleaseStatus(
                            errors: [e.message]
                    )
            )
            return ObjectMerger.mergeObjects(state, newState)

        }
        return state

    }

    @NonCPS
    @Override
    def <T> T updateField(T current, T updated) {
        return updated && updated != current ? updated : current
    }

}
</file>

<file path="bin/main/es/giss/framework/core/storage/overrides/SemanticVersionOverrideHandler.groovy">
package es.giss.framework.core.storage.overrides

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.storage.interfaces.OverrideHandler
import es.giss.framework.core.vo.release.SemanticVersion

class SemanticVersionOverrideHandler implements OverrideHandler<SemanticVersion> {

    @NonCPS
    @Override
    boolean shouldHandle(currentValue, overrideValue) {
        return currentValue instanceof SemanticVersion && overrideValue instanceof SemanticVersion
    }

    @NonCPS
    @Override
    SemanticVersion handle(SemanticVersion currentValue, SemanticVersion overrideValue) {
        if (overrideValue.major == 0 && overrideValue.minor == 0 && overrideValue.patch == 0) {
            return currentValue
        }
        return overrideValue
    }
}
</file>

<file path="bin/main/es/giss/framework/core/storage/ObjectCreator.groovy">
package es.giss.framework.core.storage

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ContextSinglenton
import es.giss.framework.core.interfaces.Derivable
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.*

import java.lang.reflect.Constructor
import java.lang.reflect.Field
import java.lang.reflect.Modifier
import java.lang.reflect.ParameterizedType

class ObjectCreator {
    private static Map<String, Class<?>> registeredClasses = [
            'BuildStrategy'   : BuildStrategy.class,
            'TestStrategy'    : TestStrategy.class,
            'PublishStrategy' : PublishStrategy.class,
            'DeployStrategy'  : DeployStrategy.class,
            'RollbackStrategy': RollbackStrategy.class,
            'UndeployStrategy': UndeployStrategy.class
    ]

    ILogger log

    ILogger getLogger() {
        if (log == null) {
            log = ContextSinglenton.getComponent(ILogger.class)
        }
        return log
    }

    static void registerClass(String key, Class clazz) {
        registeredClasses[key] = clazz
    }

    @NonCPS
    static def createInstance(Class clazz, Map structure) {
        def instance

        if (Derivable.isAssignableFrom(clazz)) {
            def typeValue = structure.get("type")
            if (typeValue) {
                def concreteClass = registeredClasses[typeValue]?: findClassBySimpleName(typeValue)
                if (concreteClass) {
                    instance = instantiateClass(concreteClass)
                } else {
                    throw new RuntimeException("No registered class found for type: $typeValue")
                }
            } else {
                throw new RuntimeException("Type field is required for Derivable classes")
            }
        } else {
            instance = instantiateClass(clazz)
        }

        if (instance instanceof Map) {
            // Si es un mapa, simplemente procesamos y aadimos las entradas
            structure.each { key, value ->
                if (!isNullOrEmpty(value)) {
                    instance[key] = processValue(value)
                }
            }
        } else {
            // Si es un objeto definido, intentamos establecer los campos
            def strategiesList = []

            structure.each { key, value ->
                if (!isNullOrEmpty(value)) {
                    if (instance instanceof ProjectTool && key.endsWith("Strategies")) {
                        // Si es ProjectTool y la clave termina en "Strategies", creamos una estrategia
                        if (value instanceof Collection) {
                            def strategyType = key.replace("Strategies", "Strategy").capitalize()
                            def toolId = structure.get("id")
                            if (strategyType) {
                                def strategyClass = registeredClasses[strategyType]?: findClassBySimpleName(strategyType)
                                if (strategyClass) {
                                    value.each { strategyValue ->
                                        strategyValue.type = strategyValue.type ?: strategyType
                                        strategyValue.toolId = strategyValue.toolId ?: toolId
                                        def strategy = createInstance(strategyClass, strategyValue)
                                        strategiesList.add(strategy)
                                    }
                                } else {
                                    throw new RuntimeException("No registered class found for strategy type: $strategyType")
                                }
                            } else {
                                throw new RuntimeException("Type field is required for strategy: $key")
                            }
                        } else {
                            throw new RuntimeException("Strategy value must be a Map: $key")
                        }
                    } else {
                        try {
                            def field = getFieldFromHierarchy(instance.getClass(), key)
                            field.setAccessible(true)
                            field.set(instance, processValue(value, field.getType(), field.getGenericType()))
                        } catch (NoSuchFieldException e) {
                            // Si el campo no existe, asumimos que es parte de un mapa y lo ignoramos
                           println("Warning: Field '$key' not found in class ${instance.getClass().name}. Ignoring.")
                        } catch (IllegalArgumentException e) {
                            throw new Exception("Error setting field '$key' in class ${instance.getClass().name}: ${e.message}")
                        }
                    }
                }
            }

            // Si es ProjectTool y tenemos strategies, las establecemos
            if (instance instanceof ProjectTool && !strategiesList.isEmpty()) {
                def strategiesField = ProjectTool.getDeclaredField("strategies")
                strategiesField.setAccessible(true)
                strategiesField.set(instance, strategiesList)
            }
        }

        return instance
    }

    @NonCPS
    static Field getFieldFromHierarchy(Class<?> clazz, String fieldName) throws NoSuchFieldException {
        try {
            return clazz.getDeclaredField(fieldName);
        } catch (NoSuchFieldException e) {
            Class<?> superClass = clazz.getSuperclass();
            if (superClass == null) {
                throw e;
            }
            return getFieldFromHierarchy(superClass, fieldName);
        }
    }


    @NonCPS
    static Class<?> findClassBySimpleName(String simpleName) {
        def result =  ContextSinglenton.context.findClassBySimpleName(simpleName)
        if(result) {
            registerClass(simpleName, result)
        }
        return result
    }

    @NonCPS
    private static def processValue(def value, Class fieldType = null, def genericType = null) {
        if (value instanceof Map) {
            if (fieldType && Derivable.isAssignableFrom(fieldType)) {
                def concreteClass = registeredClasses[value.type]?: findClassBySimpleName(value.type)
                if (!concreteClass) {
                    throw new RuntimeException("No registered class found for type: ${value}")
                }
                return createInstance(concreteClass, value)
            } else {
                return createInstance(fieldType ?: Map, value)
            }
        } else if (value instanceof List) {
            def collection = createAppropriateCollection(fieldType ?: List)
            if (genericType instanceof ParameterizedType) {
                def elementType = genericType.getActualTypeArguments()[0]
                value.each { item ->
                    if (!isNullOrEmpty(item)) {
                        collection.add(processValue(item, Class.forName(elementType.typeName)))
                    }
                }
            } else {
                collection?.addAll(value.findAll { !isNullOrEmpty(it) })
            }
            return collection
        } else if (Derivable.isAssignableFrom(value.getClass())) {
            return createInstance(value.getClass(), value)

        } else if (fieldType && fieldType.isEnum() && value instanceof String) {
            // Convertir String a Enum
            return Enum.valueOf(fieldType, value)
        } else {
            return value
        }
    }


    @NonCPS
    private static def createAppropriateCollection(Class fieldType) {
        if (Set.isAssignableFrom(fieldType)) {
            return new HashSet()
        } else if (List.isAssignableFrom(fieldType)) {
            return new ArrayList()
        } else if (Map.isAssignableFrom(fieldType)) {
            return new HashMap()
        }
    }

    @NonCPS
    private static def instantiateClass(Class clazz) {
        if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {
            return createAppropriateCollection(clazz)
        }

        try {
            return clazz.newInstance()
        } catch (InstantiationException | IllegalAccessException e) {
            Constructor<?>[] constructors = clazz.getDeclaredConstructors()
            for (Constructor<?> constructor : constructors) {
                if (constructor.getParameterCount() == 0) {
                    constructor.setAccessible(true)
                    return constructor.newInstance()
                }
            }
            throw new RuntimeException("No suitable constructor found for ${clazz.getName()}")
        }
    }

    @NonCPS
    private static boolean isNullOrEmpty(def value) {
        return value == null ||
                (value instanceof String && value.trim().isEmpty()) ||
                (value instanceof Collection && value.isEmpty()) ||
                (value instanceof Map && value.isEmpty())
    }
}
</file>

<file path="bin/main/es/giss/framework/core/storage/ObjectMerger.groovy">
package es.giss.framework.core.storage

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ContextSinglenton
import es.giss.framework.core.interfaces.Derivable
import es.giss.framework.core.interfaces.Identifiable
import es.giss.framework.core.interfaces.ModelCloneable
import es.giss.framework.core.storage.interfaces.OverrideHandler
import es.giss.framework.core.storage.overrides.SemanticVersionOverrideHandler
import es.giss.framework.core.vo.project.Metadata
import es.giss.framework.core.vo.project.strategies.*
import es.giss.framework.core.vo.release.ReleaseConfig
import org.codehaus.groovy.runtime.NullObject

import java.lang.reflect.Constructor
import java.lang.reflect.Field
import java.lang.reflect.Modifier

class ObjectMerger {
    static List<OverrideHandler> handlers = [
            new SemanticVersionOverrideHandler()
    ]

    private static Map<String, Class<?>> registeredClasses = [
            'BuildStrategy'   : BuildStrategy.class,
            'TestStrategy'    : TestStrategy.class,
            'PublishStrategy' : PublishStrategy.class,
            'DeployStrategy'  : DeployStrategy.class,
            'RollbackStrategy': RollbackStrategy.class,
            'UndeployStrategy': UndeployStrategy.class
    ]

    @NonCPS
    static void registerClass(String type, Class<?> clazz) {
        registeredClasses[type] = clazz
    }

    @NonCPS
    static <T> T updateField(T current, T updated) {
        if (updated == null || !updated) {
            return current
        }

        if (updated.getClass().isEnum()) {
            // No aplicar override si el enum es INVALID o UNKNOWN
            if (updated.name() in ['INVALID', 'UNKNOWN']) {
                return current
            }
        }
        return updated != current ? updated : current
    }

    @NonCPS
    static <T> T mergeObjects(T currentState, T overrideState) {
        try {

            if (!overrideState) {
                return cloneObject(currentState)
            }

            Class<?> clazz = currentState.getClass().isAssignableFrom(NullObject) ? overrideState.getClass() : currentState.getClass()
            if (clazz != overrideState.getClass() && !clazz.isAssignableFrom(NullObject)) {
                throw new IllegalArgumentException("Objects must be of the same type")
            }

            if (isSimpleType(clazz) || clazz.isEnum()) {
                return updateField(currentState, overrideState)
            }


            T result = createInstance(clazz)

            if (Map.isAssignableFrom(clazz) || result instanceof Map || result instanceof Metadata) {
                return mergeMaps(currentState as Map, overrideState as Map) as T
            }

            if (Collection.isAssignableFrom(clazz)) {
                return mergeCollections(currentState as Collection, overrideState as Collection) as T
            }

            for (Field field : getAllFields(clazz)) {
                if (shouldSkipField(field)) {
                    continue
                }

                field.setAccessible(true)
                def currentValue = currentState ? field.get(currentState) : null
                def overrideValue = overrideState ? field.get(overrideState) : null

                def mergedValue = mergeValues(currentValue, overrideValue)
                if (!mergedValue) {
                    continue
                }
                field.set(result, mergedValue)
                if (field.name == 'type' && Derivable.isAssignableFrom(clazz) && !registeredClasses.containsKey(mergedValue)) {
                    registerClass(mergedValue, clazz)
                }

            }

            return result
        } catch (Exception e) {
            throw new RuntimeException("Error merging objects: ${e.message} CurrentStage: ${currentState.class} OverrideStage: ${overrideState.class}")
        }
    }

    static Field[] getAllFields(Class<?> clazz) {
        List<Field> fields = new ArrayList<>();

        // Recorremos la jerarqua de herencia hasta llegar a Object
        while (clazz != null && clazz != Object.class) {
            // Procesamos cada campo declarado en la clase actual
            for (Field field : clazz.getDeclaredFields()) {

                // Filtramos:
                // 1) Campos sintticos (generados por el compilador).
                // 2) (Opcional) Campos estticos, si queremos excluirlos.
                if (!field.isSynthetic() && !Modifier.isStatic(field.getModifiers())) {
                    fields.add(field);
                }
            }

            // Continuamos con la superclase
            clazz = clazz.getSuperclass();
        }

        return fields.toArray(new Field[0]);
    }

    @NonCPS
    private static boolean isSimpleType(Class<?> clazz) {
        return clazz.isPrimitive() || clazz in [String, Boolean, Character, Byte, Short, Integer, Long, Float, Double, Void]
    }

    @NonCPS
    private static boolean shouldSkipField(Field field) {
        return Modifier.isStatic(field.getModifiers()) ||
                Modifier.isFinal(field.getModifiers()) ||
                field.isSynthetic() ||
                field.name == 'metaClass'
    }

    @NonCPS
    private static def mergeValues(def currentValue, def overrideValue) {
        if (!overrideValue && !currentValue) return cloneObject(currentValue)

        for (OverrideHandler handler : handlers) {
            if (handler.shouldHandle(currentValue, overrideValue)) {
                return handler.handle(currentValue, overrideValue)
            }
        }

        if (currentValue instanceof Derivable && overrideValue instanceof Derivable) {
            String currentType = currentValue.getType()
            String overrideType = overrideValue.getType()

            if (currentType != overrideType) {
                return cloneObject(overrideValue)
            }

            Class<?> derivedClass = registeredClasses[currentType] ?: findClassBySimpleName(currentType)
            if (derivedClass == null) {
                throw new RuntimeException("No registered class found for type: ${currentType}")
            }

            return mergeObjects(currentValue, overrideValue)
        }

        if (isSimpleType(currentValue.getClass()) || currentValue.getClass().isEnum()) {
            return updateField(currentValue, overrideValue)
        }

        if (currentValue instanceof Metadata || Metadata.isAssignableFrom(currentValue.getClass())) {
            return mergeMaps(currentValue, overrideValue)
        }

        if (currentValue instanceof ReleaseConfig || ReleaseConfig.isAssignableFrom(currentValue.getClass())) {
            return mergeMaps(currentValue, overrideValue)
        }

        if (currentValue instanceof Map || Map.isAssignableFrom(currentValue.getClass())) {
            return mergeMaps(currentValue, overrideValue)
        }

        if (currentValue instanceof Collection) {
            return mergeCollections(currentValue as Collection, overrideValue as Collection)
        }

        return mergeObjects(currentValue, overrideValue)
    }

    @NonCPS
    private static Map mergeMaps(Map currentMap, Map overrideMap) {
        Map result = new HashMap(currentMap)

        overrideMap?.each { key, value ->
            result[key] = updateField(currentMap[key], value)
        }
        return result
    }

    @NonCPS
    static Class<?> findClassBySimpleName(String simpleName) {
        return ContextSinglenton.context.findClassBySimpleName(simpleName)
    }

    @NonCPS
    private static Metadata mergeMaps(Metadata currentMap, Metadata overrideMap) {
        Metadata result = new Metadata()
        result.putAll(currentMap)
        overrideMap?.each { key, value ->
            result[key] = updateField(currentMap[key], value)
        }
        return result
    }

    @NonCPS
    private static ReleaseConfig mergeMaps(ReleaseConfig currentMap, ReleaseConfig overrideMap) {
        ReleaseConfig result = new ReleaseConfig()
        result.putAll(currentMap)
        overrideMap?.each { key, value ->
            result[key] = updateField(currentMap[key], value)
        }
        return result
    }

    @NonCPS
    private static Collection mergeCollections(Collection currentCollection, Collection overrideCollection) {

        if (!overrideCollection) return cloneObject(currentCollection)

        Collection result = createInstance(currentCollection.getClass())

        if (currentCollection.every { it instanceof Identifiable } && overrideCollection.every { it instanceof Identifiable }) {
            Map<String, Object> mergedMap = [:]

            // Procesar la coleccin actual
            currentCollection.each { item ->
                String id = (item as Identifiable).getId()
                mergedMap[id] = cloneObject(item)
            }

            // Procesar la coleccin de anulacin
            overrideCollection.each { item ->
                String id = (item as Identifiable).getId()
                if (mergedMap.containsKey(id)) {
                    // Si el elemento ya existe, fusionar
                    mergedMap[id] = mergeValues(mergedMap[id], item)
                } else {
                    // Si es un nuevo elemento, aadirlo
                    mergedMap[id] = cloneObject(item)
                }
            }

            result.addAll(mergedMap.values().collect { it })
        } else {
            // Si no todos los elementos son Identifiable, simplemente combinar las colecciones
            result.addAll(currentCollection.findAll { it != null && it != '' }.collect { cloneObject(it) })
            result.addAll(overrideCollection.findAll { it != null && it != '' }.collect { cloneObject(it) })
        }

        return result
    }

    @NonCPS
    private static def cloneObject(def obj) {
        if (obj == null) return null
        if (obj instanceof ModelCloneable) {
            return obj.clone()
        }
        if (isSimpleType(obj.getClass()) || obj.getClass().isEnum()) {
            return obj
        }
        if (obj instanceof Map) {
            return new LinkedHashMap(obj)
        }
        if (obj instanceof List) {
            return new ArrayList(obj)
        }
        if (obj instanceof Set) {
            return new LinkedHashSet(obj)
        }
        if (obj instanceof Derivable) {
            String type = obj.getType()
            Class<?> derivedClass = registeredClasses[type] ?: findClassBySimpleName(type)

            if (derivedClass == null) {
                throw new RuntimeException("No registered class found for type: ${type}")
            }
            return mergeObjects(createInstance(derivedClass), obj)
        }
        return obj
    }

    @NonCPS
    private static <T> T createInstance(Class<T> clazz) {
        if (clazz.isEnum()) {
            return clazz.getEnumConstants()[0]
        }
        try {
            return clazz.newInstance()
        } catch (InstantiationException | IllegalAccessException e) {
            Constructor<?>[] constructors = clazz.getDeclaredConstructors()
            for (Constructor<?> constructor : constructors) {
                if (constructor.getParameterCount() == 0) {
                    constructor.setAccessible(true)
                    return constructor.newInstance() as T
                }
            }
            throw new RuntimeException("No suitable constructor found for ${clazz.getName()}")
        }
    }
}
</file>

<file path="bin/main/es/giss/framework/core/storage/Store.groovy">
package es.giss.framework.core.storage

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.interfaces.StructuredResource
import es.giss.framework.core.storage.interfaces.Effect
import es.giss.framework.core.storage.interfaces.Mutation

class Store<State extends StructuredResource> {
    private State state
    private Map<Class<? extends CoreEvent>, Mutation<State>> mutations
    private Map<Class<? extends CoreEvent>, List<Effect>> effectMap
    private Map<String, List<Map<String,Closure>>> observers = [:].withDefault { [] }


    Store(State initialState) {
        state = initialState
        mutations = [:]
        effectMap = [:].withDefault { [] }

    }

    void dispatch(CoreEvent event) {
            Mutation<State> mutation = mutations[event.getClass()]
            if (mutation) {
                State oldState = state
                state = mutation.apply(state, event)
                notifyObservers(oldState, state)
            }
            List<Effect> effects = effectMap[event.getClass()]
            effects.each { it.handleEvent(event) }
    }



    def void addMutation(Class<? extends CoreEvent> eventType, Mutation<State> mutation) {
        mutations[eventType] = mutation
    }


    void addEffect(Class<? extends CoreEvent> eventType, Effect effect) {
        effectMap[eventType] << effect
    }

    def <T> T select(Closure<T> selector) {
        return selector(state)
    }


    String addObserver(String path, Closure observer) {
        String observerId = UUID.randomUUID().toString()
        observers[path] << [id: observerId, closure: observer.clone()]
        return observerId
    }


    @NonCPS
    void removeObserver(String path, String observerId) {
        observers[path].removeIf { it.id == observerId }
    }


    private void notifyObservers(State oldState, State newState) {
        observers.each { path, observerList ->
            def oldValue = getValueByPath(oldState, path)
            def newValue = getValueByPath(newState, path)
            if (oldValue != newValue) {
                observerList.each { observer ->
                    observer.closure.call(oldValue, newValue)
                }
            }
        }
    }

    private static def getValueByPath(def obj, String path) {
        path.split("\\.").inject(obj) { current, prop -> current?."$prop" }
    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/interfaces/IGitTool.groovy">
package es.giss.framework.core.tools.interfaces


import es.giss.framework.core.interfaces.ITool
import es.giss.framework.core.vo.release.GitCommitContext
import es.giss.framework.core.vo.project.SourceRepository
import es.giss.framework.core.vo.release.interfaces.IGitCommit

interface IGitTool extends ITool {

    boolean cloneInAgent()

    boolean cloneInAgent(String url, String reference)

    boolean cloneInAgent(String url, String reference, String credentialsId)

    boolean cloneInAgent(String url, String reference, String credentialsId, String cloneDir)

    boolean cloneInAgent(String url, String reference, String credentialsId, String cloneDir, Boolean shallowClone)

    void setUserDetails(Boolean override)

    void setUserDetails(Boolean override, String directory)

    String getGitRemoteUrl()

    String getGitRemoteUrl(String name)

    void fetchTags()

    Boolean createTag(String tag)

    Boolean tagExists(String tag)

    Boolean branchExists(String branchName)

    List<String> getAllTags()

    List<String> getAllTags(Boolean fromHead)

    String getTagFromCurrentHead(String tag)

    String getLatestTagFromCurrentHead(String branch)

    String getLatestTagIntegracion(String branch)

    String getLatestTagPatternFromCurrentHead(String pattern)

    String describeTagWithGitSuffix(String tag)

    Boolean currentHeadIsTagged()

    String getCurrentHeadSha()

    String getFirstCommitSha()

    String getCommitId()

    String getCommitId(String reference)

    String getCommitMessage()

    String getCommitMessage(String reference)

    String getCommitEmail()

    String getCommitEmail(String reference)

    List<String> getChangedFilesBetweenCommits(String fromRef, String toRef)

    Boolean isWorkingDirectoryUnmodified()

    Boolean switchToBranch(String branch)

    Boolean addChanges()

    Boolean addFiles(List<String> fileList)

    Boolean createCommit(String message)

    Boolean push()

    Boolean push(boolean force)

    SourceRepository getDefaultSourceRepository()

    String getLatestTagRCFromCurrentHead()

    String getLatestTagReleaseFromCurrentHead()

    String getGitBranch()

    List<IGitCommit> fetchLastCommits(int count)

    GitCommitContext getGitCurrentBranchInfo()

    List getAllTagsMaster()

    String getBranchFromMerge(String hash)
}
</file>

<file path="bin/main/es/giss/framework/core/tools/interfaces/ISemanticRelease.groovy">
package es.giss.framework.core.tools.interfaces

import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.interfaces.ITool
import es.giss.framework.core.vo.release.SemanticVersion


/**
 * Interface for SemanticRelease
 * Coordina todas las tareas necesarias para realizar un releaseStages de un proyecto

 */
interface ISemanticRelease extends Configurable {

//     Analiza los commits para determinar el tipo de releaseStages
    void analyzeCommits()
//
//    // Verifica que se cumplent las condiciones para realizar el release
    boolean verifyConditions()

    boolean incrementTagSnapshot(SemanticVersion currentVersion)

        //Crea el Tag de Master
    void createTagMaster(SemanticVersion currentVersion)
//
//    // Prepara el releaseStages (ej. actualiza versiones, etc.)
//    String prepareRelease(GitFlowType rama, String version)
//
//    // Genera las notas de releaseStages basadas en los commits
//    String generateNotes()
//
//    // Publica el releaseStages (ej. publica el artefacto en un repositorio)
//    void publishRelease(String version, String releaseNotes)
//
//    // Ejecuta las acciones posteriores al releaseStages exitoso
//    void success()
//
//    // Ejecuta las acciones posteriores al releaseStages fallido
//    void fail(Exception e)
//
//    // Verifica si una rama est permitida para realizar un releaseStages
//    boolean isBranchAllowedForRelease(String branch)
//
//    void execute()
}
</file>

<file path="bin/main/es/giss/framework/core/tools/interfaces/IToolsManager.groovy">
package es.giss.framework.core.tools.interfaces

import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.interfaces.IToolsStrategy

interface IToolsManager extends Configurable {

    void setToolVersion(String tool, String version)

    void registerToolStrategy(IToolsStrategy strategy)
}
</file>

<file path="bin/main/es/giss/framework/core/tools/interfaces/IWorkspaceTool.groovy">
package es.giss.framework.core.tools.interfaces

import es.giss.framework.core.interfaces.ITool
import es.giss.framework.core.vo.WatchFiles

import java.nio.file.Path

interface IWorkspaceTool extends ITool {

    Boolean directoryExists(String directory)

    Boolean fileExists(String file)

    void createDirectoriesIfNotExist(List<String> dirs)

    void writeFile(String file, String text)

    String readFile(String file)

    Boolean globMatch(String pattern, String filePath)

    Boolean globMatch(String pattern, String filePath, boolean caseSensitive)

    Boolean checkWatchedFiles()

    Boolean checkWatchedFiles(Boolean abortPipeline)

    Boolean checkWatchedFiles(Boolean abortPipeline, List<String> inclusions, List<String> exclusions)

    List<Path> findFiles(String directory, String pattern)

    Path findClosestFile(String directory, String pattern)

    void setWatchFiles(WatchFiles watchFiles)

}
</file>

<file path="bin/main/es/giss/framework/core/tools/restClients/interfaces/IGitLabTool.groovy">
package es.giss.framework.core.tools.restClients.interfaces

interface IGitLabTool {

    IGitLabTool credentialsId(String credentialsId)

    IGitLabTool baseUrl(String baseUrl)

    IGitLabTool ignoreSsl(Boolean ignoreSsl)

    IGitLabTool apiNamespace(String apiNamespace)

    IGitLabTool debugMode(Boolean debugMode)

    Map<String, Serializable> getMergeRequest(Object projectIdOrPath, Integer mergeRequestId)

    List<Map<String, Serializable>> getOpenedMergeRequests(Object projectIdOrPath,
                                                           String sourceBranch,
                                                           String targetBranch)

    Map<String, Serializable> createMergeRequest(Object projectIdOrPath,
                                                 String sourceBranch,
                                                 String targetBranch,
                                                 String title,
                                                 String description,
                                                 Boolean removeSourceBranch,
                                                 Boolean squash)

    Map<String, Serializable> approveMergeRequest(Object projectIdOrPath, Integer mergeRequestIid)

    Map<String, Serializable> acceptMergeRequest(Object projectIdOrPath,
                                                 Integer mergeRequestIid,
                                                 String mergeCommitMessage,
                                                 Boolean shouldRemoveSourceBranch,
                                                 Boolean mergeWhenPipelineSucceeds)

    Map<String, Serializable> createReleaseNotes(Object projectIdOrPath, String tagId, String notes)

    List<Map<String, Serializable>> getMergeRequestStatuses(Object projectIdOrPath, Integer mergeRequestIid)

    List<Map<String, Serializable>> getCommitStatuses(Object projectIdOrPath, String sha)

    List<Map<String, Serializable>> listProjectUsers(Object projectIdOrPath)

    Integer getUserId(String username)

    List<Map<String, Serializable>> userInParentGroups(Object projectIdOrPath, List<Integer> userIds)

    Boolean projectUserExists(Object projectIdOrPath, String username, Boolean includeParentGroups)

    Boolean projectUserExists(Object projectIdOrPath, String username)

    Integer getProjectId(Object projectIdOrPath)

    Integer getGroupId(Object groupIdOrPath)

    Map<String, Serializable> getGroupOrNull(Object groupIdOrPath)

    String getProjectPathFromUrl(String url)

    String getRawFile(Object projectIdOrPath, String ref, String filePath)

    String getRawFileByPath(String projectPath, String ref, String filePath)

    List<Map<String, String>> getTags(Object projectIdOrPath, String tagPattern)

    Boolean existTag(Object projectIdOrPath, String tagReference)

    Map<String, String> createTag(String projectIdOrPath, String tagName, String message, String releaseNotes)

    List<Map<String, Serializable>> getDirectoryContent(Object projectIdOrPath, String ref, String dirPath)

    void fetchGitLabDirFiles(Object projectIdOrPath, String ref, String dirPath, String destinationPath)

    List<String> getProjectLabels(Object projectIdOrPath)
}
</file>

<file path="bin/main/es/giss/framework/core/tools/restClients/interfaces/IRestClient.groovy">
package es.giss.framework.core.tools.restClients.interfaces

import es.giss.framework.core.tools.ProxyHost
import es.giss.framework.core.tools.restClients.CredentialType
import es.giss.framework.core.vo.resources.http.HttpResponse

import java.nio.file.Path

interface IRestClient {

    IRestClient url(String url)

    IRestClient header(String name, String value)

    IRestClient body(String body)

    IRestClient get()

    IRestClient get(Map<String,Object> queryParams)

    IRestClient post()

    IRestClient post(Map<String,Object> body)

    IRestClient put()

    IRestClient put(Map<String,Object> body)

    IRestClient delete()

    IRestClient withAuthBasic(String credentialsId)

    IRestClient withAuthBasic(String credentialsId, CredentialType credentialType)

    IRestClient withAuthBearer(String credentialsId)

    IRestClient withAuthBearer(String credentialsId,  CredentialType credentialType)

    IRestClient withCustomHeaderAuth(String credentialsId, String headerName)

    IRestClient withCustomHeaderAuth(String credentialsId, String headerName,  CredentialType credentialType)

    IRestClient debugMode(Boolean debugMode)

    IRestClient proxy(ProxyHost proxyHost)

    IRestClient caCert(Path caCertPath)

    IRestClient ignoreSsl(Boolean ignoreSsl)

    IRestClient pathDownloadFile(Path pathDownloadFile)

    IRestClient nameDownloadFile(String nameDownloadFile)

    IRestClient followRedirects(Boolean followRedirects)

    HttpResponse execute()

    HttpResponse download()

}
</file>

<file path="bin/main/es/giss/framework/core/tools/restClients/CredentialType.groovy">
package es.giss.framework.core.tools.restClients

enum CredentialType {
    TOKEN,
    USERNAME_PASSWORD,
    STRING,
    USERNAME_COLON_PASSWORD
}
</file>

<file path="bin/main/es/giss/framework/core/tools/restClients/GitLabTool.groovy">
package es.giss.framework.core.tools.restClients

import es.giss.framework.core.Steps
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.tools.restClients.interfaces.IGitLabTool
import es.giss.framework.core.tools.restClients.interfaces.IRestClient
import es.giss.framework.core.vo.resources.http.HttpResponse

import java.nio.charset.StandardCharsets

class GitLabTool extends Steps implements IGitLabTool {

    private String apiNamespace = 'api/v4'
    private String credentialsId
    private String baseUrl
    private Boolean ignoreSsl = false
    private Script steps
    private Boolean isDebug = false


    GitLabTool(Script steps, ILogger logger) {
        this.steps = steps
        this.logger = logger
    }

    GitLabTool credentialsId(String credentialsId) {
        this.credentialsId = credentialsId
        return this
    }

    GitLabTool baseUrl(String baseUrl) {
        this.baseUrl = baseUrl
        return this
    }

    GitLabTool debugMode(Boolean debugMode) {
        this.isDebug = debugMode
        return this
    }

    GitLabTool ignoreSsl(Boolean ignoreSsl) {
        this.ignoreSsl = ignoreSsl
        return this
    }

    GitLabTool apiNamespace(String apiNamespace) {
        this.apiNamespace = apiNamespace
        return this
    }


    @Override
    Map<String, Serializable> getMergeRequest(Object projectIdOrPath, Integer mergeRequestId) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests/${mergeRequestId}") as Map
    }

    @Override
    List<Map<String, Serializable>> getOpenedMergeRequests(Object projectIdOrPath, String sourceBranch, String targetBranch) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        def params = [
                source_branch: sourceBranch,
                target_branch: targetBranch,
                state        : 'opened'
        ]
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests", [:], params) as List<Map>
    }

    @Override
    Map<String, Serializable> createMergeRequest(
            Object projectIdOrPath, String sourceBranch, String targetBranch, String title, String description,
            Boolean removeSourceBranch, Boolean squash
    ) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        Map payload = [source_branch       : sourceBranch,
                       target_branch       : targetBranch,
                       title               : title,
                       description         : description,
                       remove_source_branch: removeSourceBranch,
                       squash              : squash
        ]
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests", payload) as Map
    }

    @Override
    Map<String, Serializable> approveMergeRequest(Object projectIdOrPath, Integer mergeRequestIid) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests/${mergeRequestIid}/approve") as Map
    }

    @Override
    Map<String, Serializable> acceptMergeRequest(
            Object projectIdOrPath, Integer mergeRequestIid, String mergeCommitMessage,
            Boolean shouldRemoveSourceBranch, Boolean mergeWhenPipelineSucceeds
    ) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        Map payload = [
                merge_commit_message        : mergeCommitMessage,
                should_remove_source_branch : shouldRemoveSourceBranch,
                merge_when_pipeline_succeeds: mergeWhenPipelineSucceeds
        ]
        return performRequest('PUT', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests/${mergeRequestIid}/merge", payload) as Map
    }

    @Override
    Map<String, Serializable> createReleaseNotes(Object projectIdOrPath, String tagId, String notes) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        Map payload = [
                tag_name   : tagId,
                description: notes
        ]
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/releases", payload) as Map
    }

    @Override
    List<Map<String, Serializable>> getMergeRequestStatuses(Object projectIdOrPath, Integer mergeRequestIid) {
        def mergeRequest = getMergeRequest(projectIdOrPath, mergeRequestIid)
        return getCommitStatuses(projectIdOrPath, mergeRequest.sha as String)
    }

    @Override
    List<Map<String, Serializable>> getCommitStatuses(Object projectIdOrPath, String sha) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/commits/${sha}/statuses") as List<Map>
    }

    @Override
    List<Map<String, Serializable>> listProjectUsers(Object projectIdOrPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/members") as List
    }

    @Override
    Boolean projectUserExists(Object projectIdOrPath, String username, Boolean includeParentGroups = false) {
        Integer userId = getUserId(username)
        List users = []
        if (includeParentGroups) {
            users.addAll(userInParentGroups(projectIdOrPath, [userId]))
        }
        users.addAll(listProjectUsers(projectIdOrPath))
        logger.debug "users check if exists: ${users}"
        List userExists = users.findAll { user ->
            user.state == 'active' && user.username.equalsIgnoreCase(username)
        }

        return userExists.size() > 0
    }

    @Override
    Integer getUserId(String username) {
        Map queryParams = [username: username]
        List<Map> user = performRequest('GET', "${apiNamespace}/users", [:], queryParams) as List<Map>
        return user[0].id as Integer
    }

    @Override
    List<Map<String, Serializable>> userInParentGroups(Object projectIdOrPath, List<Integer> user_ids) {
        Map queryParams = [user_ids: user_ids.join(',')]
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/members/all", [:], queryParams) as List
    }

    @Override
    Map<String, String> createTag(String projectIdOrPath, String tagName, String message, String releaseNotes) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath)
        Map payload = [
                tag_name           : tagName,
                ref                : 'master',
                message            : message,
                release_description: releaseNotes
        ]
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/tags/", payload) as Map
    }

    @Override
    Integer getProjectId(Object projectIdOrPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        def project = performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}") as Map
        return project.id as Integer
    }

    @Override
    String getRawFile(Object projectIdOrPath, String ref, String filePath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        String encodedFilePath = encodeValue(filePath)
        return performRequest(
                'GET',
                "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/files/${encodedFilePath}/raw",
                [:],
                [ref: ref],
                false)
    }

    @Override
    String getRawFileByPath(String projectPath, String ref, String filePath) {
        Integer idProject = getProjectId(projectPath)
        return getRawFile(idProject, ref, filePath)
    }

    @Override
    List<Map<String, Serializable>> getDirectoryContent(Object projectIdOrPath, String ref, String dirPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        String encodedDirPath = encodeValue(dirPath.replaceAll(/\/$/, ''))
        return   performRequest(
                'GET',
                "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/tree",
                [:],
                [ref: ref, path: encodedDirPath, recursive: true],
                true) as List<Map>
    }

    List<String> getProjectLabels(Object projectIdOrPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/labels")*.name as List
    }

    @Override
    void fetchGitLabDirFiles(Object projectIdOrPath, String ref, String dirPath, String destinationPath) {
        List<Map<String, Serializable>> directoryContent = getDirectoryContent(projectIdOrPath, ref, dirPath)
        logger.debug("Gitlab Repository Files in ${dirPath}: ${directoryContent}")
        directoryContent.each { item ->
            logger.debug("Gitlab Repository Item ${item.name} in ${dirPath}")
            if (item.type == "blob") { // Es un archivo
                String fileContent = getRawFile(projectIdOrPath, ref, "${item.path}")
                // Hacer algo con fileContent
                steps.sh("mkdir -p ${destinationPath}/${(item.path as String).replaceAll(item.name, '')}")
                steps.writeFile(file: "${destinationPath}/${item.path}", text: fileContent)
                logger.debug("Gitlab Repository File ${item.path} fetched")
            }

        }
    }

    @Override
    List<Map<String, String>> getTags(Object projectIdOrPath, String tagPattern) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest(
                'GET',
                "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/tags",
                [:],
                [order_by: 'updated', sort: 'desc', search: tagPattern ?: '']
        ) as List<Map<String, String>>
    }

    @Override
    Boolean existTag(Object projectIdOrPath, String tagReference) {
        def listTags = getTags(projectIdOrPath, tagReference)
        return listTags.isEmpty() ? false : true
    }

    @Override
    Integer getGroupId(Object groupIdOrPath) {
        String encodedGroupIdOrPath = encodeValue(groupIdOrPath as String)
        def group = performRequest('GET', "${apiNamespace}/groups/${encodedGroupIdOrPath}") as Map
        return group.id as Integer
    }

    @Override
    Map<String, Serializable> getGroupOrNull(Object groupIdOrPath) {
        String encodedGroupIdOrPath = encodeValue(groupIdOrPath as String)
        try {
            return performRequest('GET', "${apiNamespace}/groups/${encodedGroupIdOrPath}") as Map
        } catch (ignored) {
            return [:]
        }
    }

    @Override
    String getProjectPathFromUrl(String url) {
        // We want to get the project path (including group and subgroups)
        if (url =~ /^http/ || url =~ /^\/opt\//) {
            // The repository url follows the expression 'protocol://gitlab_domain/group1/group2.../project'
            return url?.trim().tokenize('/').drop(2).join('/').replaceAll(/.git$/, '')
        }

        // Here for ssh protocol user@gitlab_domain:group1/group2.../project.git
        return url.trim().tokenize(':').takeRight(1).join('/').replaceAll(/.git$/, '')
    }

    private static String encodeValue(String value) {
        return URLEncoder.encode(value, StandardCharsets.UTF_8.toString())
    }

    private Object performRequest(
            String method, String path, Map body = [:], Map queryParams = [:], Boolean mapJsonBody = true
    ) {

        IRestClient client = new RestClient(steps)
                .withCustomHeaderAuth(credentialsId, 'PRIVATE-TOKEN', CredentialType.USERNAME_PASSWORD)
                .url("$baseUrl/${path}")
                .debugMode(true)
                .ignoreSsl(ignoreSsl)

        switch (method.toUpperCase()) {
            case 'GET':
                client.get(queryParams)
                break
            case 'POST':
                client.post(body)
                break
            case 'PUT':
                client.put(body)
                break
            case 'DELETE':
                client.delete()
                break
            default:
                throw new IllegalArgumentException("Method $method not supported")
        }

        HttpResponse response = client.execute()


        if (response.statusCode >= 400) {
            def bodyString = body.collect { "$it.key : $it.value".toString() } as String
            logger.error("GitlabTool response: ${response.statusCode} - ${response.body}")
            steps.error("GitLabTool Error in request to GitLab with credentialsId: $credentialsId, baseUrl: $baseUrl, path: $path, method: $method, body: $bodyString, queryParams: $queryParams")
        }

        return mapJsonBody ? response.parseJsonBody() : response.body
    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/restClients/RestClient.groovy">
package es.giss.framework.core.tools.restClients


import es.giss.framework.core.tools.ProxyHost
import es.giss.framework.core.tools.restClients.interfaces.IRestClient
import es.giss.framework.core.vo.resources.http.HttpResponse
import groovy.json.JsonOutput

import java.nio.file.Path

/**
 * RestClient class.
 * This class provides methods to perform HTTP requests.
 */
class RestClient implements IRestClient {

    private Script steps
    private String method = 'GET'
    private String url = ''
    private Map<String, String> headers = [:]
    private Map<String, String> forms = [:]
    private String body = ''
    private String credentialsId = ''
    private CredentialType credentialType = CredentialType.USERNAME_PASSWORD
    private Path pathDownloadFile // Por defecto el directorio actual
    private String nameDownloadFile // Por defecto el nombre del repositorio -O/-o name
    private Boolean followRedirects = false // Para seguir las redirecciones --> -L
    private String authType = 'basic'
    private Boolean debugMode = false
    private ProxyHost proxy
    private Path caCertPath
    private Map<String, Object> queryParams = [:]
    private Boolean disableSecureConnectionVerification
    private String customAuthHeaderName


    RestClient(Script steps) {
        this.steps = steps
    }

    RestClient proxy(ProxyHost proxyHost) {
        this.proxy = proxyHost
        return this
    }

    /**
     * Sets the base URI for the HTTP request.
     *
     * @param url The base URI.
     * @return The RestClient instance.
     */
    @Override
    RestClient url(String url) {
        this.url = url
        return this
    }

    @Override
    RestClient header(String name, String value) {
        this.headers[name] = value
        return this
    }

    @Override
    RestClient body(String body) {
        this.body = body
        return this
    }

    @Override
    RestClient get() {
        return get([:])
    }

    @Override
    IRestClient get(Map<String, Object> queryParams) {
        this.method = 'GET'
        this.queryParams = queryParams
        return this
    }

    @Override
    RestClient post() {
        return post([:])
    }

    @Override
    IRestClient post(Map<String, Object> bodyParams) {
        this.method = 'POST'
        if (bodyParams) {
            this.body = JsonOutput.toJson(bodyParams)
        }
        return this
    }

    @Override
    RestClient put() {
        this.method = 'PUT'
        return this
    }

    @Override
    IRestClient put(Map<String, Object> bodyParams) {
        if (bodyParams) {
            this.body = JsonOutput.toJson(bodyParams)
        }
        return this
    }

    @Override
    RestClient delete() {
        this.method = 'DELETE'
        return this
    }

    RestClient form(String name, String value) {
        this.forms[name] = value
        return this
    }

    RestClient form(Map<String, String> formParams) {
        formParams.each { k, v ->
            form(k, v)
        }
        return this
    }

    @Override
    RestClient withAuthBasic(String credentialsId, CredentialType credentialType = CredentialType.USERNAME_PASSWORD) {
        this.credentialsId = credentialsId
        this.credentialType = credentialType
        this.authType = 'basic'
        return this

    }

    @Override
    RestClient withAuthBearer(String credentialsId, CredentialType credentialType = CredentialType.STRING) {
        this.credentialsId = credentialsId
        this.credentialType = credentialType
        this.authType = 'bearer'
        return this
    }

    @Override
    IRestClient withCustomHeaderAuth(String credentialsId, String headerName, CredentialType credentialType = CredentialType.STRING) {
        this.credentialsId = credentialsId
        this.credentialType = credentialType
        this.authType = 'customHeader'
        this.customAuthHeaderName = headerName
        return this
    }

    @Override
    RestClient debugMode(Boolean debugMode) {
        this.debugMode = debugMode
        return this
    }

    @Override
    IRestClient caCert(Path caCertPath) {
        this.caCertPath = caCertPath
        return this
    }

    @Override
    IRestClient ignoreSsl(Boolean disableSecureConnectionVerification) {
        this.disableSecureConnectionVerification = disableSecureConnectionVerification
        return this
    }

    @Override
    IRestClient pathDownloadFile(Path pathDownloadFile) {
        this.pathDownloadFile = pathDownloadFile
        return this
    }

    @Override
    IRestClient nameDownloadFile(String nameDownloadFile) {
        this.nameDownloadFile = nameDownloadFile
        return this
    }

    @Override
    IRestClient followRedirects(Boolean followRedirects) {
        this.followRedirects = followRedirects
        return this
    }

    Map getUsernamePassword(String credentialsId) {
        steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'USER', passwordVariable: 'PASS')]) {
            if (!steps.env.USER || !steps.env.PASS) {
                steps.error("Username and password must be provided for credentialsId: $credentialsId")
            }
            return ['user': steps.env.USER, 'pass': steps.env.PASS]
        }
    }

    Map getTokenAsUsernamePassword(String credentialsId) {
        steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'USER', passwordVariable: 'PASS')]) {
            if (!steps.env.USER || !steps.env.PASS) {
                steps.error("Token as username and password must be provided for credentialsId: $credentialsId")
            }
            return ['token': steps.env.PASS]
        }
    }

    Map getStringCredentials(String credentialsId) {
        steps.withCredentials([steps.string(credentialsId: credentialsId, variable: 'TOKEN')]) {
            if (!steps.env.TOKEN) {
                steps.error("Token must be provided for credentialsId: $credentialsId")
            }
            return ['token': steps.env.TOKEN]
        }
    }

    Map getTokenCredentials(String credentialsId) {
        steps.withCredentials([steps.token(credentialsId: credentialsId, variable: 'TOKEN')]) {
            if (!steps.env.TOKEN) {
                steps.error("Token must be provided for credentialsId: $credentialsId")
            }
            return ['token': steps.env.TOKEN]
        }
    }

    Map getUsernameColonPassword(String credentialsId) {
        steps.withCredentials([steps.usernameColonPassword(credentialsId: credentialsId, variable: 'USER_PASS')]) {
            if (!steps.env.USER_PASS) {
                steps.error("Username and password must be provided for credentialsId: $credentialsId")
            }
            return ['userPass': steps.env.USER_PASS]
        }
    }

    String normalizeQueryParams(Map<String, Object> params) {
        return params.collect { k, v -> "${URLEncoder.encode(k.toString(), "UTF-8")}=${URLEncoder.encode(v.toString(), "UTF-8")}" }.join('&')
    }

    String getUrlWithQueryParams(String url, Map<String, Object> queryParams) {
        return url + (queryParams ? "?${normalizeQueryParams(queryParams)}" : '')
    }

    /**
     * Executes the HTTP request.
     *
     * Example usage:
     * <pre>
     * {@code
     * def client = new RestClient(steps)
     * def response = client
     *     .url('https://jsonplaceholder.typicode.com/posts/1')
     *     .header('Content-Type', 'application/json')
     *     .withAuthBasic('my-credentials-id', CredentialType.USERNAME_PASSWORD)
     *     .get()
     *     .execute()
     * println "Status: ${response.status}"
     * println "Body: ${response.body}"
     *}
     * </pre>
     *
     * @return A Map containing the status and body of the HTTP response.
     */
    @Override
    HttpResponse execute() {
        String temporalWorkingDir = "${steps.env.WORKSPACE}@tmp/http"
        steps.sh(script: "mkdir -p ${temporalWorkingDir}")
        String urlWithQueryParams = getUrlWithQueryParams(url, queryParams)
        if (!urlWithQueryParams) {
            steps.error("[RestClient.execute()] URL is required to perform the request")
        }
        def safeUrlPart = getSafeUrlPart(urlWithQueryParams) // Limita la longitud a 30 caracteres

        String fileSuffix = getFileSuffix()
        String scriptName = "${temporalWorkingDir}/curl_${safeUrlPart}_${fileSuffix}.sh"
        String responseFileName = "${temporalWorkingDir}/resp_${safeUrlPart}_${fileSuffix}.txt"
        String responseCode = ''
        String responseBody = ''

        try {

            String commandArgs = mountCommonsCommandArgs()
            commandArgs = "${commandArgs} -o ${responseFileName}"
            commandArgs = completeComandArgsWithCredentials(commandArgs)
            if (debugMode) {
                commandArgs = "-v ${commandArgs}"
            }

            String debugCommand = debugMode ? 'set -x' : 'set +x'
            String proxyCommand = proxy ? "export http_proxy=${proxy.toString()}; export https_proxy=${proxy.toString()};" : ''
            String unsetProxyCommand = proxy ? "unset http_proxy; unset https_proxy;" : ''

            steps.writeFile(file: scriptName, text: """
                    set +x\n
                    ${proxyCommand}\n
                    curl -L ${commandArgs} "${urlWithQueryParams}"\n
                    ${unsetProxyCommand}\n
                """)

            responseCode = steps.sh(
                    script: """
                        ${debugCommand}
                        chmod +x ${scriptName}
                        bash ${scriptName}
                    """,
                    returnStdout: true)
                    .trim()

            assert !(/[\d]{3}/ ==~ responseCode): "Error: El response code no devuelve un estado valido - ${responseCode}"

            responseBody = steps.readFile(file: responseFileName)
            return new HttpResponse(statusCode: responseCode.toInteger(), body: responseBody)

        } catch (Exception e) {

            if (!responseBody) {
                responseBody = """{
                    "error": "Error executing request: ${e.message}",
                    "url": "$url",
                    "credentialType": "$credentialType",
                    "credentialsId": "$credentialsId",
                    "authType": "$authType",
                    "debugMode": "$debugMode",
                    "proxy": "$proxy",
                    "caCertPath": "$caCertPath",
                    "ignoreSsl": "$disableSecureConnectionVerification",
                    "customAuthHeaderName": "$customAuthHeaderName"
                }
            """
            }
            return new HttpResponse(statusCode: responseCode.isEmpty() ? 500 : responseCode.toInteger(), body: responseBody)

        } finally {
            if (!steps.env.DEVELOPMENT_MODE) {
//                steps.sh(script: "rm -f ${scriptName} ${responseFileName} || true")
            }
        }
    }

    private String getFileSuffix() {
        String.format("%04d", (System.currentTimeMillis() / 1000).intValue() % 6000)
    }

    private String getSafeUrlPart(String urlWithQueryParams) {
        if (urlWithQueryParams == null || urlWithQueryParams.isEmpty()) {
            throw new IllegalArgumentException("URL is required to perform the request")
        }

        def urlParts = urlWithQueryParams
                .replaceAll('https?://', '') // Elimina http:// o https://
                .split('/', 2) // Divide en dominio y path

        def domain = urlParts[0]?.split('[.-]')?.getAt(0) ?: urlWithQueryParams
        // Primera parte del dominio (hasta punto o guin)
        def path = urlParts.length > 1 ? urlParts[1] : '' // Path completo si existe

        return (domain + '_' + path)
                .replaceAll('[^a-zA-Z0-9]', '_') // Reemplaza caracteres especiales con _
                .take(60) // Limita la longitud total
    }

    private String mountCommonsCommandArgs() {
        String headerOptions = headers.collect { k, v -> "-H \"$k: $v\"" }.join(' ')
        String formOptions = forms.collect { k, v -> "-F '$k=$v'" }.join(' ')
        String bodyOption = body ? "--data \'$body\'" : ''
        String caCertOption = caCertPath ? "--cacert $caCertPath" : ''
        String ignoreSslOption = disableSecureConnectionVerification ? "-k" : ''

        String commandArgs = "-s -w \"%{http_code}\" -X $method"
        if (formOptions) {
            commandArgs = "${commandArgs} ${formOptions}"
        }

        if (headerOptions) {
            commandArgs = "${commandArgs} ${headerOptions}"
        }

        if (bodyOption) {
            commandArgs = "${commandArgs} ${bodyOption}"
        }

        if (caCertOption) {
            commandArgs = "${commandArgs} ${caCertOption}"
        }

        if (ignoreSslOption) {
            commandArgs = "${ignoreSslOption} ${commandArgs}"
        }

        return commandArgs
    }

    private String completeComandArgsWithCredentials(String commandArgs) {
        if (credentialsId) {
            switch (authType) {
                case 'basic':
                    if (credentialType == CredentialType.USERNAME_PASSWORD) {
                        def userPass = getUsernamePassword(credentialsId)
                        commandArgs = "-u ${userPass.user}:${userPass.pass} ${commandArgs}"
                    } else if (credentialType == CredentialType.USERNAME_COLON_PASSWORD) {
                        def userPass = getUsernameColonPassword(credentialsId)
                        commandArgs = "-u ${userPass.userPass} ${commandArgs}"
                    } else {
                        steps.error("Credential type $credentialType not supported")
                    }
                    break
                case 'bearer':
                    if (credentialType == CredentialType.STRING) {
                        def token = getStringCredentials(credentialsId).token
                        commandArgs = "-H \"Authorization: Bearer ${token}\" ${commandArgs}"
                    } else if (credentialType == CredentialType.TOKEN) {
                        def token = getTokenCredentials(credentialsId).token
                        commandArgs = "-H \"Authorization: Bearer ${token}\" ${commandArgs}"
                    } else if (credentialType == CredentialType.USERNAME_PASSWORD) {
                        def token = getTokenAsUsernamePassword(credentialsId).token
                        commandArgs = "-H \"Authorization: Bearer ${token}\" ${commandArgs}"
                    } else {
                        steps.error("Credential type $credentialType not supported")
                    }
                    break
                case 'customHeader':
                    if (credentialType == CredentialType.STRING) {
                        def token = getStringCredentials(credentialsId).token
                        commandArgs = "-H \"${customAuthHeaderName}: ${token}\" ${commandArgs}"
                    } else if (credentialType == CredentialType.TOKEN) {
                        def token = getTokenCredentials(credentialsId).token
                        commandArgs = "-H \"${customAuthHeaderName}: ${token}\" ${commandArgs}"
                    } else if (credentialType == CredentialType.USERNAME_PASSWORD) {
                        def userPass = getUsernamePassword(credentialsId)
                        commandArgs = "-H \"${customAuthHeaderName}: $userPass.pass\" ${commandArgs}"
                    } else {
                        steps.error("Credential type $credentialType not supported")
                    }
                    break
                default:
                    steps.error("Auth type $authType not supported")
            }

        }
        return commandArgs
    }

    @Override
    HttpResponse download() {
        String temporalWorkingDir = "${steps.env.WORKSPACE}@tmp/http_downloads"
        steps.sh(script: "mkdir -p ${temporalWorkingDir}")
        String urlWithQueryParams = getUrlWithQueryParams(url, queryParams)
        String fileSuffix = getFileSuffix()
        String safeUrlPart = getSafeUrlPart(urlWithQueryParams)

        String scriptName = "${temporalWorkingDir}/curl_${safeUrlPart}_${fileSuffix}.sh"
        String responseCode = ''
        String responseBody = ''

        try {

            String commandArgs = mountCommonsCommandArgs()
            commandArgs = completeComandArgsWithCredentials(commandArgs)
            if (pathDownloadFile.toString()) {
                steps.sh(script: "mkdir -p ${pathDownloadFile.normalize().toString()}")
                nameDownloadFile = "${pathDownloadFile.toString()}/${nameDownloadFile}".toString()
            }
            if (nameDownloadFile) {
                commandArgs = "${commandArgs} -o ${nameDownloadFile}".toString()
                responseBody = "RestClient for download file with name ${nameDownloadFile} from ${url}".toString()
            } else {
                commandArgs = "${commandArgs} -O".toString()
                responseBody = "RestClient for download file from from ${url}".toString()
            }
            if (followRedirects) {
                commandArgs = "${commandArgs} -L"
            }


            if (debugMode) {
                commandArgs = "-v ${commandArgs}".toString()
            }

            String debugCommand = debugMode ? 'set -x' : 'set +x'
            String proxyCommand = proxy ? "export http_proxy=${proxy.toString()}; export https_proxy=${proxy.toString()};".toString() : ''
            String unsetProxyCommand = proxy ? "unset http_proxy; unset https_proxy;" : ''


            steps.writeFile(file: scriptName, text: """
                    ${debugCommand}\n
                    ${proxyCommand}\n
                    curl ${commandArgs} "${urlWithQueryParams}"\n
                    ${unsetProxyCommand}\n
                """.toString())

            responseCode = steps.sh(
                    script: """
                        ${debugCommand}
                        chmod +x ${scriptName}
                        bash ${scriptName}
                    """.toString(),
                    returnStdout: true)
                    .trim()

            return new HttpResponse(statusCode: responseCode.toInteger(), body: responseBody)

        } catch (Exception e) {
            if (!responseBody) {
                responseBody = """{
                    "error": "Error executing request: ${e.message}",
                    "url": "$url",
                    "credentialType": "$credentialType",
                    "credentialsId": "$credentialsId",
                    "authType": "$authType",
                    "debugMode": "$debugMode",
                    "proxy": "$proxy",
                    "caCertPath": "$caCertPath",
                    "ignoreSsl": "$disableSecureConnectionVerification",
                    "customAuthHeaderName": "$customAuthHeaderName"
                }
            """
            }
            return new HttpResponse(statusCode: responseCode.isEmpty() ? 500 : responseCode.toInteger(), body: responseBody)

        } finally {
            if (!steps.env.DEVELOPMENT_MODE) {
//                steps.sh(script: "rm -f ${scriptName} || true")
            }

        }
    }

}
</file>

<file path="bin/main/es/giss/framework/core/tools/strategies/AlternativesToolsManagerStrategy.groovy">
package es.giss.framework.core.tools.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.IToolsStrategy
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.vo.pipeline.PipelineDefinition

@PipelineComponent(name = 'AlternativesToolsManagerStrategy', priority = ConfigurationPriority.EXCLUDED)
class AlternativesToolsManagerStrategy extends Steps implements IToolsStrategy {

    private String toolJava

    AlternativesToolsManagerStrategy(IToolsManager toolsManager) {
        toolsManager.registerToolStrategy(this)
    }

    @Override
    void setToolVersion(String tool, String version) {
        setJavaVersion(version)
    }

    @Override
    boolean filterTool(String tool) {
        return tool.contains("java")
    }

    @NonCPS
    @Override
    int priority() {
        return 2
    }

    private void setJavaVersion(String javaVersion) {
        // Convertir versiones de Java 8 o 1.8 a 1.8.0
        if (javaVersion == "8" || javaVersion == "1.8") {
            javaVersion = "1.8.0"
        }
        String destinationPath = "${steps.env.WORKSPACE}@tmp/.alternatives/setJava.sh".toString()
        if (steps.fileExists(file: destinationPath)) {
            steps.sh(script: "rm -f ${destinationPath}")
        }
        steps.writeFile(file: destinationPath, text:
                '''
                        #!/bin/bash
                        set -x
                        JAVA_VERSION=$1
                        
                        # Funcin para encontrar directorios de Java
                        find_java_dirs() {
                            find /usr/lib/jvm -maxdepth 1 -type d -name "*${1}*" 2>/dev/null
                        }
                        
                        # Validar que se proporcion una versin
                        if [ -z "${JAVA_VERSION}" ]; then
                            echo "Uso: $0 <versin-java>"
                            echo "Ejemplo: $0 1.8.0"
                            exit 1
                        fi
                        
                        # Encontrar el directorio de Java correspondiente
                        JAVA_DIR=$(find_java_dirs ${JAVA_VERSION} | head -n 1)
                        
                        if [ -z "${JAVA_DIR}" ]; then
                            echo "No se encontr la instalacin de Java ${JAVA_VERSION}"
                            echo "Instalaciones disponibles:"
                            ls -1 /usr/lib/jvm/
                            exit 1
                        fi
                        
                        # Validar que las rutas de java y javac existen
                        JAVA_BIN="${JAVA_DIR}/bin/java"
                        JAVAC_BIN="${JAVA_DIR}/bin/javac"
                        
                        if [ ! -f "${JAVA_BIN}" ]; then
                            echo "El archivo ${JAVA_BIN} no existe. Verifica la instalacin de Java ${JAVA_VERSION}."
                            exit 1
                        fi
                        
                        if [ ! -f "${JAVAC_BIN}" ]; then
                            echo "El archivo ${JAVAC_BIN} no existe. Verifica la instalacin de Java ${JAVA_VERSION}."
                            exit 1
                        fi
                        
                        # Configurar las alternativas
                        alternatives --install /usr/bin/java java "${JAVA_BIN}" 1
                        alternatives --install /usr/bin/javac javac "${JAVAC_BIN}" 1
                        
                        alternatives --set java "${JAVA_BIN}"
                        alternatives --set javac "${JAVAC_BIN}"
                        
                        echo "Java ${JAVA_VERSION} configurado correctamente"
                        java -version
                        echo "---------------------"
                        javac -version
            '''
        )


        Integer result = steps.sh(script: """
                            chmod +x ${destinationPath}
                            ${destinationPath} ${javaVersion}
                        """.trim(), returnStatus: true)

        if (result != 0) {
            steps.error("[AlternativesToolsManagerStrategy.setJavaVersion()] Errorn no se ha podido configurar la versin de Java ${javaVersion}")
        }

    }

    @Override
    Integer executeWithStatus(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStatus: true)
    }

    @Override
    String execute(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStdout: true)?.trim()
    }


    @Override
    void configure(IPipelineContext context) {
        Store<PipelineDefinition> pipelineStorage = context.getStore(PipelineDefinition.class)
        toolJava =pipelineStorage.select { PipelineDefinition descriptor -> descriptor.spec.toolsManager.alternatives.javaEngine }
        logger.debug("AlternativesToolsManagerStrategy.configure()", "Configurando Java ${toolJava}")
        if(!toolJava) {
            logger.warn("AlternativesToolsManagerStrategy.configure()", "No se ha encontrado la versin de Java en la configuracin. Se utilizar la versin 17 por defecto.")
            toolJava = "17"
        }
        setJavaVersion(toolJava)
        logger.info("AlternativesToolsManagerStrategy.configure()", "Configuracin de Java ${toolJava} completada.")
    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/strategies/AsdfToolsManagerStrategy.groovy">
package es.giss.framework.core.tools.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.IToolsStrategy
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.pipeline.PipelineDefinition

import java.nio.file.Path
import java.nio.file.Paths

@PipelineComponent(name = 'AsdfToolsStrategy', priority = ConfigurationPriority.EXCLUDED)
class AsdfToolsManagerStrategy extends Steps implements IToolsStrategy {

    private static final String TOOLS_PLUGINS_SCRIPT_SH = 'tools_install_plugins.sh'
    private static final String TOOLS_VERSIONS_SCRIPT_SH = 'tools_install.sh'

    private IWorkspaceTool workspace

    private Path defaultToolsFilesDir
    private Map<String, String> toolVersions
    private Map<String, String> toolPlugins
    private Boolean forceClearCache
    private String httpsProxy

    AsdfToolsManagerStrategy(IWorkspaceTool workspace, IToolsManager toolsManager) {
        this.workspace = workspace
        toolsManager.registerToolStrategy(this)
        toolVersions = [:]
        toolPlugins = [:]
    }


    @Override
    void setToolVersion(String tool, String version) {
        execute("""
            asdf install $tool $version
            asdf global $tool $version
        """, [])
    }

    @Override
    boolean filterTool(String tool) {
        return toolPlugins.containsKey(tool)
    }

    @NonCPS
    @Override
    int priority() {
        return 1
    }

    @Override
    Integer executeWithStatus(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStatus: true)
    }

    @Override
    String execute(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStdout: true)?.trim()
    }

    void writeToolVersionsFile(Map<String, String> tools, Path toDir = defaultToolsFilesDir) {
        logger.debug("Tool versions to write:")
        logger.printPrettyLog(LogLevel.DEBUG, tools)
        String toolVersionsContent = tools.collect { k, v -> "${k} ${v}" }.join('\n')
        workspace.writeFile(Paths.get(toDir as String, '.tool-versions') as String, toolVersionsContent)
        logger.debug("Tool versions file written to ${toDir}/.tool-versions")

        logger.executeWhenDebug {
            steps.sh "cat ${toDir}/.tool-versions"
            logger.debug("Tool versions file content:")
            logger.printPrettyLog(LogLevel.DEBUG, workspace.readFile("${toDir}/.tool-versions"))
        }
    }

    void writePluginFile(Map<String, String> plugins, Path toDir = defaultToolsFilesDir) {
        logger.debug("Missing asdf plugins: ${plugins.keySet().join(', ')}")
        logger.printPrettyLog(LogLevel.DEBUG, plugins)
        String toolsPlugins = plugins.collect { k, v -> "${k} ${v}" }.join('\n')
        if (toolsPlugins.isEmpty()) {
            logger.warn("No plugins to install")
            return
        }
        workspace.writeFile(Paths.get(toDir as String, '.tool-plugins') as String, toolsPlugins)
    }


    void updatePlugins(Map<String, String> plugins, String asdfDir, Path toDir = defaultToolsFilesDir) {
        logger.debug("Plugins to install: ${plugins}")
        logger.printPrettyLog(LogLevel.DEBUG, plugins)
        writePluginFile(plugins, toDir)
        String toolPluginsFilePath = "${toDir}/.tool-plugins"
        String result = execute("${asdfDir}/${TOOLS_PLUGINS_SCRIPT_SH} ${httpsProxy} ${toolPluginsFilePath}", [:])
        logger.debug("Result Update asdf plugins: ${result}")

    }


    void installTools(String asdfDir, Path fromDir = defaultToolsFilesDir) {
        String toolsVersion = "${fromDir}/.tool-versions"
        execute("${asdfDir}/${TOOLS_VERSIONS_SCRIPT_SH} ${httpsProxy} ${toolsVersion}", [:])
        logger.executeWhenDebug {
            steps.sh "cd ${fromDir} && asdf current"
        }
        logger.debug("Tools installed")
    }

    def copyResourcesToFile(String targetPath) {

        // Verifica si el archivo ya existe
        if (workspace.fileExists("${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}") && workspace.fileExists("${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}")) {
            logger.debug('AsdfToolManagerStrategy.copyResourcesToFile()',"El archivo ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH} ya existe, no se realizar ninguna accin.")
            return
        }

        String resourceInstallPluginScriptPath = "scripts/${TOOLS_PLUGINS_SCRIPT_SH}"
        // Obtn el recurso como una cadena
        logger.debug('AsdfToolManagerStrategy.copyResourcesToFile()',"Obteniendo recurso $resourceInstallPluginScriptPath")
        String resourceInstallPluginContent = steps.libraryResource(resourceInstallPluginScriptPath)
        if(resourceInstallPluginContent == null) {
            logger.error('AsdfToolManagerStrategy.copyResourcesToFile()',"Error al obtener el recurso $resourceInstallPluginScriptPath")
            steps.error("Error al obtener el recurso $resourceInstallPluginScriptPath")
        }

        logger.debug('AsdfToolManagerStrategy.copyResourcesToFile()',"Recurso obtenido correctamente con contenido ${resourceInstallPluginContent}")
        // Escribe el contenido del recurso en el archivo de destino
        workspace.createDirectoriesIfNotExist([Path.of(targetPath).getParent().toString()])
        logger.debug("Copiando recurso $resourceInstallPluginScriptPath a ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}")
        workspace.writeFile("${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}", resourceInstallPluginContent)
        steps.sh(script: "chmod +x ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH} && dos2unix ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}".toString())

        String resourceInstallToolsScriptPath = "scripts/${TOOLS_VERSIONS_SCRIPT_SH}"
        String resourceInstallToolsContent = steps.libraryResource(resourceInstallToolsScriptPath)

        logger.debug("Copiando recurso $resourceInstallToolsScriptPath a ${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}")
        workspace.writeFile("${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}", resourceInstallToolsContent)
        steps.sh(script: "chmod +x ${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH} && dos2unix ${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}")
    }

    void deleteToolVersionsFile(Path file) {
        steps.sh(script: "rm -f ${file}/.tool-plugins")
    }

    private void clearCacheIfConfigured() {
        if (forceClearCache) {
            logger.warn 'Force removing asdf cache directory. This action may take a while...'
            execute('rm -fr ${ASDF_DATA_DIR:-$HOME/.asdf}/*', [:])
        }
    }

    @Override
    void configure(IPipelineContext context) {
        defaultToolsFilesDir = Path.of(steps.env.WORKSPACE)
        logger.debug("Configure Default tools files directory: ${defaultToolsFilesDir.toString()}")

        String asdfDataDir = '/opt/cache/tools/.asdf-data'
        Store<PipelineDefinition> pipelineStorage = context.getStore(PipelineDefinition.class)
        pipelineStorage.select { PipelineDefinition descriptor ->
            toolPlugins = descriptor.spec.toolsManager.asdf.plugins
            toolVersions = descriptor.spec.toolsManager.asdf.tools
            defaultToolsFilesDir = Path.of(descriptor.spec.toolsManager.asdf.defaultToolVersionsFileDir)
            httpsProxy = descriptor.spec.toolsManager.asdf.proxySettings.httpsProxy
            asdfDataDir = descriptor.spec.toolsManager.asdf.defaultDataDir?.toString()
        }

        logger.debug("Installing plugins and tool versions for tools manager... with proxy ${httpsProxy}")
        clearCacheIfConfigured()

        if(!workspace.directoryExists(asdfDataDir)) {
            workspace.createDirectoriesIfNotExist([asdfDataDir,])
        }

        copyResourcesToFile(asdfDataDir)//

        logger.debug("Tool plugins: ${toolPlugins}")

        Boolean asdfDirExist = workspace.directoryExists('$ASDF_DIR')
        if (toolPlugins || !asdfDirExist) {
            updatePlugins(toolPlugins, asdfDataDir)
        }

        if (toolVersions) {
            writeToolVersionsFile(toolVersions)
            installTools(asdfDataDir)
        }
        deleteToolVersionsFile(defaultToolsFilesDir)

    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/strategies/CustomScriptToolsManagerStrategy.groovy">
package es.giss.framework.core.tools.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.IToolsStrategy
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent

import java.nio.file.Path

@PipelineComponent(name = 'CustomScriptToolsManagerStrategy', priority = ConfigurationPriority.EXCLUDED)
class CustomScriptToolsManagerStrategy extends Steps implements IToolsStrategy {

    /**
     * Nombre del script que realiza la instalacin del customscript y lo pone disponible para poder ser usado
     */
    private static final String CUSTOMSCRIPT_INSTALL_TOOL_SH = 'customscript_install_tool.sh'
    /**
     * Nombre del script que realiza la instalacin de las herramientas
     */
    private static final String CUSTOMSCRIPT_NAME_SH = 'customscript_tool.sh'
    private static final String CUSTOMSCRIPT_DATA_DIR = '/opt/cache/tools/.customscripts-data'

    private IWorkspaceTool workspace

    private Path defaultToolsFilesDir
    private Map<String, String> tools
    private Boolean forceClearCache
    private String httpsProxy

    // TODO
    private String credentialsId
    private String nexusUrl

    CustomScriptToolsManagerStrategy(IWorkspaceTool workspace, IToolsManager toolsManager) {
        this.workspace = workspace
        toolsManager.registerToolStrategy(this)
    }


    @Override
    void setToolVersion(String tool, String version) {
      steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASSWORD')]) {
            steps.withEnv(["NEXUS_HOST=${nexusUrl}"]) {
                String prueba = execute("""
                ${CUSTOMSCRIPT_NAME_SH} $tool $version
            """, [])
                logger.debug("log setTooolVersion $prueba")
            }
        }

    }

    @Override
    boolean filterTool(String tool) {
        return tools.containsKey(tool)
    }

    @NonCPS
    @Override
    int priority() {
        return 3
    }

    @Override
    Integer executeWithStatus(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStatus: true)
    }

    @Override
    String execute(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStdout: true)?.trim()
    }

    private void clearCacheIfConfigured() {
        if (forceClearCache) {
            logger.warn 'Force removing custom script cache directory. This action may take a while...'
            execute('rm -fr ${CUSTOMSCRIPT_DATA_DIR}/*', [:])
        }
    }

    def copyResourcesToFile(String targetPath) {
        logger.debug("[CustomScriptToolsManagerStrategy.copyResourcesToFile] targetPath con valor ${targetPath}")
        // Verifica si el archivo ya existe
        if (workspace.fileExists("${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH}")) {
            logger.debug("El archivo ${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH} ya existe, no se realizar ninguna accin.")
            return
        }

        String resourceInstallPluginScriptPath = "scripts/${CUSTOMSCRIPT_INSTALL_TOOL_SH}"
        // Obtn el recurso como una cadena
        String resourceInstallPluginContent = steps.libraryResource(resourceInstallPluginScriptPath)
        logger.debug("[CustomScriptToolsManagerStrategy.copyResourcesToFile] resourceInstallPluginContent ${resourceInstallPluginContent}")
        // Escribe el contenido del recurso en el archivo de destino
        workspace.createDirectoriesIfNotExist([Path.of(targetPath).toString()])
        logger.debug("Copiando recurso $resourceInstallPluginScriptPath a ${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH}")
        workspace.writeFile("${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH}", resourceInstallPluginContent)
        steps.sh(script: "chmod +x ${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH} && dos2unix ${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH}".toString())
    }

    /**
     * Realiza la descarga del script para que est disponible
     */
    private void installCustomscriptToolManager(IPipelineContext context) {
        String targetPath = steps.env.CUSTOMSCRIPT_HOME_DIR

        copyResourcesToFile(targetPath)

        logger.debug("Descarga del script de nexus ${nexusUrl} con credenciales ${credentialsId}")
        steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASSWORD')]) {
            steps.withEnv(["NEXUS_HOST=${nexusUrl}"]) {
                execute("${targetPath}/${CUSTOMSCRIPT_INSTALL_TOOL_SH} ${httpsProxy}", [:])
            }
        }
    }

    @Override
    void configure(IPipelineContext context) {

        Store<PipelineDefinition> pipelineStorage = context.getStore(PipelineDefinition.class)

        // TODO Revisar para coger la informacin de un objeto es.giss.framework.core.vo.project.ArtifactsRepository
        credentialsId = pipelineStorage.select { PipelineDefinition definition-> definition.spec.environmentVars.find { it.key == "NEXUS_CREDENTIALSID" }?.value }
        nexusUrl = pipelineStorage.select { PipelineDefinition definition-> definition.spec.environmentVars.find { it.key == "NEXUS_URL" }?.value }

        pipelineStorage.select { PipelineDefinition descriptor ->
            defaultToolsFilesDir = Path.of(descriptor.spec.toolsManager.customScript.defaultToolVersionsFileDir)
            httpsProxy = descriptor.spec.toolsManager.customScript.proxySettings.httpsProxy
            tools = descriptor.spec.toolsManager.customScript.tools
        }

        logger.debug("Installing customscript versions for tools manager... with proxy ${httpsProxy}")
        logger.debug("Installing customscript versions for tools manager... with tools ${tools}")
        clearCacheIfConfigured()

        installCustomscriptToolManager(context)
    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/strategies/GraalVmToolsManagerStrategy.groovy">
package es.giss.framework.core.tools.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.IToolsStrategy
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.pipeline.GraalVmToolsDescriptor
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.pipeline.ToolsManagerDescriptor

import java.nio.file.Path

@PipelineComponent(name = 'GraalVmToolsManagerStrategy', priority = ConfigurationPriority.EXCLUDED)
class GraalVmToolsManagerStrategy extends Steps implements IToolsStrategy {

    private static final String GRAALVM_SET_CONFIG_SCRIPT_SH = 'graalvm_set_config.sh'
    private static final String GRAALVM_INSTALL_PLUGINS_SCRIPT_SH = 'graalvm_install_plugins.sh'

    private IWorkspaceTool workspace
    private GraalVmToolsDescriptor graalVmTools
    private String graalVmVersion
    private String asdfDefaultDataDir
    private String httpsProxy

    GraalVmToolsManagerStrategy(IWorkspaceTool workspace, IToolsManager toolsManager) {
        this.workspace = workspace
        toolsManager.registerToolStrategy(this)
        graalVmTools = new GraalVmToolsDescriptor()
    }

    @Override
    void configure(IPipelineContext context) {

        Store<PipelineDefinition> pipelineStorage = context.getStore(PipelineDefinition.class)
        pipelineStorage.select { PipelineDefinition descriptor ->
            ToolsManagerDescriptor toolsManager = descriptor.spec.toolsManager
            this.graalVmTools = toolsManager.graalVmTools
            this.asdfDefaultDataDir = toolsManager.asdf.defaultDataDir
            this.httpsProxy = toolsManager.customScript.proxySettings.httpsProxy
        }

        logger.debug('GraalVmToolsManagerStrategy.configure', "Installing GraalVm: ${this.graalVmTools.javaEngine}")
        logger.debug('GraalVmToolsManagerStrategy.configure', "Installing plugins: ${this.graalVmTools.plugins}")
        if(!this.graalVmTools.plugins || !this.graalVmTools.javaEngine) {
            logger.debug('GraalVmToolsManagerStrategy.configure', "No properties found for GraalVm, skipping installation")
            return
        }
        installCustomScriptToolManager(this.graalVmTools.plugins, asdfDefaultDataDir, this.graalVmTools.javaEngine)
        logger.debug('GraalVmToolsManagerStrategy.configure', "GraalVm is ready")
    }

    private copyResourcesToFile(String targetPath) {
        List<String> toInstall = []

        logger.debug('GraalVmToolsManagerStrategy.copyResourcesToFile', "targetPath con valor ${targetPath}")
        // Verifica si el archivo ya existe
        if (workspace.fileExists("${targetPath}/${GRAALVM_INSTALL_PLUGINS_SCRIPT_SH}")) {
            logger.debug('GraalVmToolsManagerStrategy.copyResourcesToFile', "El archivo ${targetPath}/${GRAALVM_INSTALL_PLUGINS_SCRIPT_SH} ya existe, no se realizar ninguna accin.")
        } else {
            toInstall.add(GRAALVM_INSTALL_PLUGINS_SCRIPT_SH)
        }
        if (workspace.fileExists("${targetPath}/${GRAALVM_SET_CONFIG_SCRIPT_SH}")) {
            logger.debug('GraalVmToolsManagerStrategy.copyResourcesToFile', "El archivo ${targetPath}/${GRAALVM_SET_CONFIG_SCRIPT_SH} ya existe, no se realizar ninguna accin.")
        } else {
            toInstall.add(GRAALVM_SET_CONFIG_SCRIPT_SH)
        }

        toInstall.each { script ->
            String resourceInstallPluginScriptPath = "scripts/${script}"
            // Obtn el recurso como una cadena
            String resourceInstallPluginContent = steps.libraryResource(resourceInstallPluginScriptPath)
            logger.debug('GraalVmToolsManagerStrategy.copyResourcesToFile', "resourceInstallPluginContent ${resourceInstallPluginContent}")
            // Escribe el contenido del recurso en el archivo de destino
            logger.debug('GraalVmToolsManagerStrategy.copyResourcesToFile', "Copiando recurso $resourceInstallPluginScriptPath a ${targetPath}/${script}")
            workspace.createDirectoriesIfNotExist([Path.of(targetPath).toString()])
            logger.debug('GraalVmToolsManagerStrategy.copyResourcesToFile', "Copiando recurso $resourceInstallPluginScriptPath a ${targetPath}/${script}")
            workspace.writeFile("${targetPath}/${script}", resourceInstallPluginContent)
            steps.sh(script: "chmod +x ${targetPath}/${script} && dos2unix ${targetPath}/${script}".toString())
        }
    }

    private void installCustomScriptToolManager(Set<String> plugins, String asdfDefaultDataDir, String graalVmVersion) {
//        String targetPath = steps.env.GRAALVMSCRIPT_DATA_DIR
        String targetPath = '/opt/cache/tools/.graalvm'

        copyResourcesToFile(targetPath)

        String pluginsParam = plugins.join(' ')

        logger.debug('GraalVmToolsManagerStrategy.installCustomScriptToolManager', 'Configuracion de GraalVm')
        execute("${targetPath}/${GRAALVM_SET_CONFIG_SCRIPT_SH} ${httpsProxy} ${asdfDefaultDataDir} ${graalVmVersion}", [:])
        logger.debug('GraalVmToolsManagerStrategy.installCustomScriptToolManager', "Instalacion de plugins de GraalVm: $pluginsParam")
        execute("${targetPath}/${GRAALVM_INSTALL_PLUGINS_SCRIPT_SH} ${httpsProxy} ${pluginsParam}", [:])


    }

    @Override
    Integer executeWithStatus(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStdout: true)?.trim()
    }

    @Override
    String execute(String command, Object options) {
        return steps.sh(script: command?.trim(), returnStatus: true)
    }

    @Override
    void setToolVersion(String tool, String version) {
        logger.debug('GraalVmToolsManagerStrategy.setToolVersion', 'Funcion no soportada por GraalVm')
    }

    @Override
    boolean filterTool(String tool) {
        return graalVmTools.plugins?.contains(tool)
    }

    @NonCPS
    @Override
    int priority() {
        return 4
    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/GitTool.groovy">
package es.giss.framework.core.tools

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.vo.observability.TelemetryMap
import es.giss.framework.core.vo.project.SourceRepository
import es.giss.framework.core.vo.release.ConventionalCommit
import es.giss.framework.core.vo.release.GitCommit
import es.giss.framework.core.vo.release.GitCommitContext

@PipelineComponent
class GitTool extends Steps implements IGitTool {

    SourceRepository defaultJobRepository

    @Override
    boolean cloneInAgent() {
        SourceRepository defaultSourceRepository = getDefaultSourceRepository()
        if (defaultSourceRepository == null) {
            steps.error("Default source repository is null")
            return false
        } else {
            return cloneInAgent(defaultSourceRepository.url, defaultSourceRepository.branch, defaultSourceRepository.credentialsId)
        }

    }

    @Override
    boolean cloneInAgent(String url,
                         String reference,
                         String credentialsId = '',
                         String cloneDir = '.',
                         Boolean shallowClone = false) {
        String repositoryUrl = (url ==~ /http.*/) ? getGitRepoUrlWithBasicAuth(url, credentialsId) : url

        steps.withEnv(["REPO_URL=${repositoryUrl}"]) {
            logger.info "Clone repository ${url} and reference ${reference}"

            TelemetryEvent telemetryEvent = new TelemetryEvent(description: 'Clone Git Repository', payload: new TelemetryMap(url: url, reference: reference, sourceRepositoryUrl: url))
            pipeline.dispatch(telemetryEvent)
            if (shallowClone && isCommitSha(reference)) {
                return steps.sh(script: """
                    set +x
                    git clone --depth 1 \$REPO_URL ${cloneDir}
                    cd ${cloneDir}
                    git fetch --depth=1 origin ${reference}
                    git checkout ${reference}
                """, returnStatus: true)
            } else if (shallowClone) {
                return steps.sh(script: """
                    set +x
                    git clone --depth 1 --branch ${reference} --single-branch \$REPO_URL ${cloneDir}
                    cd ${cloneDir}
                """, returnStatus: true)
            } else {
                return steps.sh(script: """
                    set +x
                    git clone \$REPO_URL ${cloneDir}
                    cd ${cloneDir}
                    git checkout ${reference}
                """, returnStatus: true)
            }
        }
        return true
    }

    private Boolean isCommitSha(String reference) {
        reference ==~ /(?i)^[0-9a-f]{40}$/
    }

    @Override
    void setUserDetails(Boolean override, String directory = '.') {
        Integer gitUserKeysCount = steps.sh(returnStdout: true,
                script: """
                    cd ${directory}
                    git config --local --name-only --get-regexp "user.(name|email)" || true
                """).tokenize()?.size()

        if (gitUserKeysCount != 2 || override) {
            steps.sh """
                cd ${directory}
                git config --local user.name "${this.user}"
                git config --local user.email "${this.email}"
            """
        }
    }

    @Override
    String getGitRemoteUrl(String name = 'origin') {
        def remoteUrl = steps.sh(returnStdout: true, script: "git remote get-url ${name}")?.trim()
        return remoteUrl
    }


    private String getGitRepoUrlWithBasicAuth(final String url, String credentialsId) {
        steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'USR', passwordVariable: 'PSW')]) {
            // Encode PASS and build basic authentication in format USR:PASS
            String basicAuth = "${steps.env.USR}:${URLEncoder.encode(steps.env.PSW, 'UTF-8')}@"

            // Convert repo url to https://<username>:<password>@<server>/<repo>
            String fullRepoUrl = url.replaceAll(/(http[s]?:\/\/)/, "\$1${basicAuth}")
            return fullRepoUrl
        }
    }

    @Override
    void fetchTags() {
        String credentialsId = defaultJobRepository ? defaultJobRepository?.credentialsId : ''
        execute('git fetch --tags', [credentialsId: credentialsId])
    }

    @Override
    Boolean createTag(String tag) {
        try {
            String credentialsId = defaultJobRepository ? defaultJobRepository?.credentialsId : ''
            // Primero, crea el tag localmente
            execute("git tag ${tag}", [credentialsId: credentialsId])
            logger.debug("Tag '${tag}' created locally")

            // Luego, empuja el tag al repositorio remoto
            execute("git push origin ${tag}", [credentialsId: credentialsId])
            logger.debug("Tag '${tag}' pushed to remote repository")
            Boolean tagExists = tagExists(tag)

            if (tagExists) {
                logger.info("Tag '${tag}' created successfully")
                pipeline.dispatch(new TelemetryEvent(payload: new TelemetryMap(tag: tag, sourceRepositoryUrl: defaultJobRepository?.url)))
            } else {
                logger.error("Tag '${tag}' was not created")
            }
            return tagExists

        } catch (Exception e) {
            logger.warn("Error creating remote tag '${tag}': ${e.message}")
            return Boolean.FALSE
        }
    }

    @Override
    Boolean tagExists(String tag) {
        try {
            // Ejecuta el comando para listar todos los tags remotos
            String output = execute("git ls-remote --tags origin ${tag}", [credentialsId: defaultJobRepository ? defaultJobRepository?.credentialsId : ''])

            // Busca el tag en la salida del comando
            if (output.contains("refs/tags/${tag}")) {
                logger.debug("Tag '${tag}' exists")
                return Boolean.TRUE
            } else {
                logger.debug("Tag '${tag}' does not exist")
                return Boolean.FALSE
            }
        } catch (Exception e) {
            logger.error("Error checking tag '${tag}': ${e.message}")
            return Boolean.FALSE
        }
    }

    @Override
    Boolean branchExists(String branchName) {
        String result = execute("git ls-remote --heads origin refs/heads/${branchName}",
                [credentialsId: defaultJobRepository ? defaultJobRepository?.credentialsId : ''])

        Boolean existBranch = result.contains("refs/heads/${branchName}")
        logger.debug("BranchType '${branchName}' ${existBranch ? 'exists' : 'does not exist'}")
        return existBranch
    }

    @Override
    List<String> getAllTags(Boolean fromHead = false) {
        fetchTags()
        return steps.sh(returnStdout: true,
                script: "git tag --sort=-creatordate ${fromHead ? '--merged' : ''}").tokenize('\n')
    }

    @Override
    List<String> getAllTagsMaster() {
        fetchTags()
        return steps.sh(returnStdout: true,
                script: "git tag | grep -e '^[0-9]*.[0-9]*.[0-9]*\$'").tokenize('\n')
    }

    @Override
    String getTagFromCurrentHead(String tag) {
        fetchTags()
        return steps.sh(returnStdout: true, script: 'git tag -l ${tag} --points-at HEAD || false')
    }

    @Override
    String getLatestTagFromCurrentHead(String branch) {
        fetchTags()
//        return steps.sh(returnStdout: true, script: 'git describe --abbrev=0 --tags || true').trim()
        return steps.sh(returnStdout: true, script: "git tag --merged ${branch} | sort -V | tail -n 1|| true")?.trim()
    }

    //Busca el ltimo tag que cumpla con el patron -SNAPSHOT en integracin
    @Override
    String getLatestTagIntegracion(String branch) {
        fetchTags()
        return steps.sh(returnStdout: true, script: "git tag --merged ${branch} | grep -e \'-SNAPSHOT\$\' | sort -V | tail -n 1 || true")?.trim()
    }

    //Busca el ltimo tag que cumple un patrn
    @Override
    String getLatestTagPatternFromCurrentHead(String pattern) {
        fetchTags()
        return steps.sh(returnStdout: true,
                script: 'git describe --abbrev=0 --tags --match ${pattern} --candidates=1 || true')?.trim()
    }

    @Override
    String getLatestTagRCFromCurrentHead() {
        fetchTags()
        return steps.sh(returnStdout: true, script: 'git describe --abbrev=0 --tags --match "*-RC" || true')?.trim()
    }

    @Override
    String getLatestTagReleaseFromCurrentHead() {
        fetchTags()
        return steps.sh(returnStdout: true, script: 'git describe --abbrev=0 --tags --match "*-RELEASE" || true')?.trim()
    }

    @Override
    String getGitBranch() {
        return steps.sh(returnStdout: true, script: 'git branch --show-current')?.trim()
    }

    @Override
    String describeTagWithGitSuffix(String tag) {
        return steps.sh(returnStdout: true, script: "git describe --tags --match=${tag}")?.trim()
    }

    @Override
    Boolean currentHeadIsTagged() {
        fetchTags()
        steps.sh(returnStatus: true, script: 'git describe --tags --exact-match') == 0
    }

    //Este comando lista los commits que estn en la rama actual, empezando desde el actual (HEAD).
    // El -n 1 indica que solo quieres ver el primer commit de la lista, que es el commit actual.
    @Override
    String getCurrentHeadSha() {
        return steps.sh(returnStdout: true, script: 'git rev-list HEAD -n 1')?.trim()
    }

    @Override
    String getFirstCommitSha() {
        return steps.sh(returnStdout: true, script: 'git rev-list --reverse HEAD | head -1')?.trim()
    }


    @Override
    String getCommitId(String reference = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git rev-parse ${reference}")?.trim()
    }

    @Override
    String getCommitMessage(String reference = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git log -1 --pretty=format:'%B' ${reference}")?.trim()
    }

    @Override
    String getCommitEmail(String reference = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git log -1 --pretty=format:'%ae' ${reference}")?.trim()
    }

    @Override
    List<String> getChangedFilesBetweenCommits(String fromRef = null, String toRef = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git diff --name-only ${fromRef?.trim()} ${toRef?.trim()}").tokenize()
    }

    @Override
    Boolean isWorkingDirectoryUnmodified() {
        return steps.sh(returnStdout: true, script: 'git status --porcelain')?.trim() == ''
    }

    @Override
    String getBranchFromMerge(String hash){
        return steps.sh(returnStdout: true, script: "git branch -a --contains \$(git name-rev --tags --name-only \$(git show -s ${hash} --format=%P | cut -d\' \' -f2)) | tail -1")?.trim()
    }


    List<GitCommit> fetchLastCommits(int count) {
        String gitLogOutput = steps.sh(returnStdout: true, script: """git log -${count} --pretty=format:"COMMIT_START%n%H%n%an%n%ae%n%ad%n%D%nMESSAGE_START%n%B%nCOMMIT_END" --date=iso""")?.trim()
        if (!gitLogOutput) {
            steps.error("[GitTool.getLastCommits] Error getting info from last commits")
        }
        logger.debug("Git log output: ${gitLogOutput}")

        def commitStrings = gitLogOutput.split('COMMIT_START')

        List<GitCommit> commitList = commitStrings.collect { commitString ->
            if (commitString?.trim()) {
                try {
                    return GitCommit.fromOutput(commitString?.trim())
                } catch (IllegalArgumentException e) {
                    steps.error("[GitTool.getLastCommits] Error parsing commit info: ${e.message}")
                }
            }
        }.findAll { it != null }

        logger.printPrettyLog(LogLevel.DEBUG, "[GitTool.getLastCommits] :", commitList)
        return commitList
    }

    private boolean isTag(String current) {
        return current ==~ /\d+\.\d+\.\d+(-[A-Za-z0-9]+)?/
    }

    private boolean isTagPro(String current) {
        return current ==~ /\d+\.\d+\.\d+$/
    }



    String getGitInfo() {
        return steps.sh(returnStdout: true, script: '''
            git fetch --tags && \
            current_branch=$(git branch -a --contains HEAD | grep -v "detached" | grep "*" > /dev/null && git branch --show-current || git branch -a --contains HEAD | grep "release/" | head -n1 | sed 's/^[ *]*//' | sed 's/remotes\\/origin\\///') && \
            if [ "$current_branch" = "master" ] || [ "$current_branch" = "main" ]; then \
                current_tag=$(git tag --sort=-creatordate | grep -E '^[0-9]+\\.[0-9]+\\.[0-9]+(-SNAPSHOT.*|-RC|-RELEASE)?$' | head -n 1); \
            elif [ "$current_branch" = "develop" ]; then \
                current_tag=$(git describe --tags --abbrev=0); \
            fi \
            if [ -z "$current_tag" ]; then \
                current_tag=$(git tag --merged ${current_branch} --sort=-creatordate | head -n1); \
            fi && \
            base_version=$(echo $current_tag | sed -E 's/(-SNAPSHOT.*|-RC.*|-RELEASE.*|$)//' ) && \
            nearby_tags=$(git tag --sort=-creatordate | grep "^${base_version}" 2>/dev/null || echo ""); \
            echo -e "Rama actual: ${current_branch}\nTag actual: ${current_tag}\nTags relacionados: $(echo "$nearby_tags" | tr '\n' ' ')\n$(git show --pretty=format:"Hash: %H%nHash corto: %h%nAutor: %an%nEmail: %ae%nFecha: %ad%nRefs: %d%nAsunto: %s%nMensaje:%n%b" --date=format:'%Y-%m-%d %H:%M:%S' HEAD)"            
    ''')?.trim()
    }

    @Override
    GitCommitContext getGitCurrentBranchInfo() {

        String gitInfo = getGitInfo()
        String branchName = steps.env.BRANCH_NAME
        String pipelineTag = branchName ==~ /\d+\.\d+\.\d+.*/ ? branchName : ''
        String jobBaseName = steps.env.JOB_BASE_NAME?: ''

        if(pipelineTag){
            branchName = steps.sh(
                    returnStdout: true,
                    script: "git branch -r --contains ${pipelineTag} | { [[ \"${pipelineTag}\" =~ RC|RELEASE ]] && grep \"release\" || grep \"master\";  } | head -n 1")?.trim()?.replaceAll('.*origin/([^,]+).*', '$1')
        }

        if(gitInfo == null || gitInfo.isEmpty()){
            steps.error("[GitTool.getGitCurrentBranchInfo()] Error getting git info from currentTag HEAD")
            return null
        }

        logger.debug('GitTool.getGitCurrentBranchInfo()', "Git Info: ${gitInfo}")

        // Procesar la informacin
        def infoMap = [:]
        def currentMessage = []
        boolean isMessage = false
        String currentTag = pipelineTag
        Set<String> associatedTags = [] as Set
        String currentBranch = branchName


        gitInfo.readLines().each { line ->
            if (line.startsWith("Rama actual:") && currentBranch.isEmpty()) {
                currentBranch = line.split(":", 2)[1]?.trim()
            } else if (line.startsWith("Tag actual:") && currentTag.isEmpty()) {
                String tag = line.split(":", 2)[1]?.trim()
                if (tag != "ninguno") {
                    currentTag = tag
                }
            } else if (line.startsWith("Tags relacionados:")) {
                String tags = line.split(":", 2)[1]?.trim()
                if (tags) {
                    associatedTags.addAll(tags.split("\\s+").toList())
                }
                associatedTags.add(currentTag)
            } else if (line.startsWith("Mensaje:")) {
                isMessage = true
            } else if (isMessage) {
                currentMessage << line
            } else if (line.contains(":")) {
                def (key, value) = line.split(":", 2)
                infoMap[key?.trim()] = value?.trim()
            }
        }

        // Si no hay tag actual, usar la rama como currentTag
        if (currentTag.isEmpty()) {
            currentTag = currentBranch
        }

        // Si hay refs, procesar tags y branch adicionales
        if (infoMap.Refs) {
            String refs = infoMap.Refs.replaceAll('[()]', '')?.trim()
            associatedTags.addAll(getTagsFromLine(refs))

            if (currentBranch?.isEmpty()) {
                currentBranch = refs.split(',')
                        .findAll { it.contains("release/") || it.contains("hotfix/") || it.contains('master') || it.contains('main') }
                        .collect { it?.trim().replaceAll('.*origin/([^,]+).*', '$1') }?.find() ?: ''
            }
        }
        if(currentBranch == 'develop' || currentBranch == 'development' && !currentTag.contains('-SNAPSHOT')){
            currentTag = getLatestTagIntegracion(currentBranch) //associatedTags.find { it.endsWith('-SNAPSHOT') }
        }

        logger.debug('GitTool.getGitCurrentBranchInfo()', "Current: ${currentTag}, Branch: ${currentBranch}, Tags: ${associatedTags}")

        String mergeOriginBranch = ""
        if(currentBranch == 'master' || currentBranch == 'main'){
            mergeOriginBranch = getBranchFromMerge(infoMap.Hash as String)
        }

        return new GitCommitContext(
                currentTag: currentTag,
                jobBaseName: jobBaseName,
                hash: infoMap.Hash,
                shortHash: infoMap['Hash corto'],
                author: infoMap.Autor,
                email: infoMap.Email,
                date: infoMap.Fecha,
                subject: infoMap.Asunto,
                tags: associatedTags,
                branch: currentBranch,
                mergeOriginBranch: mergeOriginBranch,
                changeType: ConventionalCommit.fromMessage(infoMap.Asunto),
                message: currentMessage.join("\n")?.trim()
        )
    }


    private List<String> getTagsFromLine(String refs) {
        refs.split(',')
                .findAll { it.contains('tag: ') }
                .collect { it?.trim().replaceAll('.*tag: ([^,]+).*', '$1') }
    }

    /**
     * Used to set the current branch of a repository
     *
     * @param branch BranchType name that will be set
     * @return True if branch was switched successfully, False in the other case
     */
    @Override
    Boolean switchToBranch(String branch) {
        int result = steps.sh(script: "git checkout ${branch}", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    /**
     * Used to update index of repository and add all changes
     *
     * @return True if commit was created successfully, False in the other case
     */
    @Override
    Boolean addChanges() {
        int result = steps.sh(script: 'git add -A .', returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    /**
     * Used to update index of repository and add all changes
     * @param fileList is a String formatted list of files to add to stash
     * @return True if commit was created successfully, False in the other case
     */
    @Override
    Boolean addFiles(List<String> fileList) {
        int result = steps.sh(script: "git add ${fileList.join(' ')}", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }
    /**
     * Used to create a commit
     *
     * @param msg Message used to create the commit
     * @return True if index was updated successfully, False in the other case
     */
    @Override
    Boolean createCommit(String msg) {
        int result = steps.sh(script: "git commit --no-verify -m '${msg}'", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    /**
     * Push the changes to remote repository using the current branch
     *
     * @param force Push the changes ignoring warnings messages
     * @return True if push successfully, False in the other case
     */
    @Override
    Boolean push(boolean force = false) {
        int result = steps.sh(script: "git push --no-verify origin \$(git branch --show-current) ${force ? '--force' : ''}", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    @Override
    Integer executeWithStatus(String taskName, options) {
        assert options instanceof Map: "Options in execute method from GitTool must be a Map"
        String repoUrl = getGitRemoteUrl()
        String repositoryUrlFinal = repoUrl

        if (!repoUrl.matches(/^https:\/\/.*:.*@.*$/) && options.containsKey('credentialsId') && options.credentialsId) {
            repositoryUrlFinal = getGitRepoUrlWithBasicAuth(repoUrl, options.credentialsId)
        }

        // sh +x for avoiding printing command arguments in console
        steps.withEnv(["REPO_URL=${repositoryUrlFinal}"]) {
            steps.sh(returnStdout: true, script: 'set +x; git remote set-url origin "$REPO_URL"')
        }
        return steps.sh(script: taskName, returnStatus: true)
    }

    @Override
    String execute(String taskName, options) {
        assert options instanceof Map: "Options in execute method from GitTool must be a Map"
        String repoUrl = getGitRemoteUrl()
        String repositoryUrlFinal = repoUrl

        if (!repoUrl.matches(/^https:\/\/.*:.*@.*$/) && options.containsKey('credentialsId') && options.credentialsId) {
            repositoryUrlFinal = getGitRepoUrlWithBasicAuth(repoUrl, options.credentialsId)
        }

        // sh +x for avoiding printing command arguments in console
        steps.withEnv(["REPO_URL=${repositoryUrlFinal}"]) {
            steps.sh(returnStdout: true, script: 'set +x; git remote set-url origin "$REPO_URL"')
        }
        return steps.sh(returnStdout: true, script: taskName)?.trim()
    }

    SourceRepository getDefaultSourceRepository() {
        try {
            def userRemoteConfigs = steps.scm?.getUserRemoteConfigs()
            if (userRemoteConfigs == null || userRemoteConfigs.isEmpty()) {
                logger.warn("User remote configs cannot be null or empty in jenkins scm object")
                return null
            }
            String url = userRemoteConfigs[0]?.getUrl()
            if (url == null) {
                steps.error("URL cannot be null")
            }

            // Extrae la referencia (rama o commit) del objeto scm
            def branches = steps.scm?.getBranches()
            if (branches == null || branches.isEmpty()) {
                steps.error("Branches cannot be null or empty in jenkins scm object")
            }
            String reference = branches?.get(0)?.getName() ?: steps.env.BRANCH_NAME
            if (!reference) {
                logger.warn("Reference in remote scm url ${url} is null")
            }

            // Extrae las credenciales del objeto scm
            String credentialsId = userRemoteConfigs?.get(0)?.getCredentialsId()
            if (!credentialsId) {
                logger.warn("Credentials ID in remote scm url ${url} is null")
            }

            return new SourceRepository(
                    id: 'defaultJenkins',
                    url: url,
                    branch: reference,
                    email: 'cicdBot@giss.devops.es',
                    userName: 'Giss Jenkins Bot',
                    credentialsId: credentialsId ?: '')
        } catch (Exception e) {
            logger.error("Error getting default source repository: ${e.message}")
            return null
        }
    }

    @Override
    void configure(IPipelineContext context) {
        this.defaultJobRepository = getDefaultSourceRepository()
    }


}
</file>

<file path="bin/main/es/giss/framework/core/tools/ProxyHost.groovy">
package es.giss.framework.core.tools

class ProxyHost {
    private String protocol = 'http'
    private String host
    private int port = 8080
    private String proxyUser
    private String proxyPassword

    @Override
    String toString() {
        if (proxyUser || proxyPassword) {
            return "${protocol}://${proxyUser}:${proxyPassword}@${host}:${port}"
        }
        return "${protocol}://${host}:${port}"

    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/ReleaseController.groovy">
package es.giss.framework.core.tools

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.tools.interfaces.ISemanticRelease
import es.giss.framework.core.vo.observability.TelemetryMap
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.project.StructuredResourceMetadata
import es.giss.framework.core.vo.release.*
import es.giss.framework.core.vo.release.interfaces.IGitCommit


import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

@PipelineComponent
class ReleaseController extends Steps implements ISemanticRelease {

    IGitTool gitTool

    ReleaseController(IGitTool gitTool) {
        this.gitTool = gitTool
    }

    @Override
    void analyzeCommits() {
        logger.debug('ReleaseController.analyzeCommits()', 'Ejecucin de analyzeCommits')
        List<IGitCommit> changes = gitTool.fetchLastCommits(4)

        logger.debug('ReleaseController.analyzeCommits()', "changes: ${changes}")

        GitCommitContext commitContext = gitTool.getGitCurrentBranchInfo()
        Changelog changelog = new Changelog(
                currentChangeSet: commitContext,
                changes: changes,
        )

        logger.debug('ReleaseController.analyzeCommits()', "commitContext: ${commitContext}")

        GitflowPhase currentFlowPhase = commitContext.getGitflowPhase()
        logger.debug('ReleaseController.analyzeCommits()', "currentFlowPhase: ${currentFlowPhase}")
        String pipelineTagVersion = steps.env.BRANCH_NAME ==~ /\d+\.\d+\.\d+.*/ ? steps.env.BRANCH_NAME : ''

        SemanticVersion version = pipelineTagVersion? SemanticVersion.fromString(pipelineTagVersion): commitContext.getTagVersion()
        logger.debug('ReleaseController.analyzeCommits()', "version from tag: ${version}")

        ReleasePromotion releasePromotion = currentFlowPhase.getReleasePromotion()
        logger.debug('ReleaseController.analyzeCommits()', "releasePromotion: ${releasePromotion}")

        String ocNamespaceSuffix = pipeline.getStore(ReleaseDescriptor).select { ReleaseDescriptor descriptor -> descriptor.spec?.releaseConfigs?.get(0)?.ocNamespaceSuffix.toString() }
        String releaseName = pipeline.getStore(ReleaseDescriptor).select { ReleaseDescriptor descriptor -> descriptor?.metadata?.name }

        String namespace = "g${releasePromotion.toEnvironment.toString()}-${ocNamespaceSuffix}".toString()

        logger.debug('ReleaseController.analyzeCommits()', "Calculated namespace:  ${namespace} from releasePromotion: ${releasePromotion} and ocNamespaceSuffix: ${ocNamespaceSuffix}")

        ReleaseDescriptor releaseDescriptor = new ReleaseDescriptor(
                metadata: new StructuredResourceMetadata(
                        namespace: namespace,
                ),
                spec: new ReleaseSpec(
                        version: version,
                        date: LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss")),
                        changeLog: changelog,
                        currentFlowPhase: currentFlowPhase,
                        releasePromotion: releasePromotion,
                )
        )

        logger.debug('ReleaseController.analyzeCommits()', "releaseDescriptor config: ${releaseDescriptor}")
        ProjectDescriptor projectDescriptor = new ProjectDescriptor(
                metadata: new StructuredResourceMetadata(
                        name: releaseName,
                        namespace: namespace,
                ),
        )

        PipelineDefinition pipelineDefinition = new PipelineDefinition(
                metadata: new StructuredResourceMetadata(
                        name: releaseName,
                        namespace: namespace,
                ),
        )

        pipeline.updateDataModels(releaseDescriptor)
        pipeline.updateDataModels(projectDescriptor)
        pipeline.updateDataModels(pipelineDefinition)

        pipeline.getStore(ReleaseDescriptor).select { ReleaseDescriptor descriptor ->
            logger.printPrettyLog(LogLevel.DEBUG, 'ReleaseController.analyzeCommits() Post update ReleaseDescriptor:', descriptor.toMap())
        }

    }

    @Override
    boolean verifyConditions() {
        logger.debug('ReleaseController.verifyConditions()', 'Ejecucin de verifyConditions')
        return pipeline.getStore(ReleaseDescriptor).select { ReleaseDescriptor descriptor ->
            descriptor.spec.currentFlowPhase != GitflowPhase.INVALID
        }

    }

    @Override
    boolean incrementTagSnapshot(SemanticVersion currentVersion){
        logger.info("ReleaseController.incrementTagSnapshot()", "Incremento de Tag Snapshot a partir de ${currentVersion.toFullString()}")
        String tag = currentVersion.incrementBuild().toFullString()
        Boolean res = gitTool.createTag(tag)
        logger.info("ReleaseController.incrementTagSnapshot()", "Nuevo Tag Snapshot: ${tag}")
        return res
    }

    @Override
    void createTagMaster(SemanticVersion currentVersion) {
        logger.info("ReleaseController.createTagMaster(String currentVersion)", "Creacion de tag en master a partir de ${currentVersion.toString()}")
        String tag = currentVersion.getReleaseMaster()
        Boolean res = gitTool.createTag(tag)
        logger.info("ReleaseController.createTagMaster(String currentVersion)", "Nuevo Tag de Master: ${tag}")
        if(!res){
            steps.error("[ReleaseController.createTagMaster()] Error al crear el Tag de Master")
        }
    }

    @Override
    void configure(IPipelineContext context) {
        logger.debug('ReleaseController.configure()', 'Ejecucin de configure')

    }
}
</file>

<file path="bin/main/es/giss/framework/core/tools/ToolsManager.groovy">
package es.giss.framework.core.tools

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Stage
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.IToolsStrategy
import es.giss.framework.core.tools.interfaces.IToolsManager

@PipelineComponent()
class ToolsManager extends Stage implements IToolsManager {

    private List<IToolsStrategy> toolsStrategies = []

    @Override
    void setToolVersion(String tool, String version) {
        sortedStrategies().each {
            if (it.filterTool(tool)) {
                it.setToolVersion(tool, version)
            }
        }
    }

    @NonCPS
    @Override
    void registerToolStrategy(IToolsStrategy strategy) {
        toolsStrategies.add(strategy)
    }

    @NonCPS
    List<IToolsStrategy> sortedStrategies() {
        return toolsStrategies.sort { a, b ->
            int priorityA = a.priority()
            int priorityB = b.priority()

            if (priorityA != priorityB) {
                return priorityA <=> priorityB // Ordenar por prioridad descendente
            }
            return 0
        } as List<IToolsStrategy>
    }

    @Override
    void configure(IPipelineContext context) {
        logger.debug('ToolsManager.configure', "Variable de entorno CACHE_BASE_DIR: ${steps.env.CACHE_BASE_DIR}")

        sortedStrategies().each {
            it.configure(context)
        }
    }

}
</file>

<file path="bin/main/es/giss/framework/core/tools/WorkspaceTool.groovy">
package es.giss.framework.core.tools

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.WatchFiles

import java.nio.file.FileSystems
import java.nio.file.Path
import java.nio.file.Paths

@PipelineComponent
class WorkspaceTool extends Steps implements IWorkspaceTool {
    private WatchFiles watchFiles
    private IGitTool gitTool

    WorkspaceTool(IGitTool gitTool) {
        this.gitTool = gitTool
        this.watchFiles = new WatchFiles(inclusions: [], exclusions: [])
    }

    @Override
    Boolean directoryExists(String directory) {
        String result = execute("[ -d  ${directory} ]")
        if (result.contains('_KO_')) {
            return false
        }
        return true
    }

    void setWatchFiles(WatchFiles watchFiles) {
        this.watchFiles = watchFiles
    }

    @Override
    Boolean fileExists(String file) {
        String result = execute("test -f ${file}")
        if (result.contains('_KO_')) {
            return false
        }
        return true
    }

    @Override
    void createDirectoriesIfNotExist(List<String> dirs) {
        execute("mkdir -p ${dirs.join(' ')}")
    }

    @Override
    void writeFile(String file, String text) {
        String scrCat = """cat <<'EOF' > "${file}"\n${text?.trim()}\nEOF"""
        int result = executeWithStatus(scrCat, [:])
        logger.debug("[WorkspaceTool.writeFile] Ejecutado con resultado: ${result}")
        checkAndThrowException(result, scrCat)
    }

    @Override
    String readFile(String file) {
        String result = execute("cat ${file}")
        checkAndThrowException(result)
        return result
    }

    @Override
    Boolean globMatch(String pattern, String str) {
        return globMatch(pattern, str, true)
    }

    @Override
    Boolean globMatch(String pattern, String path, boolean caseSensitive) {
        def globPattern = caseSensitive ? pattern : pattern.toLowerCase()
        def filePath = caseSensitive ? path : path.toLowerCase()
        return FileSystems
                .getDefault()
                .getPathMatcher("glob:${globPattern}")
                .matches(Paths.get(filePath))
    }

    @Override
    Boolean checkWatchedFiles(Boolean abortPipeline = true) {
        List<String> watchFilesInclusionsList = watchFiles?.inclusions ?: []
        List<String> watchFilesExclusionsList = watchFiles?.exclusions ?: []
        checkWatchedFiles(abortPipeline, watchFilesInclusionsList, watchFilesExclusionsList)
    }

    @Override
    Boolean checkWatchedFiles(Boolean abortPipeline, List<String> inclusions, List<String> exclusions) {
        if (!inclusions) {
            logger.warn 'No watchFiles configured'
            return true
        }

        List<String> changedFiles = getChangedFileList()
        logger.info "Files that have changed are ${changedFiles.join(', ')}"

        // Find any file included in `watchFilesInclusionsList` and not excluded in `watchFilesInclusionsList`
        Boolean foundCoincidence = changedFiles.any { file ->
            logger.debug "Checking if file '${file}' matches any inclusion patterns"
            Boolean fileFound = doesFileMatchAnyPattern(file, inclusions)
            Boolean fileIgnored = false

            if (fileFound) {
                logger.debug "Checking if file ${file} matches any exclusion patterns"
                fileIgnored = doesFileMatchAnyPattern(file, exclusions)
                logger.debug "File '${file}' is ${fileIgnored ? 'ignored' : 'included'}"
            }
            return fileFound && !fileIgnored
        }

        logger.info "${foundCoincidence ? 'Found' : 'Not found any'} coincidence"

        if (!foundCoincidence && abortPipeline) {
            logger.info 'Skip execution since no files have changed between the reference and the HEAD'
            pipeline.autoCancelled = true
            steps.currentBuild.description = 'Skipped execution'
            steps.currentBuild.result = 'SUCCESS'
        }
        return foundCoincidence
    }

    @Override
    List<Path> findFiles(String directory, String pattern) {
        logger.debug "Searching files in '${directory}' with pattern '${pattern}'"
        String result = execute("find ${directory} -wholename '${pattern}'")
        checkAndThrowException(result)

        if(result.contains('\n')) {
            return result.tokenize('\n').collect { Paths.get(it) }
        }
        logger.debug('WorkspaceTool.findFiles()', "Files Result: ${result}")
        return result ? [Paths.get(result)] : []
    }

    @Override
    Path findClosestFile(String directory, String pattern) {
        String result = execute("find ${directory} -depth -name '${pattern}' | head -n 1")
        checkAndThrowException(result)
        return result ? Paths.get(result.trim()) : null
    }

    private List<String> getChangedFileList() {
        // Get latest tag but if no tags are found then take the first commit
        String fromRef = (gitTool.getLatestTagFromCurrentHead()) ?: gitTool.getFirstCommitSha()
        if (fromRef.contains('_KO_')) {
            steps.error(fromRef)
        }
        // Get the list of files that have changed between the reference and the HEAD
        return gitTool.getChangedFilesBetweenCommits(fromRef, 'HEAD')
    }

    Boolean doesFileMatchAnyPattern(String filePath, List<String> expressions) {
        return expressions.any { globPattern ->
            boolean found = globMatch(globPattern, filePath)
            logger.debug "File '${filePath}' ${(found) ? 'matches' : 'does not match'} pattern ${globPattern}"
            return found
        }
    }

    private void checkAndThrowException(String result) {
        if (result.contains('_KO_')) {
            steps.error(result)
        }
    }

    private void checkAndThrowException(int result, String msj) {
        if (result != 0) {
            steps.error("El comando fallo: ${msj}. Resultado: ${result}")
        }
    }

    @Override
    void configure(IPipelineContext context) {

    }

    String execute(String command) {
        return execute(command, [:])
    }

    @Override
    Integer executeWithStatus(String command, options) {
        return steps.sh(script: command?.trim(), returnStatus: true)
    }

    @Override
    String execute(String command, Object options) {
        logger.debug('WorkspaceTool.execute()', "Ejecutando comando: ${command}")
        return steps.sh(script: """#!/bin/bash
                                   ${command?.trim()}; [ \$? -eq 0 ] || echo "_KO_ status: \$?"
                                """.trim(), returnStdout: true).trim()
    }
}
</file>

<file path="bin/main/es/giss/framework/core/utils/interfaces/IExpressionEvaluator.groovy">
package es.giss.framework.core.utils.interfaces

interface IExpressionEvaluator {

    def resolve(String expression, Map context)

    def evaluate(String groovyQuery, def context)
}
</file>

<file path="bin/main/es/giss/framework/core/utils/ArtifactsHelmXmlReader.groovy">
package es.giss.framework.core.utils

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.logger.LogLevel

class ArtifactsHelmXmlReader {

    private final static String file = "artifacts_helm.xml"

    protected Script steps
    protected ILogger logger

    ArtifactsHelmXmlReader(Script steps, ILogger logger) {
        this.steps = steps
        this.logger = logger
    }

    List<Map> getHelmConfig() {
        String helmXmlContent = loadFile(file)
        if (!helmXmlContent) {
            return [[:]]
        }
        List<Map> configMap = parseArtifactsHelm(helmXmlContent)
        logger.printPrettyLog(LogLevel.DEBUG, 'Helm Config Map:', configMap)
        return configMap
    }

    private String loadFile(String filePath) {
        String PIPE_PATH = "${steps.env.WORKSPACE}/pipes"
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${filePath}")
        if (exists) {
            def fileContent = steps.readFile(file: "${PIPE_PATH}/${filePath}")
            logger.debug("Loading configuration from file ${PIPE_PATH}/${filePath}.")
            return fileContent
        } else {
            logger.warn("File ${filePath} does not exists.")
        }
        return ''
    }
//
    @NonCPS
    private List<Map<String, Object>> parseArtifactsHelm(String xmlContent) {
        def artifacts = new XmlSlurper().parseText(xmlContent)

        def deployDefaultXml = artifacts?.helm?.deploy_default
        Map deployDefault = [
                ocNamespaceSuffix : deployDefaultXml?.@oc_namespace_suffix.text() ?: '--',
                runtimeTech       : deployDefaultXml?.@runtime_tech.text() ?: '--',
                runtimeTechVersion: deployDefaultXml?.@runtime_tech_version.text() ?: '--',
                runtimeTechTag    : deployDefaultXml.@runtime_tech_tag.text() ?: '--',
                chartVersion      : deployDefaultXml.@chart_version.text() ?: '--',
                configPath        : deployDefaultXml.@path_config.text() ?: 'src/main'
        ]


        return artifacts.helm.deploy.collect { it ->
            String artifactId = it.@artifact.text()
            def deployArtifact = artifacts.artifact.find { it.@name == artifactId }
            return [
                    releaseName       : it.@nombre_release.text(),
                    artifactId        : artifactId,
                    configPath        : it.@path_config.text() ?: deployDefault.configPath,
                    ocNamespaceSuffix : it.@oc_namespace_suffix.text() ?: deployDefault.ocNamespaceSuffix,
                    runtimeTech       : it.@runtime_tech.text() ?: deployDefault.runtimeTech,
                    runtimeTechVersion: it.@runtime_tech_version.text() ?: deployDefault.runtimeTechVersion,
                    runtimeTechTag    : it.@runtime_tech_tag.text() ?: deployDefault.runtimeTechTag,
                    chartVersion      : it.@chart_version.text() ?: deployDefault.chartVersion,
                    nexusFile         : deployArtifact?.nexus_file?.text() ?: ''
            ]
        }

    }


}
</file>

<file path="bin/main/es/giss/framework/core/utils/ExpressionEvaluator.groovy">
package es.giss.framework.core.utils

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.utils.interfaces.IExpressionEvaluator

@PipelineComponent
class ExpressionEvaluator extends Steps implements IExpressionEvaluator {
    static final OPERATOR_PATTERN = /(it\.\w+\s*(==|!=|<=|>=|=~|>|<)\s*(.+))/
    static final EXISTENCE_PATTERN = /(it\.\w+)/
    static final LOGICAL_OPERATOR_PATTERN = /(\|\||&&)/

    @NonCPS
    def parse(String jsonPath) {
        def groovyQuery = 'data'
        def matcher = jsonPath =~ /(\w+|\[\?.*?\)\]|\[.*?\]|\*)/
        // Encuentra todas las palabras o cualquier cosa entre corchetes
        def parts = matcher.findAll().collect { it?.get(0) }

        parts.each { String part ->
            if (part.startsWith('$') || part == '*') {
                // Root element, do nothing as 'data' is already the root.
                // Wildcard, add '.*' to the Groovy query.
            } else if (part == '[*]') {
                // Wildcard, add '*' to the Groovy query.
                groovyQuery += '*'
            } else if (part.startsWith('[')) {
                // Handle slices, direct indexes, and filters.
                if (part ==~ /\[\?\(.*\)\]/) {
                    // Extract the filter condition, replace '@' with 'it'.
                    String condition = part
                            .replaceAll(/\[\?\(/, '')
                            .replaceAll(/\)\]/, '')
                            .replaceAll(/@/, 'it')
                            .replaceAll(/\$\['(.*?)'\]/, 'data.$1') // Handle references to other fields.

                    // Split the condition into parts by logical operators.
                    def conditions = condition.split(LOGICAL_OPERATOR_PATTERN)

                    // Check each part of the condition.
                    conditions.each { String cond ->
                        cond = cond?.trim()
                        def operatorsMatcher = cond =~ OPERATOR_PATTERN
                        def existenceMatcher = cond =~ EXISTENCE_PATTERN
                        if (!operatorsMatcher.matches() && !existenceMatcher.matches()) {
                            throw new IllegalArgumentException("Invalid filter condition: '${cond}'. The condition should follow one of the allowed patterns: '==', '!=', '<', '<=', '>', '>=', '=~', or a field existence check.")
                        }
                    }
                    groovyQuery += ".findAll { ${condition} }"

                } else if (part ==~ /\[-?\d*,-?\d*\]|\[-?\d+\]/) {
                    // Handle array slice.
                    groovyQuery += part
                            .replaceAll(/:/, '..')
                            .replace('[..', '[0..')
                            .replace('..]', '..-1]')

                } else if (part ==~ /\[-?\d*:-?\d*\]|\[-?\d+\]/) {
                    // Handle array slice.
                    def tempPart = part

                    if (part ==~ /\[.*:\d+\]/) {
                        tempPart = part.replace(']', ' - 1]')
                    }
                    groovyQuery += tempPart
                            .replace(/:/, '..')
                            .replace('[..', '[0..')
                            .replace('..]', '..-1]')


                } else {
                    // Handle direct index.
                    groovyQuery += '.' + part.replaceAll(/['\'|\"|\[|\]]/, '')
                }
            } else {
                // Property access
                groovyQuery += ".${part}"
            }
        }
        if(groovyQuery.endsWith('first') || groovyQuery.endsWith('last')) {
            groovyQuery = "${groovyQuery}()"
        }
        return groovyQuery
    }

    @NonCPS
    def evaluate(String groovyQuery, def context) {
        Binding binding = new Binding()
        binding.setVariable('data', context)
        GroovyShell shell = new GroovyShell(binding)

        try {
            return shell.evaluate(groovyQuery)
        } catch (Exception e) {
            throw new RuntimeException("Failed to evaluate the query: ${e.message}")
        }
    }


    @Override
    def resolve(String expression, Map context) {
        try {
            if(expression.contains("find")){
                return evaluate("data.${expression}", context)
            }
            String query = parse(expression)
            return evaluate(query, context)
        } catch (Exception e) {
            return null
        }
    }
}
</file>

<file path="bin/main/es/giss/framework/core/utils/MapUtils.groovy">
package es.giss.framework.core.utils

import es.giss.framework.core.cdi.ServicesFactory
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.*
import es.giss.framework.core.vo.release.SemanticVersion

import java.lang.reflect.ParameterizedType

/**
 * Utility methods for maps
 */
class MapUtils {

    /**
     * Find the first key path that exists in the map or return null
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: [
     *      b: [
     *        c: 'value'
     *      ],
     *      d: 'other value'
     *    ]
     * ]
     * findFirstKeyPathOrNull(props, 'a.b.c', 'a.d') // returns 'value'
     * </code></pre>
     * </p
     *
     * @param map Map to search for the key path
     * @param keyPaths Key paths with dot notation to search for in the map in order of priority
     * @return The value of the first key path found or null
     */
    static Object findFirstKeyPathOrNull(Map<String, Serializable> map, String... keyPaths) {
        return keyPaths.collect { keyPath -> findDeep(map, keyPath) }.find { it != null }
    }

    /**
     * Find the key path if it exists in the map or return null
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: [
     *      b: [
     *        c: 'value'
     *      ],
     *      d: 'other value'
     *    ]
     * ]
     * findDeep(props, 'a.b.c') // returns 'value'
     * </code></pre>
     * </p>
     *
     * @param map Map to search for the key path
     * @param keyPath Key path to search for in the map with dot notation
     * @return The value of the key path or null
     */
    //@NonCPS
    static Object findDeep(Map<String, Serializable> map, String keyPath) {
        try {
            def slice = keyPath.split('\\.')
            def key = slice[0]

            if (map.containsKey(key) && slice.size() == 1) {
                return map[key]
            }

            if (map.containsKey(key) && map[key] instanceof Map) {
                return findDeep(map[key] as Map, slice[1..-1].join('.'))
            }

            def matcher = (key =~ /\[(.*?)\]/)
            def filter = null

            if (matcher.find()) {
                filter = matcher.group(1)
                key = key.split('\\[')[0]
            }

            if (map.containsKey(key) && map[key] instanceof List) {
                if (filter?.contains(',')) {
                    def indices = filter.split(',').collect { it.toInteger() }
                    def results = indices.collect { map[key][it] }
                    return slice.size() > 1 ? results.collect { findDeep(it as Map, slice[1..-1].join('.')) } : results
                } else if (filter?.isNumber()) {
                    def result = map[key][filter.toInteger()]
                    return slice.size() > 1 ? findDeep(result as Map, slice[1..-1].join('.')) : result
                } else if (filter?.startsWith('@')) {
                    def attr = filter.substring(1).split('=')[0]
                    def value = filter.substring(1).split('=')[1].replaceAll('"', '')
                    return map[key].find { it[attr] == value }
                } else {
                    return map[key].find {
                        it instanceof Map && (filter ? it[filter.split('=')[0]] == filter.split('=')[1].replaceAll('"', '') : true)
                                ? (slice.size() > 1 ? findDeep(it as Map, slice[1..-1].join('.')) : it)
                                : null
                    }
                }
            }
        } catch (NullPointerException e) {
            return null
        }
    }


    /**
     * Find the key path if it exists in the map or return the default value
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: [
     *      b: [
     *        c: 'value'
     *      ],
     *      d: 'other value'
     *    ]
     * ]
     * findDeepOrDefault(props, 'a.m', 'default value') // returns 'default value'
     * </code></pre>
     * </p>
     *
     * @param map Map to search for the key path
     * @param keyPath Key path to search for in the map with dot notation
     * @param defaultValue Default value to return if the key path is not found
     * @return The value of the key path or the default value
     */
    static Object findDeepOrDefault(Map<String, Serializable> map, String keyPath, Object defaultValue) {
        return findDeep(map, keyPath) ?: defaultValue
    }

    /**
     * Delete all null entries from a map
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: 1234,
     *    b: null,
     *    c: [
     *      d: null,
     *    ]
     * ]
     * deleteNullEntries(props) // returns [a: 1234]
     * </code></pre>
     * </p>
     *
     * @param map Map to delete null entries from recursively
     * @return The map with all null entries removed
     */
    //@NonCPS
    static Map deleteNullEntries(Map map) {
        return map
                ?.collectEntries { k, v -> [k, v instanceof Map ? deleteNullEntries(v) : v] }
                ?.findAll { k, v -> v || v == false } as Map
    }

    /**
     * Merge multiple maps recursively
     *
     * <p>
     * Example:
     * <pre><code>
     * def map1 = [
     *    a: 1234,
     *    b: [
     *      c: 5678,
     *    ]
     * ]
     * def map2 = [
     *    a: 4321,
     *    b: [
     *      d: 8765,
     *    ]
     * ]
     * merge(map1, map2) // returns [a: 4321, b: [c: 5678, d: 8765]]
     * </code></pre>
     * </p>
     *
     * @param maps Maps to merge
     * @return The merged map
     */
    //@NonCPS
    static Map deepMerge(Map... maps) {
        Map result = [:]
        maps.each { map ->
            map.each { k, v ->
                if (result[k] instanceof Map && v instanceof Map) {
                    result[k] = deepMerge(result[k] as Map, v as Map)
                } else if (result[k] instanceof List && v instanceof List) {
                    result[k] = (result[k] as List) + (v as List)
                } else {
                    result[k] = v
                }
            }
        }
        return result
    }

    static Map deepMergeWithKeys(List<String> keys, List<Map> maps) {
        deepMergeWithKeys(keys, maps as Map[])
    }

    static Map deepMergeWithKeys(List<String> keys, Map... datas) {
        Map result = [:]
        datas.each { map ->
            if (map instanceof Map) {
                map.each { k, v ->
                    if (result[k] instanceof Map && v instanceof Map) {
                        boolean keysMatch = keys.any { key -> result[k][key] == v[key] }
                        if (keysMatch) {
                            result[k] = deepMergeWithKeys(keys, [result[k] as Map, v as Map])
                        } else {
                            result[k] = v
                        }
                    } else if (result[k] instanceof List && v instanceof List) {
                        result[k] = mergeLists(keys, result[k] as List, v as List)
                    } else {
                        result[k] = v
                    }
                }
            }
        }
        return result
    }


    static List mergeLists(List<String> keys, List dataOrigin, List dataOverride) {
        Map map = [:]
        dataOrigin.each { item ->
            if (item instanceof Map) {
                if (keys.any { item.containsKey(it) }) {
                    String key = keys.find { item.containsKey(it) }
                    map[item[key]] = item
                } else {
                    map[item] = item
                }
            }
        }
        dataOverride.each { item ->
            if (item instanceof Map) {
                if (keys.any { item.containsKey(it) }) {
                    String key = keys.find { item.containsKey(it) }
                    if (map.containsKey(item[key])) {
                        map[item[key]] = deepMerge(map[item[key]] as Map, item as Map)
                    } else {
                        map[item[key]] = item
                    }
                } else {
                    map[item] = item
                }
            }
        }
        return map.values() as List
    }

    /**
     * Same as {@link #deepMerge(Map ...)} but with a list of maps
     *
     * @param maps Maps to merge
     * @return The merged map
     */
    //@NonCPS
    static Map deepMerge(List<Map> maps) {
        deepMerge(*maps)
    }

    //@NonCPS
    static def createInstance(Class targetClass, def structure) {
        if (structure == null) return null

        try {
            if (Map.isAssignableFrom(structure.getClass())) {
                def instance = targetClass.newInstance()
                structure.each { key, value ->
                    if (instance.hasProperty(key)) {
                        def field = targetClass.getDeclaredField(key)
                        field.setAccessible(true)
                        def fieldType = field.getType()

                        if (List.isAssignableFrom(fieldType)) {
                            def genericType = field.getGenericType()
                            def elementType = Object
                            if (genericType instanceof ParameterizedType) {
                                elementType = ((ParameterizedType) genericType).getActualTypeArguments()[0]
                            }
                            instance[key] = value.collect { element ->
                                createInstance(elementType instanceof Class ? elementType : Object, element)
                            }
                        } else if (Set.class.isAssignableFrom(fieldType)) {
                            def genericType = field.getGenericType()
                            def elementType = Object
                            if (genericType instanceof ParameterizedType) {
                                elementType = ((ParameterizedType) genericType).getActualTypeArguments()[0]
                            }
                            instance[key] = value.collect { element ->
                                createInstance(elementType instanceof Class ? elementType : Object, element)
                            }.toSet()
                        } else if (Map.isAssignableFrom(fieldType)) {
                            if (fieldType == LinkedHashMap) {
                                instance[key] = new LinkedHashMap(value)
                            } else {
                                instance[key] = value // Assign map directly
                            }
                        } else if (!fieldType.isPrimitive() && fieldType != String) {
                            instance[key] = createInstance(fieldType, value)
                        } else if (fieldType.isPrimitive()) {
                            instance[key] = value
                        } else if (fieldType == String) {
                            instance[key] = value
                        } else {
                            instance[key] = value
                        }
                    } else if (ProjectTool.isAssignableFrom(instance.getClass())) {
                        def projectTool = instance as ProjectTool
                        if (projectTool?.strategies == null) {
                            projectTool.strategies = []
                        }
                        if (key == 'buildStrategies') {
                            projectTool.strategies.addAll(value.collect { element ->
                                createInstance(BuildStrategy, element)
                            })
                        }
                        if (key == 'testStrategies') {
                            projectTool.strategies.addAll(value.collect { element ->
                                createInstance(TestStrategy, element)
                            })
                        }
                        if (key == 'publishStrategies') {
                            projectTool.strategies.addAll(value.collect { element ->
                                createInstance(PublishStrategy, element)
                            })
                        }
                        if (key == 'deployStrategies') {
                            projectTool.strategies.addAll(value.collect { element ->
                                createInstance(DeployStrategy, element)
                            })
                        }
                        if (key == 'undeployStrategies') {
                            projectTool.strategies.addAll(value.collect { element ->
                                createInstance(UndeployStrategy, element)
                            })
                        }
                        if (key == 'rollbackStrategies') {
                            projectTool.strategies.addAll(value.collect { element ->
                                createInstance(RollbackStrategy, element)
                            })
                        }
                        if (key.contains('Command')) {
                            instance[key] = value
                        }
                    }
                }
                return instance
            } else if (List.isAssignableFrom(structure.getClass()) || Set.isAssignableFrom(structure.getClass())) {
                return structure.collect { createInstance(targetClass, it) }
            } else if (SemanticVersion.isAssignableFrom(targetClass)) {
                return SemanticVersion.fromString(structure)
//            } else if(targetClass.simpleName.contains("VendorService")) {
//                ServicesFactory.createInstanceFromMap(structure.type, structure)
            }

        } catch (Exception e) {
            throw new Exception("Error creating instance of ${targetClass.name} with structure: ${structure}. Error: ${e.message}")
        }

        return structure
    }

}
</file>

<file path="bin/main/es/giss/framework/core/vo/events/StageSkippedEvent.groovy">
package es.giss.framework.core.vo.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class StageSkippedEvent implements TelemetryModel {
    String stageName


    @Override
    Map<String, Object> toMap() {
        return [
                id: stageName,
                stageName: stageName,
        ]
    }

    @Override
    String getId() {
        return stageName
    }


}
</file>

<file path="bin/main/es/giss/framework/core/vo/events/StageStarted.groovy">
package es.giss.framework.core.vo.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class StageStarted implements TelemetryModel {
    String stageName
    String result

    @Override
    String toString() {
        return """
            id: $stageName          
            stageName: $stageName
            result: $result
        """
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id       : stageName,
                stageName: stageName,
                result   : result
        ]
    }

    @Override
    String getId() {
        return stageName
    }

}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/events/ProcessedCofigAdaptersEvent.groovy">
package es.giss.framework.core.vo.observability.events

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class ProcessedCofigAdaptersEvent implements TelemetryModel {
    String name

    @Override
    Map<String, Object> toMap() {
       return [
              name: name
       ]
    }

    @NonCPS
    @Override
    String getId() {
        return this.name
    }

    @NonCPS
    @Override
    String toString() {
        return "name=${name}"
    }

    @NonCPS
    @Override
    Object clone() {
        return new ProcessedCofigAdaptersEvent(
                name: name
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/events/StageCompletedEvent.groovy">
package es.giss.framework.core.vo.observability.events

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class StageCompletedEvent implements TelemetryModel {

    String stageName
    long duration = 0
    String result

    @Override
    Map<String, Object> toMap() {
        return [
                stageName: stageName,
                duration: duration,
                result: result,
        ]
    }

    @NonCPS
    @Override
    String getId() {
        return stageName
    }

    @NonCPS
    @Override
    Object clone() {
        return new StageCompletedEvent(
                stageName: stageName,
                duration: duration,
                result: result,
        )
    }


    @NonCPS
    @Override
    String toString() {
        return """
            stageName: $stageName
            duration: $duration
            result: $result
        """
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/events/StageErrorEvent.groovy">
package es.giss.framework.core.vo.observability.events

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class StageErrorEvent implements TelemetryModel {
    String stageName
    String message
    String result
    List<String> filteredStackTrace

    @NonCPS
    @Override
    String toString() {
        return """
            stageName: $stageName
            message: $message
            result: $result
            filteredStackTrace: $filteredStackTrace
        """
    }

    @Override
    Map<String, Object> toMap() {
        return [
                stageName         : stageName,
                message           : message,
                result            : result,
                filteredStackTrace: filteredStackTrace
        ]
    }

    @NonCPS
    @Override
    String getId() {
        return this.stageName
    }

    @NonCPS
    @Override
    Object clone() {
        return new StageErrorEvent(
                stageName         : stageName,
                message           : message,
                result            : result,
                filteredStackTrace: filteredStackTrace
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/events/StageSkippedEvent.groovy">
package es.giss.framework.core.vo.observability.events

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class StageSkippedEvent implements TelemetryModel {
    String stageName
    String description = ''


    @Override
    Map<String, Object> toMap() {
        return [
                stageName: stageName,
                description: description
        ]
    }

    @NonCPS
    @Override
    String getId() {
        return this.stageName
    }

    Object clone() {
        return new StageSkippedEvent(
                stageName: stageName,
                description: description
        )
    }


    @NonCPS
    @Override
    String toString() {
        return """
            stageName: $stageName
            description: $description
        """
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/events/StageStarted.groovy">
package es.giss.framework.core.vo.observability.events

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class StageStarted implements TelemetryModel {
    String stageName
    String result

    @NonCPS
    @Override
    String toString() {
        return """          
            stageName: $stageName
            result: $result
        """
    }

    @Override
    Map<String, Object> toMap() {
        return [
                stageName: stageName,
                result   : result
        ]
    }

    @NonCPS
    @Override
    String getId() {
        return this.stageName
    }

    @NonCPS
    @Override
    Object clone() {
        return new StageStarted(
                stageName: stageName,
                result   : result
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/events/StageUnstableEvent.groovy">
package es.giss.framework.core.vo.observability.events

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class StageUnstableEvent implements TelemetryModel {

    String stageName
    String result

    @Override
    Map<String, Object> toMap() {
        return [
                stageName: stageName,
                result: result,
        ]
    }

    @NonCPS
    @Override
    String getId() {
        return stageName
    }

    @NonCPS
    @Override
    Object clone() {
        return new StageUnstableEvent(
                stageName: stageName,
                result: result,
        )
    }


    @NonCPS
    @Override
    String toString() {
        return """
            stageName: $stageName
            result: $result
        """
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/ObservabilityHub.groovy">
package es.giss.framework.core.vo.observability

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.interfaces.StructuredResource
import es.giss.framework.core.vo.project.StructuredResourceMetadata

class ObservabilityHub implements StructuredResource, TelemetryModel {
    String apiVersion = 'observability.giss.es/v1'
    String kind = 'ObservabilityHub'

    StructuredResourceMetadata metadata = new StructuredResourceMetadata()

    Map status = [:]
    ObservabilitySpec spec = new ObservabilitySpec()

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion: apiVersion,
                metadata  : metadata,
                kind      : kind,
                spec      : spec.toMap(),
                status    : status,
        ]
    }

    @Override
    String apiVersion() {
        return this.apiVersion
    }

    @Override
    Map status() {
        return status
    }

    @NonCPS
    @Override
    String getId() {
        return this.kind
    }

    @NonCPS
    @Override
    Object clone() {
        ObservabilityHub clone = new ObservabilityHub()
        clone.apiVersion = this.apiVersion
        clone.kind = this.kind
        clone.metadata = this.metadata.clone()
        clone.status = this.status.clone()
        clone.spec = this.spec.clone()
        return clone
    }

    @NonCPS
    @Override
    String toString() {
        return """
        ObservabilityHub {
                apiVersion: ${apiVersion},
                kind: ${kind},
                metadata: ${metadata.toString()},
                status: ${status.collect { k, v -> "$k: ${v?.toString()}" }},
                spec: ${spec.toString()}
            }"""
    }

}
</file>

<file path="bin/main/es/giss/framework/core/vo/observability/TelemetryMap.groovy">
package es.giss.framework.core.vo.observability

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.TelemetryModel

class TelemetryMap extends HashMap<String, Object> implements TelemetryModel {
    String id

    @Override
    Map<String, Object> toMap() {
        this.put("id", id)
        return this
    }

    @NonCPS
    @Override
    String toString() {
        return """
        TelemetryMap {
            id: $id
        }
        """
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/AlternativesToolsDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class AlternativesToolsDescriptor implements PipelineModel {
    String javaEngine = ''

    @Override
    Map<String, Object> toMap() {
        return [
                javaEngine: javaEngine
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new AlternativesToolsDescriptor(
                javaEngine: javaEngine.toString()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/AsdfToolsManagerDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class AsdfToolsManagerDescriptor implements PipelineModel  {
    String defaultToolVersionsFileDir = ''
    String defaultDataDir = ''
    boolean forceClearCache = false
    ProxySettings proxySettings = new ProxySettings()
    Map<String, String> plugins = [:]
    Map<String, String> tools = [:]


    @Override
    Map<String, Object> toMap() {
        return [
                defaultToolVersionsFileDir: defaultToolVersionsFileDir,
                defaultDataDir             : defaultDataDir,
                forceClearCache            : forceClearCache,
                proxySettings              : proxySettings.toMap(),
                plugins                    : plugins,
                tools                      : tools
        ]
    }

    @NonCPS
    @Override
    public String toString() {
        return "AsdfToolsManagerDescriptor{" +
                "defaultToolVersionsFileDir='" + defaultToolVersionsFileDir + '\'' +
                ", defaultDataDir='" + defaultDataDir + '\'' +
                ", forceClearCache=" + forceClearCache +
                ", proxySettings=" + proxySettings +
                ", plugins=" + plugins +
                ", tools=" + tools +
                '}';
    }

    @NonCPS
    @Override
    Object clone() {
        return new AsdfToolsManagerDescriptor(
                defaultToolVersionsFileDir: defaultToolVersionsFileDir,
                defaultDataDir             : defaultDataDir,
                forceClearCache            : forceClearCache,
                proxySettings              : proxySettings,
                plugins                    : plugins,
                tools                      : tools
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/CacheDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class CacheDescriptor implements PipelineModel {
    String baseDir = ''
    Set<String> cacheFolders = []
    String exportEnvVar = ''
    boolean forceClearCache = false

    @Override
    Map<String, Object> toMap() {
        return [
                baseDir         : baseDir,
                cacheFolders    : cacheFolders,
                exportEnvVar    : exportEnvVar,
                forceClearCache : forceClearCache
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new CacheDescriptor(
                baseDir         : baseDir,
                cacheFolders    : cacheFolders,
                exportEnvVar    : exportEnvVar,
                forceClearCache : forceClearCache
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/CustomScriptManagerDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class CustomScriptManagerDescriptor implements PipelineModel  {
    String defaultToolVersionsFileDir = ''
    String defaultDataDir = ''
    boolean forceClearCache = false
    ProxySettings proxySettings = new ProxySettings()
    Map<String, String> tools = [:]

    @Override
    Map<String, Object> toMap() {
        return [
                defaultToolVersionsFileDir: defaultToolVersionsFileDir,
                defaultDataDir             : defaultDataDir,
                forceClearCache            : forceClearCache,
                proxySettings              : proxySettings.toMap(),
                tools                      : tools
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new CustomScriptManagerDescriptor(
                defaultToolVersionsFileDir: defaultToolVersionsFileDir,
                defaultDataDir             : defaultDataDir,
                forceClearCache            : forceClearCache,
                proxySettings              : proxySettings,
                tools                      : tools
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/GraalVmToolsDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class GraalVmToolsDescriptor implements PipelineModel {

    String javaEngine = ''
    Set<String> plugins = []

    @Override
    Map<String, Object> toMap() {
        return [
                javaEngine: javaEngine,
                plugins: plugins,
        ]
    }

    @NonCPS
    @Override
    public String toString() {
        return "GraalVmToolsDescriptor{" +
                "javaEngine='" + javaEngine + '\'' +
                ", plugins=" + plugins.join(', ') +
                '}';
    }

    @NonCPS
    @Override
    Object clone() {
        return new GraalVmToolsDescriptor(
                javaEngine: javaEngine,
                plugins: plugins
        )

    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/JobStatus.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class JobStatus implements PipelineModel {
    Boolean success = false
    String message = ''
    String buildNumber = ''
    String buildUrl = ''
    Date startTime = new Date()
    Date endTime = new Date()
    String duration = ''
    String gitRemoteUrl = ''
    String gitBranch = ''
    String commitId = ''
    String commitMessage = ''
    String commitEmail = ''
    String buildUserId = ''
    String buildUserName = ''
    String workspace = ''
    String buildTrigger = ''

    boolean isManual() {
        return buildTrigger == 'MANUAL'
    }

    @Override
    Map<String, Object> toMap() {
        return [
                success      : success,
                message      : message,
                buildNumber  : buildNumber,
                buildUrl     : buildUrl,
                startTime    : startTime,
                endTime      : endTime,
                duration     : duration,
                gitRemoteUrl : gitRemoteUrl,
                gitBranch    : gitBranch,
                commitId     : commitId,
                commitMessage: commitMessage,
                commitEmail  : commitEmail,
                buildUserId    : buildUserId,
                buildUserName  : buildUserName,
                workspace      : workspace,
                buildTrigger   : buildTrigger

        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
            success    : $success
            message    : $message
            buildNumber: $buildNumber
            buildUrl   : $buildUrl
            startTime  : $startTime
            endTime    : $endTime
            duration   : $duration
            gitRemoteUrl: $gitRemoteUrl
            gitBranch   : $gitBranch
            commitId   : $commitId
            commitMessage: $commitMessage,
            commitEmail: $commitEmail,
            buildUserId  : $buildUserId,
            buildUserName: $buildUserName,
            workspace: $workspace
            buildTrigger: $buildTrigger           
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return  new JobStatus(
                success      : success,
                message      : message,
                buildNumber  : buildNumber,
                buildUrl     : buildUrl,
                startTime    : startTime,
                endTime      : endTime,
                duration     : duration,
                gitRemoteUrl : gitRemoteUrl,
                gitBranch    : gitBranch,
                commitId     : commitId,
                commitMessage: commitMessage,
                commitEmail  : commitEmail,
                buildUserId    : buildUserId,
                buildUserName  : buildUserName,
                workspace      : workspace,
                buildTrigger   : buildTrigger
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/PipelineDefinition.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel
import es.giss.framework.core.interfaces.StructuredResource
import es.giss.framework.core.vo.project.StructuredResourceMetadata

class PipelineDefinition implements StructuredResource, PipelineModel {
    String apiVersion = 'pipeline.giss.es/v1'
    String kind = 'PipelineDefinition'
    StructuredResourceMetadata metadata = new StructuredResourceMetadata()
    PipelineSpec spec = new PipelineSpec()
    PipelineStatus status = new PipelineStatus()

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion: apiVersion,
                kind      : kind,
                metadata  : metadata.toMap(),
                spec      : getSpec()?.toMap() ?: [:],
                status    : status?.toMap() ?: [:]
        ]
    }

    @Override
    String apiVersion() {
        return this.apiVersion
    }

    @Override
    PipelineStatus status() {
        return this.status
    }

    @NonCPS
    @Override
    String toString() {
        return """
            PipelineDefinition {
                apiVersion: $apiVersion,
                kind: $kind,             
                metadata: $metadata,
                spec: $spec,
                status: $status
            }
        """
    }

    static PipelineDefinition getDefault() {
        return new PipelineDefinition(
                spec: new PipelineSpec(
                        cache: new CacheDescriptor(
                                exportEnvVar: 'CACHE_ROOT_DIR',
                        ),
                        toolsManager: new ToolsManagerDescriptor(
                                alternatives: new AlternativesToolsDescriptor(),
                                asdf: new AsdfToolsManagerDescriptor(
                                    defaultDataDir : '/opt/cache/tools/.asdf-data',
                                    proxySettings : new ProxySettings(
                                            httpsProxy: 'http://proxy-sa.seg-social.es:8080',
                                            httpProxy: 'http://proxy-sa.seg-social.es:8080',
                                            noProxy: 'localhost'
                                    ),
                                ),
                                customScript: new CustomScriptManagerDescriptor(
                                    defaultDataDir : '/opt/cache/tools/.customscript-data',
                                    proxySettings : new ProxySettings(
                                            httpsProxy: 'http://proxy-sa.seg-social.es:8080',
                                            httpProxy: 'http://proxy-sa.seg-social.es:8080',
                                            noProxy: 'localhost'
                                    )
                                )
                        )
                )
        )
    }

    @NonCPS
    @Override
    Object clone() {
        return new PipelineDefinition(
                apiVersion: apiVersion,
                kind      : kind,
                metadata  : metadata.clone(),
                spec      : spec.clone(),
                status    : status.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/PipelineSettings.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class PipelineSettings implements PipelineModel {
    Set<String> skipStages = []
    boolean debugMode = false
    String devopsEnvironment = ''
    Map<String, String> parameters = [:]

    @Override
    Map<String, Object> toMap() {
        return [
                skipStages       : skipStages,
                debugMode        : debugMode,
                devopsEnvironment: devopsEnvironment.toString(),
                parameters       : parameters.collectEntries { k, v -> [k, v!=null?:''] }
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
            PipelineSettings {
                skipStages: $skipStages,
                debugMode: $debugMode,
                devopsEnvironment: $devopsEnvironment,            
                parameters: $parameters
            }
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new PipelineSettings(
                skipStages: skipStages,
                debugMode: debugMode,
                devopsEnvironment: devopsEnvironment,
                parameters: parameters
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/PipelineStatus.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class PipelineStatus implements PipelineModel {

    JobStatus jobStatus = new JobStatus()
    List<String> errors = []

    @Override
    Map<String, Object> toMap() {
        return [
                jobStatus: jobStatus?.toMap()?: [:],
                errors: errors
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new PipelineStatus(
                jobStatus: jobStatus,
                errors: errors
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/ProxySettings.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel

class ProxySettings implements PipelineModel {
    String httpProxy = ''
    String httpsProxy = ''
    String noProxy = ''

    @Override
    Map<String, Object> toMap() {
        return [
                httpProxy : httpProxy,
                httpsProxy: httpsProxy,
                noProxy   : noProxy
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new ProxySettings(
                httpProxy : httpProxy,
                httpsProxy: httpsProxy,
                noProxy   : noProxy
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/pipeline/ToolsManagerDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.PipelineModel


class ToolsManagerDescriptor implements PipelineModel {
    AlternativesToolsDescriptor alternatives = new AlternativesToolsDescriptor()
    AsdfToolsManagerDescriptor asdf = new AsdfToolsManagerDescriptor()
    GraalVmToolsDescriptor graalVmTools = new GraalVmToolsDescriptor()
    CustomScriptManagerDescriptor customScript = new CustomScriptManagerDescriptor()


    Map<String, Object> toMap() {
        return [
                alternatives: alternatives?.toMap() ?: [:],
                asdf        : asdf?.toMap() ?: [:],
                graalVmTools: graalVmTools?.toMap() ?: [:],
                customScript: customScript?.toMap() ?: [:]
        ]
    }

    @NonCPS
    @Override
    public String toString() {
        return "ToolsManagerDescriptor{" +
                "alternatives=" + alternatives +
                ", asdf=" + asdf +
                ", graalVmTools=" + graalVmTools +
                ", customScript=" + customScript +
                '}';
    }

    @NonCPS
    @Override
    Object clone() {
        return new ToolsManagerDescriptor(
                alternatives: alternatives?.clone(),
                asdf        : asdf?.clone(),
                graalVmTools: graalVmTools?.clone(),
                customScript: customScript?.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/BuildStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.Metadata
import groovy.text.GStringTemplateEngine

class BuildStrategy implements ProjectActionStrategy {
    String id = ''
    String toolId = ''
    String name = ''
    String type = BuildStrategy.class.getSimpleName()
    protected String buildCommand = ''
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        if (buildCommand?.contains('$')) {
            return new GStringTemplateEngine().createTemplate(buildCommand).make(metadata).toString()
        }
        return buildCommand
    }

    @Override
    void prepareEnvironment(IPipelineContext context) {
        // Implementar logica particular de la estrategia

    }

    @Override
    void postExecution(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }

    @NonCPS
    @Override
    String toString() {
        return """
        BuildStrategy {
                id: ${id},
                name: ${name},
                toolId: ${toolId},
                buildCommand: ${buildCommand},    
                type: ${type},           
                metadata: ${metadata}
            }"""
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id          : id,
                name        : name,
                type        : type,
                toolId      : toolId,
                buildCommand: buildCommand,
                metadata    : metadata.toMap()
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new BuildStrategy(
                id: id,
                toolId: toolId,
                type: type,
                name: name,
                buildCommand: buildCommand,
                metadata: metadata.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/DeployStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.Metadata

class DeployStrategy implements ProjectActionStrategy {
    String id = ''
    String toolId = ''
    String type = DeployStrategy.class.getSimpleName()
    String name = ''
    protected String deployCommand = ''
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        return deployCommand
    }

    @Override
    void prepareEnvironment(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }

    @Override
    void postExecution(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }

    @NonCPS
    @Override
    String toString() {
        return """
        DeployStrategy {
                id: ${id},
                toolId: ${toolId},
                name: ${name},
                type: ${type},
                deployCommand: ${deployCommand},               
                metadata: ${metadata}
            }"""
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id           : id,
                name         : name,
                toolId       : toolId,
                type         : type,
                deployCommand: deployCommand,
                metadata     : metadata.toMap()
        ]
    }


    @NonCPS
    @Override
    Object clone() {
        return new DeployStrategy(
                id: id,
                toolId: toolId,
                type: type,
                name: name,
                deployCommand: deployCommand,
                metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/ProjectActionStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Derivable
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.Identifiable
import es.giss.framework.core.vo.project.Metadata


interface ProjectActionStrategy extends ProjectDescriptorModel, Identifiable, Derivable {

    String getId()

    String getToolId()

    String getName()

    String getCommand()

    Metadata getMetadata()

    void setMetadata(Metadata metadata)

    void prepareEnvironment(IPipelineContext context)

    void postExecution(IPipelineContext context)
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/PublishStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.Metadata
import groovy.text.GStringTemplateEngine

class PublishStrategy implements ProjectActionStrategy {
    String id = ''
    String toolId = ''
    String name = ''
    String type = ''
    protected String publishCommand = ''
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        if (publishCommand?.contains('$')) {
            return new GStringTemplateEngine().createTemplate(publishCommand).make(metadata).toString()
        }
        return publishCommand
    }

    @Override
    void prepareEnvironment(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }

    @Override
    void postExecution(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }

    @NonCPS
    @Override
    String toString() {
        return """        
                id: ${id}
                name: ${name}
                toolId: ${toolId}
                type: ${type}
                publishCommand: ${publishCommand}             
                metadata: ${metadata}
            """
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id            : id,
                name          : name,
                toolId        : toolId,
                type          : type,
                publishCommand: publishCommand,
                metadata      : metadata.toMap()
        ]
    }


    @NonCPS
    @Override
    Object clone() {
        return new PublishStrategy(
                id: id,
                toolId: toolId,
                type: type,
                name: name,
                publishCommand: publishCommand,
                metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/RollbackStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.DeployTarget
import es.giss.framework.core.vo.project.Metadata

class RollbackStrategy implements ProjectActionStrategy {
    String id = ''
    String toolId = ''
    String name = ''
    String type = ''
    protected String rollbackCommand = ''
    DeployTarget deployTarget = new DeployTarget()
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        return rollbackCommand
    }

    @Override
    void prepareEnvironment(IPipelineContext context) {
        // Implementar logica particular de la estrategia

    }

    @Override
    void postExecution(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }


    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                toolId: toolId,
                type: type,
                rollbackCommand: rollbackCommand,
                deployTarget: deployTarget.toMap(),
                metadata: metadata.toMap()
        ]
    }


    @NonCPS
    @Override
    Object clone() {
        return new RollbackStrategy(
                id: id,
                toolId: toolId,
                name: name,
                type: type,
                rollbackCommand: rollbackCommand,
                deployTarget: deployTarget,
                metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/TestStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.Metadata

class TestStrategy implements ProjectActionStrategy {
    String id = ''
    String toolId = ''
    String type = TestStrategy.class.getSimpleName()
    String name = ''
    protected String testCommand = ''
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        return testCommand
    }

    @Override
    void prepareEnvironment(IPipelineContext context) {
        // Implementar logica particular de la estrategia

    }

    @Override
    void postExecution(IPipelineContext context) {
        // Implementar logica particular de la estrategia

    }

    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                toolId: toolId,
                type: type,
                testCommand: testCommand,
                metadata: metadata.toMap()
        ]
    }


    @NonCPS
    @Override
    Object clone() {
        return new TestStrategy(
                id: id,
                toolId: toolId,
                name: name,
                testCommand: testCommand,
                metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/strategies/UndeployStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.Metadata

class UndeployStrategy implements ProjectActionStrategy {
    String id = ''
    String toolId = ''
    String type = ''
    String name = ''
    protected String undeployCommand = ''
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        return undeployCommand
    }

    @Override
    void prepareEnvironment(IPipelineContext context) {
        // Implementar logica particular de la estrategia

    }

    @Override
    void postExecution(IPipelineContext context) {
        // Implementar logica particular de la estrategia
    }


    @Override
    Map<String, Object> toMap() {
        return [
                id             : id,
                name           : name,
                toolId         : toolId,
                type           : type,
                undeployCommand: undeployCommand,
                metadata       : metadata.toMap()
        ]
    }


    @NonCPS
    @Override
    Object clone() {
        return new UndeployStrategy(
                id            : id,
                toolId        : toolId,
                name          : name,
                type          : type,
                undeployCommand: undeployCommand,
                metadata      : metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ArtifactsRepository.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable

class ArtifactsRepository implements ProjectDescriptorModel, Identifiable {
    String id = ''
    String name = ''
    String url = ''
    ArtifactsRepositoryType type = ArtifactsRepositoryType.UNKNOWN
    String credentialsId = ''
    Metadata metadata = new Metadata()

    boolean validate() {
        return id && url && credentialsId
    }

    @NonCPS
    @Override
    String toString() {
        return """
            ArtifactsRepository {
                id: ${id},
                name: ${name},
                url: ${url},
                type: ${type},
                credentialsId: ${credentialsId},
                metadata: ${metadata}
            }
        """
    }

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            url: url,
            type: type,
            credentialsId: credentialsId,
            metadata: metadata
        ]
    }

    @NonCPS
    String domainUrl() {
        // Expresin regular para extraer el dominio de una URL
        def pattern = ~/(https?:\/\/[^\/]+)\/.*/
        def matcher = pattern.matcher(this.url)
        if (matcher.find()) {
            return matcher.group(1) // Devuelve el dominio encontrado
        } else {
            return ''
        }
    }

    @NonCPS
    @Override
    Object clone() {
        return new ArtifactsRepository(
            id: id,
            name: name,
            url: url,
            type: type,
            credentialsId: credentialsId,
            metadata: metadata.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ArtifactsRepositoryType.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

enum ArtifactsRepositoryType implements ProjectDescriptorModel {
    DEPLOY, HELM_DEPLOY, MAVEN, NPM, UNKNOWN

    @Override
    Map<String, Object> toMap() {
        return [
            name: name(),
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return name()
    }

}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ArtifactType.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ArtifactType implements ProjectDescriptorModel {
    String name = ''
    String extension = ''

    @Override
    Map<String, Object> toMap() {
        return [
            name: name,
            extension: extension
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new ArtifactType(
            name: name,
            extension: extension
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/DeployTarget.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable

class DeployTarget implements ProjectDescriptorModel, Identifiable {
    String id = ''
    String name = ''
    String description = ''
    String type = 'DeployTarget'
    Metadata metadata = new Metadata()

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            description: description,
            type: type,
            metadata: metadata
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """            
                id: $id
                name: $name
                description: $description
                type: $type
                metadata: $metadata            
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return  new DeployTarget(
            id: id,
            name: name,
            description: description,
            type: type,
            metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/Email.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable

class Email implements ProjectDescriptorModel, Identifiable {
    String name
    String email
    Set<String> notificationsInterested = [] as Set

    @Override
    Map<String, Object> toMap() {
        return [
                name                   : name,
                email                  : email,
                notificationsInterested: notificationsInterested
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """            
                name: $name
                email: $email
                notificationsInterested: $notificationsInterested
            """
    }

    @NonCPS
    @Override
    boolean equals(Object o) {
        if (!(o instanceof Email)) return false
        Email emailObj = (Email) o

        return email != null ? email == emailObj.email : emailObj.email == null
    }

    @NonCPS
    @Override
    int hashCode() {
        return email != null ? email.hashCode() : 0
    }

    @NonCPS
    @Override
    String getId() {
        return email
    }

    @NonCPS
    @Override
    void setId(String id) {
        this.email = id
    }

    @NonCPS
    @Override
    Object clone() {
        return new Email(
                name                   : name,
                email                  : email,
                notificationsInterested: notificationsInterested
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/Metadata.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.ModelCloneable

class Metadata extends HashMap<String, Object> implements ModelCloneable {

    @NonCPS
    @Override
    String toString() {
        return """           
                ${this.collect { k, v -> "$k: $v" }.join("\n")}            
        """
    }


    @NonCPS
    Map<String, Object> toMap() {
        return this.collectEntries { k, v ->
            [k.toString(), (v instanceof GString) ? v.toString() : v]
        }
    }

    @Override
    @NonCPS
    Object clone() {
        def metadata =  new Metadata()
        metadata.putAll(this)
        return metadata
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/Notification.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class Notification implements ProjectDescriptorModel {
    Set<Email> emails = new HashSet<Email>()

    @Override
    Map<String, Object> toMap() {
        return [
            emails: emails.collect {
                (it as Email)?.toMap()?: [:]
            }
        ]
    }

    @Override
    String toString() {
        return """           
               emails: $emails            
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new Notification(
            emails: emails
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ProjectConfigurationFile.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectConfigurationFile implements ProjectDescriptorModel {
    protected String name = ''
    protected String version = ''
    protected def dependencies = []

    @Override
    Map<String, Object> toMap() {
        return [
            name        : name,
            version     : version,
            dependencies: dependencies
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """            
              - name: $name
                version: $version
                dependencies: $dependencies            
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ProjectConfigurationFile(
            name        : name,
            version     : version,
            dependencies: dependencies
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ProjectDescriptor.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.StructuredResource

class ProjectDescriptor implements StructuredResource, ProjectDescriptorModel {
    String apiVersion = 'project.giss.es/v1'
    String kind = 'ProjectDescriptor'
    StructuredResourceMetadata metadata = new StructuredResourceMetadata()
    ProjectSpec spec = new ProjectSpec()
    ProjectStatus status = new ProjectStatus()

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion        : apiVersion,
                kind              : kind,
                metadata          : metadata.toMap(),
                spec              : spec?.toMap() ?: [:],
                status            : status?.toMap() ?: [:]
        ]
    }

    @Override
    String apiVersion() {
        return this.apiVersion
    }

    @Override
    def status() {
        return status
    }

    @NonCPS
    @Override
    String toString() {
        return """            
                apiVersion: $apiVersion
                kind: $kind                
                metadata: $metadata
                spec: $spec
                status: $status
            }
        """
    }

    static ProjectDescriptor getDefault() {
        return new ProjectDescriptor()
    }

    @NonCPS
    @Override
    Object clone() {
        return new ProjectDescriptor(
                apiVersion: apiVersion,
                kind      : kind,
                metadata  : metadata,
                spec      : spec,
                status    : status
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ProjectSettings.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectSettings implements ProjectDescriptorModel {
    String name = ''
    String description = ''
    String inceptionYear = ''
    String developCenter = ''
    String codeCapp = ''
    String promotableItem = ''
    String currentVersion = ''
    String suffix = ''

    @Override
    Map<String, Object> toMap() {
        return [
                name          : name,
                description   : description,
                inceptionYear : inceptionYear,
                developCenter : developCenter,
                codeCapp      : codeCapp,
                promotableItem: promotableItem,
                currentVersion: currentVersion,
                suffix        : suffix,
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
            ProjectSettings {
                name: $name,
                description: $description,
                inceptionYear: $inceptionYear,
                developCenter: $developCenter,
                codeCapp: $codeCapp,
                promotableItem: $promotableItem,
                currentVersion: $currentVersion,
                suffix: $suffix
            }
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return  new ProjectSettings(
                name          : name,
                description   : description,
                inceptionYear : inceptionYear,
                developCenter : developCenter,
                codeCapp      : codeCapp,
                promotableItem: promotableItem,
                currentVersion: currentVersion,
                suffix        : suffix
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ProjectStatus.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectStatus implements ProjectDescriptorModel {

    List<ProjectConfigurationFile> projectConfigurationFiles = []
    List<String> errors = []
    List<ScannerToolResult> scannerToolResult = []

    @Override
    Map<String, Object> toMap() {
        return [
                configurationFiles: projectConfigurationFiles.collect { it.toMap() },
                errors: errors,
                scannerToolResult: scannerToolResult.collect { it.toMap() },
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
            status:
                projectConfigurationFiles: $projectConfigurationFiles
                errors: $errors            
                scannerToolResult: $scannerToolResult           
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ProjectStatus(
                projectConfigurationFiles: projectConfigurationFiles.collect { it.clone() },
                errors: errors,
                scannerToolResult: scannerToolResult.collect { it.clone() },
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ProjectTool.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable
import es.giss.framework.core.vo.project.strategies.*

class ProjectTool implements ProjectDescriptorModel, Identifiable {
    String id = ''
    String name = ''
    String version = ''
    boolean cache = false
    String toolConfigurationFilePath = ''
    String artifactsRepositoryId = ''
    List<ProjectActionStrategy> strategies = []


    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                version: version,
                cache: cache,
                toolConfigurationFilePath: toolConfigurationFilePath,
                artifactsRepositoryId: artifactsRepositoryId,
                buildStrategy: strategies.find { it instanceof BuildStrategy }?.toMap()?: [:],
                testStrategy: strategies.find { it instanceof TestStrategy }?.toMap()?: [:],
                publishStrategy: strategies.find { it instanceof PublishStrategy }?.toMap()?: [:],
                deployStrategy: strategies.find { it instanceof DeployStrategy }?.toMap()?: [:],
                undeployStrategy: strategies.find { it instanceof UndeployStrategy }?.toMap()?: [:],
                rollbackStrategy: strategies.find { it instanceof RollbackStrategy }?.toMap()?: [:]
        ]
    }

    ProjectActionStrategy getStrategyById(String id) {
        return strategies.find { it.id == id }
    }

    @NonCPS
    @Override
    String toString() {
        return """            
              - id: $id
                name: $name
                version: $version
                cache: $cache
                toolConfigurationFilePath: $toolConfigurationFilePath
                artifactsRepositoryId: $artifactsRepositoryId
                buildStrategy: ${strategies.find { it instanceof BuildStrategy }}
                testStrategy: ${strategies.find { it instanceof TestStrategy }}
                publishStrategy: ${strategies.find { it instanceof PublishStrategy }}
                deployStrategy: ${strategies.find { it instanceof DeployStrategy }}
                undeployStrategy: ${strategies.find { it instanceof UndeployStrategy }}
                rollbackStrategy: ${strategies.find { it instanceof RollbackStrategy }}            
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ProjectTool(
                id: id,
                name: name,
                version: version,
                cache: cache,
                toolConfigurationFilePath: toolConfigurationFilePath,
                artifactsRepositoryId: artifactsRepositoryId,
                strategies: strategies.collect {
                    it.clone()
                }
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ScannerToolModel.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable

class ScannerToolModel implements ProjectDescriptorModel, Identifiable {
    String id
    String name
    String description
    String command
    Metadata metadata

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            description: description,
            command: command,
            metadata: metadata
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """            
              - id: $id
                name: $name
                description: $description
                command: $command
                metadata: $metadata            
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ScannerToolModel(
            id: id,
            name: name,
            description: description,
            command: command,
            metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/ScannerToolResult.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable

class ScannerToolResult implements ProjectDescriptorModel, Identifiable {
    String id = ''
    String name = ''
    boolean isFailure = false
    boolean isBlockingFailure = false
    Metadata metadata = new Metadata()

    @Override
    Map<String, Object> toMap() {
        return [
                name              : name,
                isFailure         : isFailure,
                isBlockingFailure : isBlockingFailure,
                metadata          : metadata,
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
        ScannerToolResult {
                id: ${id},
                name: ${name},
                isFailure: ${isFailure},
                isBlockingFailure: ${isBlockingFailure},
                metadata: ${metadata}
            }"""
    }

    @NonCPS
    @Override
    Object clone() {
        return new ScannerToolResult(
                id               : id,
                name             : name,
                isFailure        : isFailure,
                isBlockingFailure: isBlockingFailure,
                metadata         : metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/SourceRepository.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Identifiable



class SourceRepository implements ProjectDescriptorModel, Identifiable {
    String id = ''
    String name = ''
    String url = ''
    String branch = ''
    String email = ''
    String userName = ''
    String credentialsId = ''
    Metadata metadata = new Metadata()

    Map toMap() {
        return [
                id           : id,
                name         : name,
                url          : url,
                branch       : branch,
                email        : email,
                userName     : userName,
                credentialsId: credentialsId,
                metaData     : metadata.toMap()
        ]
    }

    String projectIdOrPathFromUrl() {
        def projectPathRegex = ~/(?:https?:\/\/[^\/]+\/|.*?\/projects\/)(.+?)(?:\.git)?$/

        def projectPathMatcher = url =~ projectPathRegex
        if (projectPathMatcher.find()) {
            String projectPath = projectPathMatcher.group(1)
            return projectPath
        } else {
            return ''
        }
    }

    @NonCPS
    @Override
    String toString() {
        return """
            sourceRepository:
                id: $id
                name: $name
                url: $url
                branch: $branch
                email: $email
                userName: $userName
                credentialsId: $credentialsId
                metaData: $metadata
            
        """
    }

    static SourceRepository fromMap(Map map) {
        return new SourceRepository(
                id           : map.id,
                name         : map.name,
                url          : map.url,
                branch       : map.branch,
                email        : map.email,
                userName     : map.userName,
                credentialsId: map.credentialsId,
                metadata: map.metadata
        )
    }

    @NonCPS
    @Override
    Object clone() {
        return new SourceRepository(
                id           : id,
                name         : name,
                url          : url,
                branch       : branch,
                email        : email,
                userName     : userName,
                credentialsId: credentialsId,
                metadata     : metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/StructuredResourceMetadata.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.DataModel

class StructuredResourceMetadata implements DataModel {
    String name = ''
    String namespace = ''
    Map<String, String> labels = [:]
    Map<String, String> annotations = [:]


    @NonCPS
    @Override
    String toString() {
        return """                      
            name       : $name,
            namespace  : $namespace,
            labels     : $labels,
            annotations: $annotations
        """
    }

    @Override
    Map<String, Object> toMap() {
        return [
                name       : name,
                namespace  : namespace,
                labels     : labels,
                annotations: annotations
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new StructuredResourceMetadata(
                name: name,
                namespace: namespace,
                labels: labels,
                annotations: annotations
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/project/VendorService.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.interfaces.Derivable
import es.giss.framework.core.interfaces.Identifiable

class VendorService implements ProjectDescriptorModel, Identifiable, Derivable {
    protected String id = ''
    protected String name = ''
    protected String baseUrl = ''
    protected String credentialsId = ''
    String type = ''
    protected Metadata metadata = new Metadata()

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            baseUrl: baseUrl,
            credentialsId: credentialsId,
            type: type,
            metadata: metadata,
        ]
    }

    @NonCPS
    @Override
    String getType() {
        return type
    }

    @NonCPS
    @Override
    void setType(String type) {
        this.type = type
    }

    @NonCPS
    @Override
    String toString() {
        return """            
                id: $id
                name: $name
                baseUrl: $baseUrl
                credentialsId: $credentialsId
                type: $type            
                metadata: $metadata            
        """
    }


    @NonCPS
    @Override
    String getId() {
        return this.id
    }

    @NonCPS
    @Override
    void setId(String id) {
        this.id = id
    }

    @NonCPS
    @Override
    Object clone() {
        return new VendorService(
            id: id,
            name: name,
            baseUrl: baseUrl,
            credentialsId: credentialsId,
            metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/events/ReleaseEvent.groovy">
package es.giss.framework.core.vo.release.events

import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class ReleaseEvent extends CoreEvent<ReleaseModel> {
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/interfaces/ChangeType.groovy">
package es.giss.framework.core.vo.release.interfaces

interface ChangeType {
    String getType()
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/interfaces/IChangeSet.groovy">
package es.giss.framework.core.vo.release.interfaces

interface IChangeSet extends ReleaseModel {

    String getId() // git commit hash

    String getAuthor()

    String getEmail()

    String getMessage()

    String getDate()

    ChangeType getChangeType()

}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/interfaces/IGitCommit.groovy">
package es.giss.framework.core.vo.release.interfaces

import es.giss.framework.core.interfaces.Derivable

interface IGitCommit extends IChangeSet, Derivable {}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/interfaces/ReleaseModel.groovy">
package es.giss.framework.core.vo.release.interfaces

import es.giss.framework.core.events.interfaces.DataModel

interface ReleaseModel extends DataModel {}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/Approval.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class Approval implements ReleaseModel {
    String required
    String numReviewers

    @Override
    Map<String, Object> toMap() {
        return [
                required    : required,
                numReviewers: numReviewers
        ]
    }


    @NonCPS
    @Override
    String toString() {
        return """            
                required                 : $required
                numReviewers             : $numReviewers
        """
    }

    @NonCPS
    static Approval getDefault() {
        return new Approval(
                required: '',
                numReviewers: ''
        )
    }

    @NonCPS
    @Override
    Object clone() {
        return new Approval(
                required    : required,
                numReviewers: numReviewers
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/ApprovalRule.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.project.Metadata
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

class ApprovalRule implements ReleaseModel {
    String name = ""
    Metadata metadata = new Metadata()

    @Override
    Map<String, Object> toMap() {
        return [
                name    : name,
                metadata: metadata
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """  
            {
                name: $name,             
                metadata: $metadata
            }
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ApprovalRule(
                name    : name,
                metadata: metadata
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/Artifact.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.project.ArtifactType
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

import java.nio.file.Path

class Artifact implements ReleaseModel {
    String id = ''
    String name = ''
    String version = ''// Calculated
    String url = '' // Calculated
    Path localPath = Path.of('')
    String description = ''
    String idRepository = ''
    ArtifactType type = new ArtifactType()

    @NonCPS
    @Override
    Map<String, Object> toMap() {
        return [
                id          : id,
                name        : name,
                version     : version,
                url         : url,
                localPath   : localPath,
                description : description,
                idRepository: idRepository,
                type        : type.toMap() ?: [:]
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
        Id: ${id}
        Name: ${name}
        SemanticVersion: ${version}
        Url: ${url}
        LocalPath: ${localPath.toString()}
        Description: ${description}
        IdRepository: ${idRepository}
        Type: ${type}
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new Artifact(
                id          : id,
                name        : name,
                version     : version,
                url         : url,
                localPath   : localPath,
                description : description,
                idRepository: idRepository,
                type        : type.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/Changelog.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.IChangeSet
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class Changelog implements ReleaseModel {
    List<IChangeSet> changes = []
    IChangeSet currentChangeSet = new GitCommitContext()

    IChangeSet getChanges(String id) {
        changes.find { it.id == id }
    }

    @Override
    Map<String, Object> toMap() {
        return [
                currentChangeSet: currentChangeSet.toMap(),
                changeSets: changes.collect { it.toMap() },
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new Changelog(
                changes: changes.collect { it.clone() },
                currentChangeSet: currentChangeSet.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/CodeReviewer.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class CodeReviewer implements ReleaseModel {
    String name = ''
    String email = ''

    @Override
    Map<String, Object> toMap() {
        return [
                name: name,
                email: email
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new CodeReviewer(
                name: name,
                email: email
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/ConventionalCommit.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.DataModel
import es.giss.framework.core.vo.release.interfaces.ChangeType
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

enum ConventionalCommit implements ChangeType, ReleaseModel {
    FEAT("feat"),
    FIX("fix"),
    DOCS("docs"),
    STYLE("style"),
    REFACTOR("refactor"),
    PERF("perf"),
    TEST("test"),
    CHORE("chore"),
    REVERT("revert"),
    BREAKING_CHANGE("breaking change"),
    CI("ci"),
    UNKNOWN("unknown")

    private final String type

    ConventionalCommit(String type) {
        this.type = type
    }

    @NonCPS
    @Override
    String getType() {
        return type
    }

    @NonCPS
    static ConventionalCommit fromMessage(String message) {
        try {
            String lowerMessage = message.toLowerCase()

            // Check for breaking change first
            if (lowerMessage.contains("breaking change") || lowerMessage.contains("!:")) {
                return BREAKING_CHANGE
            }

            // Check for other types
            for (ConventionalCommit commit : values()) {
                if (commit != UNKNOWN && commit != BREAKING_CHANGE) {
                    if (lowerMessage.startsWith(commit.type + ":") || lowerMessage.startsWith(commit.type + "(")) {
                        return commit
                    }
                }
            }
        } catch (Exception e) {
            // Ignore
        }
        // If no match found, return UNKNOWN
        return UNKNOWN
    }

    @Override
    String toString() {
        return type
    }

    @Override
    Map<String, Object> toMap() {
        return [
                type: type
        ]
    }

}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/DeployEnvironment.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

enum DeployEnvironment implements ReleaseModel {
    UNKNOWN('unk'),
    INTEGRATION("int"),
    CERTIFICATION("cer"),
    PREPRODUCTION("pre"),
    PRODUCTION("pro"),
    FORMATION("for"),
    LABORATORY("lab")

    private final String environment

    private DeployEnvironment(String environment) {
        this.environment = environment
    }

    String getDeployEnvironment() {
        return environment
    }

    static DeployEnvironment fromString(String deployEnvironment) {
        return values().find { it.deployEnvironment.equalsIgnoreCase(deployEnvironment) }
    }

    @NonCPS
    static List<String> getEnvironments() {
        return values().collect { it.environment }
    }

    @NonCPS
    @Override
    String toString() {
        return environment
    }

    // Mtodo para obtener los ambientes superiores, incluyendo el actual
    List<String> getUpperEnvironments() {
        def orderedEnvs = [INTEGRATION, CERTIFICATION, PREPRODUCTION, PRODUCTION]
        def specialEnvs = [FORMATION, LABORATORY, UNKNOWN]

        if (specialEnvs.contains(this)) {
            return [this.environment]
        }

        def currentIndex = orderedEnvs.indexOf(this)
        if (currentIndex == -1) {
            return [this.environment]
        }

        return orderedEnvs[currentIndex..-1].collect { it.environment }
    }

    @Override
    Map<String, Object> toMap() {
        return [
                deployEnvironment: environment
        ]
    }


}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/GitCommit.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ChangeType
import es.giss.framework.core.vo.release.interfaces.IGitCommit
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

class GitCommit implements IGitCommit,  ReleaseModel {
    String hash = ''
    String author = ''
    String email = ''
    ChangeType changeType = ConventionalCommit.UNKNOWN
    String date = ''
    String message = ''
    List<String> tags = []
    List<String> branches = []
    String type = GitCommit.class.simpleName

    static GitCommit fromOutput(String commitString) {
        def lines = commitString?.trim().split('\n')

        if (lines.size() < 6) {
            throw new IllegalArgumentException("Invalid git log output: not enough lines")
        }

        def commit = new GitCommit(
                hash: lines[0]?.trim(),
                author: lines[1]?.trim(),
                email: lines[2]?.trim(),
                date: lines[3]?.trim()
        );

        commit.extractRefs(lines[4]?.trim())

        // El mensaje comienza despus de MESSAGE_START
        int messageStartIndex = lines.findIndexOf { it.contains('MESSAGE_START') }
        if (messageStartIndex >= 0 && messageStartIndex < lines.size() - 1) {
            commit.message = lines[(messageStartIndex + 1)..-1].join('\n').replace('COMMIT_END','').trim()
        } else {
            commit.message = lines[5].trim() // Si no hay MESSAGE_START, asumimos que el mensaje est en la lnea 6
        }
        // Determinar el tipo de cambio basado en el mensaje
        commit.changeType = ConventionalCommit.fromMessage(commit.message)
        return commit
    }

    private void extractRefs(String refNames) {
        if (refNames && !refNames.trim().isEmpty()) {
            def refs = refNames.split(',').collect { it.trim() };
            refs.each { ref ->
                if (ref.startsWith('tag: ')) {
                    tags.add(ref.replace('tag: ', ''));
                } else if (ref.startsWith('HEAD -> ')) {
                    branches.addAll(ref.replace('HEAD -> ', '').split(', '));
                } else if (!ref.startsWith('origin/')) {
                    branches.add(ref);
                }
            }
        }
        // Si no hay branches despus de procesar, aadimos una rama "unknown"
        if (branches.isEmpty()) {
            branches.add("unknown");
        }
    }


    @NonCPS
    @Override
    String toString() {
        return """ 
            Commit Hash: ${hash}           
            Author: ${author}
            Email: ${email}
            Change Type: ${changeType?.type?.toString()?: 'Unknown'}
            Date: ${date}   
            Message: <"${message}"> 
            Tags: ${tags}
            Branches: ${branches}
      """;
    }

    @Override
    String getId() {
        return this.hash
    }

    @Override
    Map<String, Object> toMap() {
        return [
                hash      : hash,
                author    : author,
                email     : email,
                changeType: changeType.type.toString(),
                date      : date,
                message   : message,
                tags      : tags,
                branches  : branches

        ]

    }

    @NonCPS
    @Override
    Object clone() {
        return new GitCommit(
                hash      : hash,
                author    : author,
                email     : email,
                changeType: changeType,
                date      : date,
                message   : message,
                tags      : tags,
                branches  : branches
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/GitCommitContext.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ChangeType
import es.giss.framework.core.vo.release.interfaces.IGitCommit
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

class GitCommitContext implements IGitCommit, ReleaseModel {
    String currentTag = ''
    String jobBaseName = ''
    String hash = ''
    String shortHash = ''
    String author = ''
    String email = ''
    String date = ''
    String subject = ''
    String message = ''
    Set<String> tags = [] as Set
    String branch = ''
    String mergeOriginBranch = ''
    ChangeType changeType = ConventionalCommit.UNKNOWN
    String type = GitCommitContext.class.simpleName


    boolean isProductionReady() {
        return (branch.contains('master') || branch.contains('main')) && tags.any { it ==~ /\d+\.\d+\.\d+$/ } && jobBaseName ==~ /\d+\.\d+\.\d+$/
    }

    boolean isProduction() {
        return (branch.contains('master') || branch.contains('main')) && !(tags.any { it ==~ /\d+\.\d+\.\d+$/ })
    }

    boolean isRelease() {
        return branch.contains('release/') && tags.any { it.endsWith('-RELEASE') } && tags.any { it.endsWith('-RC') }  && jobBaseName ==~ /\d+\.\d+\.\d+-RELEASE$/
    }


    boolean isHotfix() {
        return tags.any { it.endsWith('-hotfix') || it.endsWith('-HOTFIX') } && branch.contains('hotfix/')
    }

    boolean isReleaseCandidate() {
        return branch.contains('release/') && tags.any { it.endsWith('-RC') } && !tags.any { it.endsWith('-RELEASE') } && jobBaseName ==~ /\d+\.\d+\.\d+-RC$/
    }


    boolean isDevelop() {
        return (branch.contains('develop') || branch.contains('development/')) && tags.any { it.endsWith('-SNAPSHOT') }
    }


    boolean isFeature() {
        return branch.contains('feature/') || branch.contains('feat/')
    }

    SemanticVersion getTagVersion() {
        if(currentTag) {
            return SemanticVersion.fromString(currentTag)
        }
        GitflowPhase phase = getGitflowPhase()
        String tagVersion = null

        // Definir el orden de prioridad general de los tags (ms prximo a produccin primero)
        def generalPriorities = [{ it ==~ /\d+\.\d+\.\d+$/ },              // Release version (e.g., 1.2.3)
                                 { it.endsWith('-RELEASE') },              // Release tag
                                 { it.endsWith('-hotfix') || it.endsWith('-HOTFIX') }, // Hotfix tag
                                 { it.endsWith('-RC') },                   // Release Candidate tag
                                 { it.endsWith('-SNAPSHOT') },             // Snapshot tag
                                 { it.endsWith('-FEATURE') }               // Feature tag
        ]

        // Definir el orden de prioridad de los tags para cada fase
        def tagPriorities = [(GitflowPhase.MASTER)           : generalPriorities,
                             (GitflowPhase.RELEASE)          : [{ it.endsWith('-RELEASE') },
                                                                { it.endsWith('-RC') },
                                                                { it.endsWith('-SNAPSHOT') }] + generalPriorities,
                             (GitflowPhase.HOTFIX)           : [{ it.endsWith('-hotfix') || it.endsWith('-HOTFIX') },
                                                                { it.endsWith('-SNAPSHOT') }] + generalPriorities,
                             (GitflowPhase.RELEASE_CANDIDATE): [{ it.endsWith('-RC') },
                                                                { it.endsWith('-SNAPSHOT') }] + generalPriorities,
                             (GitflowPhase.DEVELOP)          : [{ it.endsWith('-SNAPSHOT') }] + generalPriorities,
                             (GitflowPhase.FEATURE)          : [{ it.endsWith('-SNAPSHOT') },
                                                                { it.endsWith('-FEATURE') }] + generalPriorities]

        // Seleccionar las prioridades basadas en la fase, o usar las prioridades generales si es invlido
        def prioritiesToUse = tagPriorities[phase] ?: generalPriorities

        // Buscar el tag con la prioridad ms alta
        for (def tagCheck in prioritiesToUse) {
            tagVersion = tags.find(tagCheck)
            if (tagVersion) break
        }

        // Si no se encuentra ningn tag, usar '0.0.0'
        if (tagVersion == null) {
            tagVersion = '0.0.0'
        }

        return SemanticVersion.fromString(tagVersion)
    }


    GitflowPhase getGitflowPhase() {
        if (isProductionReady()) {
            return GitflowPhase.PRODUCTION_READY
        } else if (isProduction()) {
            return GitflowPhase.MASTER
        } else if (isHotfix()) {
            return GitflowPhase.HOTFIX
        } else if (isRelease()) {
            return GitflowPhase.RELEASE
        } else if (isReleaseCandidate()) {
            return GitflowPhase.RELEASE_CANDIDATE
        } else if (isDevelop()) {
            return GitflowPhase.DEVELOP
        } else if (isFeature()) {
            return GitflowPhase.FEATURE
        } else {
            return GitflowPhase.INVALID
        }
    }

    @NonCPS
    @Override
    String toString() {
        return """
            GitCommitContext {
               currentTag: ${currentTag}
               jobBaseName: ${jobBaseName}
               hash: ${hash}
               shortHash: ${shortHash}
               author: ${author}
               email: ${email} 
               date: ${date}
               subject: ${subject}              
               tags: ${tags}   
               branches: ${branch}
               mergeOriginBranch: ${mergeOriginBranch}
               changeType: ${changeType?.type?.toString() ?: 'Unknown'}
               message: ${message ? message.substring(0, Math.min(30, message.length())) : ''}
            }"""
    }

    @Override
    String getId() {
        return this.hash
    }

    @Override
    Map<String, Object> toMap() {
        return [currentTag   : currentTag,
                jobBaseName: jobBaseName,
                hash      : hash,
                shortHash : shortHash,
                author    : author,
                email     : email,
                date      : date,
                subject   : subject,
                tags      : tags,
                branch    : branch,
                mergeOriginBranch: mergeOriginBranch,
                changeType: changeType.type.toString(),
                message   : message ? message.substring(0, Math.min(100, message.length())) : '',
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new GitCommitContext(
                currentTag: currentTag,
                jobBaseName: jobBaseName,
                hash: hash,
                shortHash: shortHash,
                author: author,
                email: email,
                date: date,
                subject: subject,
                tags: tags,
                branch: branch,
                mergeOriginBranch: mergeOriginBranch,
                changeType: changeType,
                message: message
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/GitflowPhase.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

enum GitflowPhase implements ReleaseModel {
    FEATURE,
    DEVELOP,
    RELEASE,
    RELEASE_CANDIDATE,
    HOTFIX,
    MASTER,
    INVALID,
    PRODUCTION_READY

    String getPhase() {
        return this.name().toLowerCase()
    }

    @NonCPS
    @Override
    String toString() {
        return this.name()
    }

    static GitflowPhase getPhase(String phase) {
        return GitflowPhase.valueOf(phase.toUpperCase())
    }

    ReleasePromotion getReleasePromotion() {
        ReleasePromotion environmentPromotion = new ReleasePromotion()
        switch (this) {
            case FEATURE:
                environmentPromotion.toEnvironment = DeployEnvironment.INTEGRATION
                break
            case DEVELOP:
                environmentPromotion.toEnvironment = DeployEnvironment.INTEGRATION
                break
            case RELEASE_CANDIDATE:
                environmentPromotion.toEnvironment = DeployEnvironment.CERTIFICATION
                break
            case RELEASE:
                environmentPromotion.toEnvironment = DeployEnvironment.PREPRODUCTION
                break
            case HOTFIX:
            case MASTER:
            case PRODUCTION_READY:
                environmentPromotion.toEnvironment = DeployEnvironment.PRODUCTION
                break
            default:
                environmentPromotion.toEnvironment = DeployEnvironment.UNKNOWN
                break
        }
        return environmentPromotion
    }

    @Override
    Map<String, Object> toMap() {
        return [
                phase: this.getPhase()
        ]

    }

}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/GitlabUser.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class GitlabUser implements ReleaseModel {
    String id = ''
    String name = ''
    String gu = ''


    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                gu: gu
        ]
    }

    @NonCPS
    @Override
    Object clone() {
        return new GitlabUser(
                id: id,
                name: name,
                gu: gu
        )
    }

    @NonCPS
    @Override
    String toString() {
        return "id: " + id + ", name: " + name+ ", gu: " + gu
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/MergeRequest.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class MergeRequest implements ReleaseModel {
    Boolean enabled = false
    String iid = ''
    String sourceBranch = ''
    String targetBranch = ''
    GitlabUser mergeUser = new GitlabUser()
    List<GitlabUser> approvedBy = []
    GitlabUser mergedBy = new GitlabUser()
    String mergeCommitSha = ''
    String description = ''
    String date = ''
    String state = ''



    @Override
    Map<String, Object> toMap() {
        return [
                enabled             : enabled,
                iid                 : iid,
                sourceBranch        : sourceBranch,
                targetBranch        : targetBranch,
                mergeUser           : mergeUser.toMap(),
                approvedBy          : approvedBy.collect { it.toMap() },
                mergedBy            : mergedBy.toMap(),
                mergeCommitSha      : mergeCommitSha,
                description         : description,
                date                : date,
                state               : state
        ]
    }


    @NonCPS
    @Override
    String toString() {
        return """            
                enabled             : $enabled
                iid                 : $iid
                sourceBranch        : $sourceBranch
                targetBranch        : $targetBranch
                mergeUser           : $mergeUser            
                approvedBy          : $approvedBy
                mergedBy            : $mergedBy
                mergeCommitSha      : $mergeCommitSha
                description         : $description
                date                : $date
                state               : $state          
        """
    }

    @NonCPS
    static MergeRequest getDefault(){
        return new MergeRequest(
                enabled             : false,
                targetBranch        : '',

        )
    }

    @NonCPS
    @Override
    Object clone() {
        return new MergeRequest(
                enabled             : enabled,
                targetBranch        : targetBranch,
                mergedBy            : mergedBy.clone()
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/ReleaseConfig.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.Identifiable
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

class ReleaseConfig extends HashMap<String, Object> implements Identifiable, ReleaseModel {


    @NonCPS
    @Override
    Map<String, Object> toMap() {
        return this as Map<String, Object>
    }

    @NonCPS
    @Override
    String getId() {
        return this.get('id')
    }

    @NonCPS
    @Override
    void setId(String id) {
        this.put('id', id)
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/ReleaseDescriptor.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.StructuredResource
import es.giss.framework.core.vo.project.StructuredResourceMetadata
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


class ReleaseDescriptor implements StructuredResource, ReleaseModel {
    String kind = 'ReleaseDescriptor'
    String apiVersion = 'release.giss.es/v1'
    StructuredResourceMetadata metadata = new StructuredResourceMetadata()
    ReleaseSpec spec = new ReleaseSpec()
    ReleaseStatus status = new ReleaseStatus()

    @Override
    Map<String, Object> toMap() {
        return [
                kind      : kind,
                apiVersion: apiVersion,
                metadata  : metadata,
                spec      : spec.toMap(),
                status    : status.toMap()
        ]
    }

    @Override
    String apiVersion() {
        return this.apiVersion
    }

    @Override
    def status() {
        return this.status
    }

    @NonCPS
    @Override
    String toString() {
        return """            
                kind         : $kind
                apiVersion   : $apiVersion
                metadata     : $metadata
                spec         : $spec
                status       : $status
            }
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ReleaseDescriptor(
                kind      : kind,
                apiVersion: apiVersion,
                metadata  : metadata,
                spec      : spec,
                status    : status
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/ReleasePromotion.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

class ReleasePromotion implements ReleaseModel {
    DeployEnvironment toEnvironment = DeployEnvironment.UNKNOWN
    String promotionDate = LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"))
    CodeReviewer codeReviewer = new CodeReviewer()
    String comments = ''

    @Override
    Map<String, Object> toMap() {
        return [
                toEnvironment     : toEnvironment,
                promotionDate     : promotionDate,
                codeReviewer      : codeReviewer.toMap(),
                comments          : comments
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """
            ReleasePromotion {
                toEnvironment: ${toEnvironment},
                promotionDate: ${promotionDate},
                codeReviewer: ${codeReviewer},
                comments: ${comments}
            }
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ReleasePromotion(
                toEnvironment     : toEnvironment,
                promotionDate     : promotionDate,
                codeReviewer      : codeReviewer.clone(),
                comments          : comments
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/ReleaseStatus.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel

class ReleaseStatus implements ReleaseModel {
    List<String> errors = []

    @Override
    Map<String, Object> toMap() {
        return [
                errors: errors
        ]
    }

    @NonCPS
    @Override
    String toString() {
        return """            
            ReleaseStatus {
                errors: ${errors}
            }
        """
    }

    @NonCPS
    @Override
    Object clone() {
        return new ReleaseStatus(
                errors: errors
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/release/SemanticVersion.groovy">
package es.giss.framework.core.vo.release

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.release.interfaces.ReleaseModel


/**
 * Representa una versin semntica siguiendo la especificacin de Semantic Versioning.
 */
class SemanticVersion implements Comparable<SemanticVersion>,  ReleaseModel {

    public static final GISS_SEMANTIC_VERSION_PATTERN = ~/\d+\.\d+\.\d*(-((\d*-SNAPSHOT)|SNAPSHOT|(RC|RELEASE|HOTFIX)))?/



    int major = 0  // Nmero de versin mayor
    int minor = 0  // Nmero de versin menor
    int patch = 0  // Nmero de parche
    int build = 1  // El nmero de compilacin por defecto es 1
    String buildSuffix = '' // Sufijo de compilacin (opcional) RC, RELEASE, HOTFIX, SNAPSHOT

    SemanticVersion() {
        major = 0
        minor = 0
        patch = 0
        build = 1
        buildSuffix = ''
    }


    /**
     * Constructor de la clase SemanticVersion.
     * @param major Nmero de versin mayor.
     * @param minor Nmero de versin menor.
     * @param patch Nmero de parche.
     * @param build Nmero de compilacin (opcional).
     * @param buildSuffix Sufijo de compilacin (opcional).
     */
    SemanticVersion(int major, int minor, int patch, int build = 1, String buildSuffix = '') {
        this.major = major
        this.minor = minor
        this.patch = patch
        this.build = build
        this.buildSuffix = buildSuffix
    }


    /**
     * Incrementa la versin mayor y reinicia minor y patch.
     * @return Nueva instancia de SemanticVersion con la versin mayor incrementada.
     */
    SemanticVersion incrementMajor() {
        return new SemanticVersion(major + 1, 0, 0, 1, buildSuffix)
    }

    /**
     * Incrementa la versin menor y reinicia patch.
     * @return Nueva instancia de SemanticVersion con la versin menor incrementada.
     */
    SemanticVersion incrementMinor() {
        return new SemanticVersion(major, minor + 1, 0, 1, buildSuffix)
    }

    /**
     * Incrementa la versin de parche.
     * @return Nueva instancia de SemanticVersion con el parche incrementado.
     */
    SemanticVersion incrementPatch() {
        return new SemanticVersion(major, minor, patch + 1, 1, buildSuffix)
    }

    /**
     * Incrementa el nmero de compilacin (build).
     * @return Nueva instancia de SemanticVersion con el build incrementado.
     */
    SemanticVersion incrementBuild() {
        return new SemanticVersion(major, minor, patch, build + 1, buildSuffix)
    }

    /**
     * Compara esta versin con otra versin.
     * @param other Otra instancia de SemanticVersion para comparar.
     * @return Negativo si this < other, cero si son iguales, positivo si this > other.
     */
    @NonCPS
    @Override
    int compareTo(SemanticVersion other) {
        int result = Integer.compare(this.major, other.major)
        if (result != 0) return result

        result = Integer.compare(this.minor, other.minor)
        if (result != 0) return result

        result = Integer.compare(this.patch, other.patch)
        if (result != 0) return result

        return Integer.compare(this.build, other.build)
    }




    @NonCPS
    @Override
    String toString() {
        return "${major}.${minor}.${patch}${buildSuffix? '-'+buildSuffix: ''}"
    }

    /**
     * Devuelve la representacin completa de la versin, incluyendo el build si es distinto de 1.
     * @return Cadena de texto con la versin completa.
     */
    @NonCPS
    String toFullString() {
        return "${major}.${minor}.${patch}-${build}${buildSuffix? '-'+buildSuffix: ''}"
    }

    @NonCPS
    String getFeatureVersion() {
        return "${major}.${minor}"
    }

    @NonCPS
    String getFixVersion() {
        return "${major}.${minor}.${patch}"
    }

    @NonCPS
    String getReleaseMaster() {
        return "${major}.${minor}.${patch}"
    }

    @NonCPS
    String getNonStatusVersion() {
        if (buildSuffix == 'SNAPSHOT' ) {
            return "${major}.${minor}.${patch}-${build}"
        } else {
            return getFixVersion()
        }
    }

    @NonCPS
    @Override
    boolean equals(Object o) {
        if (this.is(o)) return true
        if (!(o instanceof SemanticVersion)) return false
        SemanticVersion version = (SemanticVersion) o
        return major == version.major &&
                minor == version.minor &&
                patch == version.patch &&
                build == version.build &&
                buildSuffix == version.buildSuffix
    }

    @NonCPS
    @Override
    int hashCode() {
        return Objects.hash(major, minor, patch, build, buildSuffix)
    }

    static SemanticVersion fromString(String version) {
        if (!(version ==~ GISS_SEMANTIC_VERSION_PATTERN)) {
            throw new IllegalArgumentException("La cadena de texto no cumple el patrn de versin semntica: ${version}")
        }
        String[] parts = version.split(/[-.]/)
        int major = Integer.parseInt(parts[0])
        int minor = Integer.parseInt(parts[1])
        int patch = Integer.parseInt(parts[2])
        int build = 1
        String buildSuffix = ''

        if (parts.length > 3) {
            String lastPart = parts[3]
            if (lastPart ==~ /\d+/) {
                build = Integer.parseInt(lastPart)
                if (parts.length > 4) {
                    buildSuffix = parts[4]
                }
            } else {
                buildSuffix = lastPart
            }
        }

        new SemanticVersion(major, minor, patch, build, buildSuffix)
    }

    @Override
    Map<String, Object> toMap() {
        return [
                major       : major,
                minor       : minor,
                patch       : patch,
                build       : build,
                buildSuffix : buildSuffix
        ]
    }

    @NonCPS
    public static SemanticVersion getDefault() {
        return new SemanticVersion(0, 0, 0, 1, '')
    }

    @NonCPS
    @Override
    Object clone() {
        return new SemanticVersion(major, minor, patch, build, buildSuffix)
    }

    boolean isFinal() {
        this.toString() ==~ /\d+\.\d+\.\d+$/
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/resources/http/FormDataCollection.groovy">
package es.giss.framework.core.vo.resources.http

import com.cloudbees.groovy.cps.NonCPS

import java.nio.file.Path

class FormDataCollection {
    Map<String, Path> files
    Map<String, Object> data

    @NonCPS
    @Override
    String toString() {
        List<String> postData = []
        data.each { key, value ->
            postData.add("${key}=${value}")
        }

        files.each { key, path ->
            postData.add("${key}@${path}")
        }
        return postData.join(' ')

    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/resources/http/HttpResponse.groovy">
package es.giss.framework.core.vo.resources.http

import com.cloudbees.groovy.cps.NonCPS
import groovy.json.JsonSlurperClassic


class HttpResponse {
    Integer statusCode
    Map headers
    String body

    @NonCPS
    @Override
    String toString() {
        return "status_code: ${statusCode}, response: ${body}"
    }

    @NonCPS
    Object parseJsonBody() {
        return new JsonSlurperClassic().parseText(body as String)
    }

    Object parseJsonBody(steps) {
        return steps.readJSON(text: body as String)
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/resources/http/RequestOptions.groovy">
package es.giss.framework.core.vo.resources.http

class RequestOptions {
    Map<String, Serializable> headers
    String clientCertPath
    String clientKeyPath
    List<Integer> checkStatusCodes
    Boolean ignoreSslErrors = false
    Boolean followRedirects = true
    Boolean printCommand = null // null to use the default value in HTTPieTool
    Boolean logResponse = false
    Boolean mapJsonBody = false
    String saveResponseBodyToFile
    Integer timeout = 30
    FormDataCollection formDataCollection
}
</file>

<file path="bin/main/es/giss/framework/core/vo/CollectionResources.groovy">
package es.giss.framework.core.vo

import es.giss.framework.core.interfaces.StructuredResource
import es.giss.framework.core.vo.project.Metadata
import es.giss.framework.core.vo.project.StructuredResourceMetadata

class CollectionResources implements StructuredResource {
    String apiVersion
    String kind
    StructuredResourceMetadata metadata = new StructuredResourceMetadata()
    List<StructuredResource> items

    @Override
    String apiVersion() {
        return this.apiVersion
    }

    @Override
    def getSpec() {
        return [items: this.items.collect { it.toMap() }]
    }

    @Override
    def status() {
        return this.items
    }

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion: this.apiVersion,
                kind      : this.kind,
                metadata  : this.metadata.toMap(),
                spec      : this.getSpec(),
        ]
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/ConfigToolFileStrategy.groovy">
package es.giss.framework.core.vo

import es.giss.framework.core.PipelineContext

import java.nio.file.Path

interface ConfigToolFileStrategy {
    Path resolveConfigFile(PipelineContext context)
}
</file>

<file path="bin/main/es/giss/framework/core/vo/GenericResource.groovy">
package es.giss.framework.core.vo

import es.giss.framework.core.interfaces.StructuredResource
import es.giss.framework.core.vo.project.StructuredResourceMetadata

class GenericResource implements StructuredResource {
    String apiVersion
    String kind
    StructuredResourceMetadata metadata = new StructuredResourceMetadata()
    Map<String, Object> spec
    Map<String, Object> status

    @Override
    String apiVersion() {
        return this.apiVersion
    }

    @Override
    def status() {
        return this.status
    }

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion: this.apiVersion,
                kind      : this.kind,
                metadata  : this.metadata.toMap(),
                spec      : this.spec,
                status    : this.status
        ]
    }
}
</file>

<file path="bin/main/es/giss/framework/core/vo/WatchFiles.groovy">
package es.giss.framework.core.vo

class WatchFiles {
    List<String> inclusions
    List<String> exclusions
}
</file>

<file path="bin/main/es/giss/framework/core/GitStages.groovy">
package es.giss.framework.core

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IGitService
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.vo.project.SourceRepository

@PipelineComponent
class GitStages extends Stage implements IGitService {

    IGitTool gitTool

    GitStages(IGitTool gitTool) {
        this.gitTool = gitTool
    }

    @Override
    void cloneInAgent() {
        stage('Clone in Agent') {
            boolean result = gitTool.cloneInAgent()
            SourceRepository defaultRepository = gitTool.getDefaultSourceRepository()
            if (!result) {

                throw new Exception("Error cloning in agent with url: ${defaultRepository.url} and reference: ${defaultRepository.branch} and credentialsId: ${defaultRepository.credentialsId}")
            }
            logger.debug("Cloned in agent with url: ${defaultRepository.url} and reference: ${defaultRepository.branch} and credentialsId: ${defaultRepository.credentialsId} in WORKSPACE: ${steps.env.WORKSPACE}")
        }
    }

    @Override
    void cloneInAgent(String url,
                      String reference,
                      String credentialsId = '',
                      String cloneDir = '.',
                      Boolean shallowClone = false) {
        stage('Clone in Agent') {
            boolean result = gitTool.cloneInAgent(url, reference)
            if (!result) {
                throw new Exception("Error cloning in agent with url: ${url} and reference: ${reference} and credentialsId: ${credentialsId} and cloneDir: ${cloneDir} and shallowClone: ${shallowClone}")
            }
        }
    }


}
</file>

<file path="bin/main/es/giss/framework/core/PipelineContext.groovy">
package es.giss.framework.core

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.dependencies.DependencyResolver
import es.giss.framework.core.cdi.dependencies.IDependencyResolver
import es.giss.framework.core.cdi.scanner.ClassesInPackageScanner
import es.giss.framework.core.events.CoreEvent
import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.events.ProjectEvent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.events.interfaces.DataModel
import es.giss.framework.core.events.interfaces.PipelineModel
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.interfaces.*
import es.giss.framework.core.logger.Logger
import es.giss.framework.core.storage.ObjectCreator
import es.giss.framework.core.storage.ObjectMerger
import es.giss.framework.core.storage.Store
import es.giss.framework.core.storage.mutations.ObservabilityHubMutation
import es.giss.framework.core.storage.mutations.PipelineDefinitionMutation
import es.giss.framework.core.storage.mutations.ProjectDescriptorMutation
import es.giss.framework.core.storage.mutations.ReleaseDescriptorMutation
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.observability.ObservabilityHub
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.release.ReleaseDescriptor
import es.giss.framework.core.vo.release.events.ReleaseEvent
import es.giss.framework.core.vo.release.interfaces.ReleaseModel
import hudson.model.Cause

import java.nio.file.Path
import java.util.concurrent.atomic.AtomicReference

class PipelineContext implements IPipelineContext {

    public static String EPHEMERAL_TOKEN = ''
    private static def regexOcNamespace = /^[\w:\\/]+-(([\w]+)-([\w]+)-([\w]+)).[\w.]+/
    public static final List<String> DEFAULT_SCAN_PACKAGES = ['es.giss.framework']
    private ClassesInPackageScanner scanner
    private IDependencyResolver dependencyResolver

    private Set<String> skipStages = new HashSet()
    private Script steps
    private Boolean autoCancelled
    private Boolean isDebuggable
    private Set<Class<?>> scannedComponents

    private Map<Class<? extends StructuredResource>, Store> storeMap = [:]

    private ILogger logger
    private IWorkspaceTool workspaceTool
    private AtomicReference<String> atomicCurrentStage = new AtomicReference<>()

    PipelineContext(Script steps) {
        this.steps = steps
        this.scanner = new ClassesInPackageScanner()
        this.dependencyResolver = new DependencyResolver()
        this.skipStages = new HashSet<>()
        logger = new Logger(steps)
    }

    @NonCPS
    @Override
    Class<?> findClassBySimpleName(String packageName = DEFAULT_SCAN_PACKAGES.first(), String simpleName) {
        // Usamos el scanner esttico
        Set<Class<?>> classes = scanner.findImplementers(packageName, Derivable.class)
        // Filtramos la clase cuyo simpleName coincida
        return classes.find { it?.simpleName == simpleName }
    }

    @NonCPS
    @Override
    void registerComponentsFromPackages(List<String> packageNames = DEFAULT_SCAN_PACKAGES) {
        packageNames.each { packageName ->
            this.scannedComponents = scanner.findAnnotatedClasses(packageName, PipelineComponent)
            registerAll(scannedPipelineComponents, packageName)
        }

        dependencyResolver.registerCoreComponent(Script.class, steps)
        dependencyResolver.registerCoreComponent(IPipelineContext.class, this)
        dependencyResolver.initialize()

    }

    @NonCPS
    private void registerAll(Set<Class<?>> componentClass, String packageName) {
        componentClass.each { serviceClass ->
            def interfaces = filterInstances(serviceClass, packageName)

            if (interfaces.size() == 0) {
                registerPipelineComponent(serviceClass, serviceClass)
            }

            interfaces.each { interfaceClass ->
                registerPipelineComponent(interfaceClass, serviceClass)
            }
        }
    }

    @NonCPS
    private void registerPipelineComponent(Class<?> type, Class<?> serviceClass) {
        dependencyResolver.register(type, serviceClass)
    }

    @NonCPS
    private static List<Class<?>> filterInstances(Class<?> serviceClass, String packageName) {
        return serviceClass.interfaces.findAll { interfaceIt ->
            interfaceIt.name.startsWith(packageName) || DEFAULT_SCAN_PACKAGES.any {
                pkg -> interfaceIt.name.startsWith(pkg)
            }
        }
    }


    @NonCPS
    @Override
    def <T> T getComponent(Class<T> type, String name) {
        dependencyResolver.getInstance(type, name)
    }

    @NonCPS
    @Override
    def <T> T getComponent(Class<T> type) {
        return dependencyResolver.getInstance(type)
    }


    @Override
    void configureServicesByPriority() {
        IToolsManager toolsManager = getComponent(IToolsManager.class)
        this.configure()
        toolsManager.configure(this)
        def map = groupInstancesByPriority()
        [
                ConfigurationPriority.HIGHEST,
                ConfigurationPriority.HIGH,
                ConfigurationPriority.MEDIUM,
                ConfigurationPriority.LOW,
                ConfigurationPriority.LOWEST,

        ].each { priority ->
            map.get(priority).each { instance ->
                if (instance instanceof Configurable && !(instance instanceof IToolsManager)) {
                    (instance as Configurable).configure(this)
                }
            }
        }

    }

    @Override
    void setAutoCancelled(Boolean autoCancel) {
        autoCancelled = autoCancel
    }

    @Override
    boolean isAutoCancelled() {
        return autoCancelled
    }

    @Override
    void setDebugMode(boolean debugMode) {
        this.isDebuggable = debugMode
    }

    @Override
    boolean isDebugMode() {
        return isDebuggable
    }

    @Override
    Set<String> getSkipStages() {
        return skipStages
    }

    @Override
    void addSkipStage(String stage) {
        skipStages.add(stage)
    }

    @Override
    void injectEnvironmentVariables(Map<String, String> envVars) {
        def envs = steps.env
        envVars.each { k, v -> envs[k] = v }
    }

    @NonCPS
    @Override
    Map groupInstancesByPriority() {
        def finalSortedInstances = [
                (ConfigurationPriority.HIGHEST): [],
                (ConfigurationPriority.HIGH)   : [],
                (ConfigurationPriority.MEDIUM) : [],
                (ConfigurationPriority.LOW)    : [],
                (ConfigurationPriority.LOWEST) : [],
        ]

        dependencyResolver.getInstances().each { key, value ->
            def priority = key.priority
            if (priority == ConfigurationPriority.EXCLUDED) {
                return
            }
            finalSortedInstances.get(priority).add(value)
        }
        return finalSortedInstances
    }

    @NonCPS
    int getSizedInstances() {
        return dependencyResolver.getSizedInstances()
    }


    @Override
    void dispatch(CoreEvent event) {
        try {
            if (!event.payload) {
                steps.error("Payload is required in event ${event}")
            }
            switch (event.payload.getClass()) {
                case PipelineModel:
                    Store<PipelineDefinition> store = getStore(PipelineDefinition.class)
                    store.dispatch(event)
                    break
                case ProjectDescriptorModel:
                    Store<ProjectDescriptor> store = getStore(ProjectDescriptor.class)
                    store.dispatch(event)
                    break
                case TelemetryModel:
                    Store<ObservabilityHub> store = getStore(ObservabilityHub.class)
                    store.dispatch(event)
                    break
                case ReleaseModel:
                    Store<ReleaseDescriptor> store = getStore(ReleaseDescriptor.class)
                    store.dispatch(event)
                    break
                default:
                    logger.warn("Store not found for ${event.payload?.getClass()?.getSimpleName()} in dependency resolver")
            }
        } catch (Exception e) {
            logger.warn("ExceptionType:${e.getClass().simpleName} - ${e.message}")
            logger.warn("Error dispatching event ${event.getClass().simpleName} with payload type ${event.payload.getClass().simpleName} --> ${event.payload}. Error: ${e.getMessage()}")
        }

    }


    @Override
    void registerConfigAdaptersFromPackages(List<String> packageNames = DEFAULT_SCAN_PACKAGES) {
        packageNames.each { packageName ->
            Set<Class<IConfigAdapter>> componentClass = scanner.findImplementers(packageName, IConfigAdapter.class)
            logger.info('PipelineContext.registerConfigAdaptersFromPackages()', "Scanning for Config Adapters in package ${packageName} result: ${componentClass.collect { it.getSimpleName() }}")
            IConfigClient configClient = getComponent(IConfigClient.class)

            componentClass.collect { adapterClass ->
                PipelineComponent annotation = adapterClass.getAnnotation(PipelineComponent)
                String name = annotation?.name()
                IConfigAdapter componet = getComponent(IConfigAdapter.class, name)
                if (componet == null) {
                    steps.error("Config Adapter not found for ${adapterClass?.getSimpleName()} in dependency resolver")
                }
                componet
            }.each { adapter ->
                configClient.addAdapter(adapter)
            }
        }
    }

    @Override
    void registerDataModelsFromPackages(List<String> packageNames = DEFAULT_SCAN_PACKAGES) {
        packageNames.each { packageName ->
            Set<Class<Derivable>> componentClass = scanner.findImplementers(packageName, Derivable.class)
            componentClass.each { dataModelClass ->
                ObjectCreator.registerClass(dataModelClass.simpleName, dataModelClass)
                ObjectMerger.registerClass(dataModelClass.simpleName, dataModelClass)
            }
            logger.printPrettyLog(LogLevel.DEBUG, "Data Models registered in package ${packageName} -->", componentClass.collect { it.getSimpleName() })
        }
    }

    String resolveCacheDirectory(String cacheBaseDir) {
        String controllerName = resolveControllerName()
        if (controllerName) {
            Path.of(cacheBaseDir, resolveControllerName(), 'dependencies', splitJobPathInItems().join('/')) as String
        } else {
            Path.of(cacheBaseDir, 'dependencies', splitJobPathInItems().join('/')) as String
        }
    }

    private List<String> splitJobPathInItems() {
        String resolveName = steps.env.PIPELINE_NAME as String ?: steps.env.JOB_NAME as String
        def jobPathChunks = resolveName.tokenize('/')
        return isMultiBranchPipeline() ? jobPathChunks.dropRight(1) : jobPathChunks
    }

    String resolveControllerDomain() {
        String url = getControllerUrlBase()
        URI.create(url).getHost()
    }

    Boolean isMultiBranchPipeline() {
        def isMultiBranch = Boolean.FALSE
        try {
            // In a multibranch pipeline every build runs in a individual job definition, so we need to access to
            // its parent job to check if it's a multibranch pipeline
            isMultiBranch = steps.env?.BRANCH_NAME ? true : false
        } catch (ignored) {
            logger.warn("Error checking if it's a multibranch pipeline: ${ignored}")
        }
        return isMultiBranch
    }


    String resolveControllerName() {
        String url = getControllerUrlBase()
        logger.debug("Controller URL: ${url}")
        URI uri = new URI(url)
        String host = uri.getHost()
        return host
    }

    private String getControllerUrlBase() {
        return steps.env?.CONTROLLER_URL_BASE as String ?: steps.env.JENKINS_URL as String
    }

    private void clearCacheIfConfigured(Boolean forceClearCache, String cacheDir) {
        if (forceClearCache) {
            steps.sh "rm -fr ${cacheDir} || true"
            logger.debug("Cache directory ${cacheDir} has been removed")
        }
    }

    void createCacheFolders(Set<String> cacheFolders, String cacheDir) {
        def paths = cacheFolders.collect { Path.of(cacheDir, it).toString() } as List<String>
        if (paths) {
            workspaceTool.createDirectoriesIfNotExist(paths)
        }
    }

    void setEnvironmentWithVarsExpanded(String cacheDirExportEnvVar, Map<String, String> envVars, String cacheDir) {
        steps.env.setProperty(cacheDirExportEnvVar, cacheDir)
        def environment = steps.env.getEnvironment()
        Map<String, String> finalEnvVars = [:]
        envVars.each { k, v -> finalEnvVars.put(k, environment.expand(v as String)) }
        logger.debug("Environment variables to inject: ${finalEnvVars}")
        if (finalEnvVars) {
            injectEnvironmentVariables(finalEnvVars)
        }
    }

    String getEnvironment() {
        String devopsEnvironment = steps.env.DEVOPS_ENVIRONMENT
        if (devopsEnvironment) {
            return devopsEnvironment
        }
        String controllerDomain = resolveControllerDomain()
        def match = controllerDomain =~ regexOcNamespace
        if (match.matches() && match[0].size() > 2) {
            return match[0][2].substring(1).toUpperCase()
        } else {
            logger.warn("No environment found in controller domain")
            return ''
        }
    }

    String getAppNamespace() {
        String controllerDomain = resolveControllerDomain()
        def match = controllerDomain =~ regexOcNamespace
        if (match.matches() && match[0].size() > 4) {
            String appNamespace = match[0][4]
            return appNamespace
        } else {
            logger.warn("No app namespace found in controller domain")
            return ''
        }
    }


    @NonCPS
    @Override
    Store<? extends StructuredResource> getStore(Class<? extends StructuredResource> modelClass) {
        Store store = storeMap[modelClass] as Store<? extends StructuredResource>
        if (store == null) {
            steps.error("Store not found for ${modelClass?.getSimpleName()} in dependency resolver")
        }
        return store
    }

    @Override
    void addStore(Class<? extends StructuredResource> modelClass, Store<? extends StructuredResource> store) {
        storeMap.put(modelClass, store)
    }

    void initializePipelineDefaultStore(PipelineModel... models) {
        PipelineDefinition initState = PipelineDefinition.getDefault()

        initState.status.jobStatus.buildTrigger = getBuildTriggerCause()
        initState.spec.cache.baseDir = resolveCacheDirectory('/opt/cache')
        initState.status.jobStatus.buildNumber = steps.env.BUILD_NUMBER
        initState.status.jobStatus.buildUrl = steps.env.JENKINS_URL
        initState.spec.toolsManager.asdf.defaultDataDir = '/opt/cache/tools/.asdf-data'
        initState.spec.toolsManager.customScript.defaultDataDir = '/opt/cache/tools/.customscript-data'

        addStore(PipelineDefinition.class, new Store<PipelineDefinition>(initState))
        Store<PipelineDefinition> store = getStore(PipelineDefinition.class)
        store.addMutation(PipelineEvent.class, new PipelineDefinitionMutation())
        models.each { model ->
            store.dispatch(new PipelineEvent(description: "Initial PipelineDescriptor configuration", payload: model))
        }

    }

    void initializeProjectDescriptorStore(ProjectDescriptorModel... models) {
        addStore(ProjectDescriptor.class, new Store<ProjectDescriptor>(ProjectDescriptor.getDefault()))
        Store<ProjectDescriptor> store = getStore(ProjectDescriptor.class)
        store.addMutation(ProjectEvent.class, new ProjectDescriptorMutation())
        models.each { model ->
            store.dispatch(new ProjectEvent(description: "Initial ProjectDescriptor configuration", payload: model))
        }
    }

    void initializeTelemetryStore(TelemetryModel... models) {
        addStore(ObservabilityHub.class, new Store<ObservabilityHub>(new ObservabilityHub()))
        Store<ObservabilityHub> store = getStore(ObservabilityHub.class)
        store.addMutation(TelemetryEvent.class, new ObservabilityHubMutation())

    }

    void initializeReleaseStore(ReleaseModel... models) {
        addStore(ReleaseDescriptor.class, new Store<ReleaseDescriptor>(new ReleaseDescriptor()))
        Store<ReleaseDescriptor> store = getStore(ReleaseDescriptor.class)
        store.addMutation(ReleaseEvent.class, new ReleaseDescriptorMutation())
        models.each { model ->
            store.dispatch(new ReleaseEvent(description: "Initial ReleaseDescriptor configuration", payload: model))
        }
    }

    @Override
    void updateDataModels(DataModel... dataModels) {
        if (dataModels) {
            dataModels.each { model ->
                switch (model) {
                    case ProjectDescriptorModel:
                        dispatch(new ProjectEvent(payload: model))
                        break
                    case TelemetryModel:
                        dispatch(new TelemetryEvent(payload: model))
                        break
                    case PipelineModel:
                        dispatch(new PipelineEvent(payload: model))
                        break
                    case ReleaseModel:
                        dispatch(new ReleaseEvent(payload: model))
                        break
                }
            }
        }
    }

    Map modelDataToMap() {
        Map data = storeMap.collectEntries { k, v ->
            [(k.getSimpleName()): v.state.toMap()]
        }
        return data
    }

    @Override
    String getCurrentPipelineUserId() {
        def rawBuild = steps?.currentBuild?.rawBuild
        def cause = rawBuild?.getCause(Cause.UserIdCause)
                ?: rawBuild?.getCause(Cause.UpstreamCause)?.upstreamRun?.getCause(Cause.UserIdCause)

        if (cause) {
            def userId = cause.getUserId()
            logger.debug('PipelineContext.getCurrentPipelineUserId()', "Jenkins user id is ${userId}")
            return userId
        }
        logger.warn('PipelineContext.getCurrentPipelineUserId()','Jenkins user id cannot be determined')
        return steps?.currentBuild?.getBuildCauses()?.find { it instanceof Cause.UserIdCause }?.getUserId() ?: ''

    }


    @Override
    boolean isDevelopmentMode() {
        return steps.env.DEVELOPMENT_MODE?.toString()?.toLowerCase() == 'true' ?: false
    }

    @NonCPS
    @Override
    Set<Class<?>> getScannedPipelineComponents() {
        def set = new TreeSet<>({ a, b -> a.getName().compareTo(b.getName()) } as Comparator)
        set.addAll(this.scannedComponents)
        return set
    }

    @Override
    String getCurrentPipelineUserName() {
        def rawBuild = steps?.currentBuild?.rawBuild
        def cause = rawBuild?.getCause(Cause.UserIdCause)
                ?: rawBuild?.getCause(Cause.UpstreamCause)?.upstreamRun?.getCause(Cause.UserIdCause)

        if (cause) {
            def username = cause.getUserName()
            logger.debug('PipelineContext.getCurrentPipelineUserName()', "Jenkins username is ${username}")
            return username
        }
        return steps?.currentBuild?.getBuildCauses()?.find { it instanceof Cause.UserIdCause }?.getUserName() ?: ''
    }

    Map getBuildTriggerCause() {
        try {
            def causes = steps?.currentBuild?.getBuildCauses()
            if(!causes) {
                return [type: "UNKNOWN", detail: "Causa desconocida"]
            }
            for (cause in causes) {
                switch (cause._class) {
                    case 'hudson.model.Cause$UserIdCause':
                        return [type: "MANUAL", detail: "Iniciado por usuario: ${cause.userId}"]
                    case 'hudson.triggers.TimerTrigger$TimerTriggerCause':
                        return [type: "SCHEDULED", detail: "Iniciado por timer"]
                    case 'hudson.triggers.SCMTrigger$SCMTriggerCause':
                        return [type: "SCM", detail: "Iniciado por cambios en SCM"]
                    case 'org.jenkinsci.plugins.workflow.support.steps.build.BuildUpstreamCause':
                        return [type: "UPSTREAM", detail: "Iniciado por job upstream: ${cause.upstreamProject}"]
                    case 'hudson.triggers.RemoteCause':
                        return [type: "REMOTE", detail: "Iniciado remotamente"]
                    default:
                        return [type: "OTHER", detail: "Causa: ${cause._class}"]
                }
            }

        } catch (Exception e) {
            logger.warn("Error getting build trigger cause: ${e}")
        }
        return [type: "UNKNOWN", detail: "Causa desconocida"]
    }

    @Override
    void updateDataModelsFromMap(data) {

        Map pipelineMap = data.find { it -> it.kind == 'PipelineDefinition' }
        Map projectMap = data.find { it -> it.kind == 'ProjectDescriptor' }
        Map releaseMap = data.find { it -> it.kind == 'ReleaseDescriptor' }

        if (releaseMap) {
            ReleaseDescriptor releaseDescriptor = ObjectCreator.createInstance(ReleaseDescriptor, releaseMap)
            updateDataModels(releaseDescriptor)
        }

        if (projectMap) {
            ProjectDescriptor projectDescriptor = ObjectCreator.createInstance(ProjectDescriptor, projectMap)
            updateDataModels(projectDescriptor)
        }

        if (pipelineMap) {
            PipelineDefinition pipelineDefinition = ObjectCreator.createInstance(PipelineDefinition, pipelineMap)
            updateDataModels(pipelineDefinition)
        }

    }



    void configure() {
        workspaceTool = getComponent(IWorkspaceTool.class)
        Store<PipelineDefinition> store = getStore(PipelineDefinition.class)
        isDebuggable = store.select { PipelineDefinition it -> it.spec.settings.debugMode }
        skipStages = store.select { PipelineDefinition it -> it.spec.settings.skipStages }
        Map environMentVars = store.select { PipelineDefinition it -> it.spec.environmentVars }
        logger.info('PipelineContex.configure()', "Workspace directory is configured at ${steps.env.WORKSPACE}")

        String cacheBaseDir = store.select { PipelineDefinition it -> it.spec.cache.baseDir }
        Set<String> cacheFolders = store.select { PipelineDefinition it -> it.spec.cache.cacheFolders }
        String cacheDirExportEnvVar = store.select { PipelineDefinition it -> it.spec.cache.exportEnvVar }

        Boolean forceClearCache = store.select { PipelineDefinition it -> it.spec.cache.forceClearCache }

        String jobCacheDir = resolveCacheDirectory(cacheBaseDir)

        clearCacheIfConfigured(forceClearCache, jobCacheDir)
        createCacheFolders(cacheFolders, jobCacheDir)
        setEnvironmentWithVarsExpanded(cacheDirExportEnvVar, environMentVars, jobCacheDir)
        logger.info('PipelineContex.configure()', "Cache root directory is configured at ${jobCacheDir}")
    }

}
</file>

<file path="bin/main/es/giss/framework/core/ReleaseStages.groovy">
package es.giss.framework.core

import es.giss.framework.core.Stage
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.storage.Store
import es.giss.framework.core.interfaces.IReleaseStages
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.tools.interfaces.ISemanticRelease
import es.giss.framework.core.vo.release.ReleaseDescriptor
import es.giss.framework.core.vo.release.SemanticVersion

@PipelineComponent
class ReleaseStages extends Stage implements IReleaseStages {

    private ISemanticRelease releaseController
    SemanticVersion currentVersion

    final String STAGE_TAG_SNAPSHOT = "Tag Snapshot"

    ReleaseStages(ISemanticRelease releaseController) {
        this.releaseController = releaseController
    }

    @Override
    void configure(IPipelineContext context) {
        Store releaseStore = context.getStore(ReleaseDescriptor.class)
        this.currentVersion = releaseStore.select { ReleaseDescriptor releaseDescriptor ->
            releaseDescriptor.spec.version
        }
    }

    @Override
    void releaseSnapshot() {
        stage(STAGE_TAG_SNAPSHOT) {
            logger.info("[ReleaseStages.releaseSnapshot()]")
            Boolean res = releaseController.incrementTagSnapshot(this.currentVersion)
            if(!res){
                markStageUnstable(STAGE_TAG_SNAPSHOT, "Error al incrementar el tag Snapshot")
            }
        }
    }

    @Override
    void releaseMaster() {
        stage('Tag Master') {
            logger.info("[ReleaseStages.releaseMaster()]")
            releaseController.createTagMaster(this.currentVersion)
        }
    }
}
</file>

<file path="bin/main/es/giss/framework/core/Stage.groovy">
package es.giss.framework.core


import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.interfaces.IStage
import es.giss.framework.core.vo.observability.events.StageCompletedEvent
import es.giss.framework.core.vo.observability.events.StageErrorEvent
import es.giss.framework.core.vo.observability.events.StageSkippedEvent
import es.giss.framework.core.vo.observability.events.StageStarted
import es.giss.framework.core.vo.observability.events.StageUnstableEvent
import es.giss.framework.core.vo.pipeline.JobStatus
import org.jenkinsci.plugins.pipeline.modeldefinition.Utils

abstract class Stage extends Steps implements IStage {




    @Override
    def stage(String name, Closure body) {
        logger.info("Iniciando Stage: $name".toString())
        body?.delegate = steps

        steps.stage(name) {
            logger.info("Iniciando Stage2: $name")
            if (!evaluateIfSkipStage(name)) {
                TelemetryEvent stageStartedEvent = new TelemetryEvent(payload: new StageStarted(stageName: name, result: steps.currentBuild.currentResult))
                pipeline.dispatch(stageStartedEvent)

                def result = null
                try {
                    logger.info "Execute Stage with name: '$name'"
                    if (body == null) {
                        logger.warn "Stage '$name' is empty"
                    }
                    result = body()
                } catch (Exception ex) {
                    List<String> lines = handleException(name, ex)
                    steps.currentBuild?.result = 'FAILURE'
                    StageErrorEvent stageErrorEvent = new StageErrorEvent(
                            stageName: name,
                            result: steps.currentBuild?.currentResult,
                            message: ex.getMessage(),
                            filteredStackTrace: lines
                    )
                    JobStatus jobStatus = new JobStatus(message: "Ha fallado este stage: ${name} con excepcin: ${ex.getMessage()}")

                    pipeline.updateDataModels(stageErrorEvent, jobStatus)
                    logger.flushLogs()
//                    throw ex
                    steps.error ex.getMessage()
                }
                long currentTimeMillis = System.currentTimeMillis()
                long duration = currentTimeMillis - stageStartedEvent.timeMillis
                pipeline.updateDataModels(new StageCompletedEvent(stageName: name, duration: duration, result: steps.currentBuild.currentResult ))
                logger.info "Finalize Stage: '$name' with duration: ${duration / 1000} seconds and result ${steps.currentBuild.currentResult} "
                logger.flushLogs()
                return result
            } else {
                logger.info "Stage '$name' skipped"
                pipeline.updateDataModels(new StageSkippedEvent(stageName: name))
                cancelStage(name)
            }

        }

    }

    protected boolean evaluateIfSkipStage(String name) {
        Boolean skipped = false
        if (pipeline?.skipStages?.contains(name)) {
            logger.warn "Stage '$name' is marked to be skipped (pipeline.skipStages=${pipeline?.skipStages?.join(',')})"
            skipped = true
        }
        logger.debug "Stage '$name' not skipped"
        return skipped
    }

    List<String> handleException(String name, Exception ex) {
        List lines = ["Error in Stage $name", ex.toString(), ex.getMessage()]
        lines.add('----------------------------------------')
        lines.addAll(filterStackTrace(ex).join("\n"))
        logger.logPrettyError(lines)
        return lines
    }

    List<String> filterStackTrace(Exception ex) {
        return ex.getStackTrace().findAll { stackTraceElement ->
            PipelineContext.DEFAULT_SCAN_PACKAGES.any { pattern -> stackTraceElement.toString().contains(pattern) }
        }
    }

    void cancelStage(String name) {
        try {
            Utils.markStageSkippedForConditional(name)
        } catch (Exception ex) {
            logger.warn "Cannot cancel stage $name due to an error: ${ex?.message}"
            handleException(name, ex)
        }
    }

    void markStageUnstable(String stageName, String message = "Stage marked as UNSTABLE") {
        try {
            steps.catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE', message: message) {
                pipeline.updateDataModels(new StageUnstableEvent(stageName: stageName, result: "UNSTABLE" ))
                steps.error message
            }
        } catch (Exception ex) {
            logger.warn "Cannot mark stage as unstable due to an error: ${ex?.message}"
        }
    }
}
</file>

<file path="bin/main/es/giss/framework/core/Steps.groovy">
package es.giss.framework.core

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.ISteps

abstract class Steps implements ISteps {

    @Inject
    protected Script steps
    @Inject
    protected ILogger logger
    @Inject
    protected IPipelineContext pipeline

    void ensure(boolean condition, String errorMessage) {
        if (!condition) {
            this.steps.error(errorMessage)
        }
    }

    void ensureNotNull(def object, String errorMessage) {
        this.ensure(object != null, errorMessage)
    }


    void ensureNotEmpty(List list, String errorMessage) {
        this.ensureNotNull(list, errorMessage)
        this.ensure(list.size() > 0, errorMessage)
    }
}
</file>

<file path="bin/main/cdi.groovy">
import static es.giss.framework.core.cdi.ContextSinglenton.createPipelineContext
import static es.giss.framework.core.cdi.ContextSinglenton.getContext

void initialize(Script steps) {
    createPipelineContext(steps)
    generateEphemeralToken(1)
}


// vars/generateJenkinsToken.groovy
def generateEphemeralToken(durationHours = 1) {
    def tokenContent = null

    node('master') {
        try {
            // Obtener los datos necesarios del service account
            def podSaToken = sh(
                    script: "cat /var/run/secrets/kubernetes.io/serviceaccount/token",
                    returnStdout: true
            ).trim()

            // Login usando los certificados montados y ignorando proxy
            withEnv(['NO_PROXY=kubernetes.default.svc,kubernetes,kubernetes.default,localhost,127.0.0.1',
                     'no_proxy=kubernetes.default.svc,kubernetes,kubernetes.default,localhost,127.0.0.1']) {
                sh """
                    set +x
                    oc login \
                        --token=${podSaToken} \
                        --server=https://kubernetes.default.svc \
                        --certificate-authority=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                    set -x
                """

                // Verificar la SA actual
                def saInfo = sh(
                        script: """
                    echo "=== Informacin de la Service Account ==="
                    echo "Usuario actual: \$(oc whoami)"
                    echo "Namespace actual: \$(oc project -q)"                  
                    echo "===================================="
                """,
                        returnStdout: true
                ).trim()
                echo "Info de Service Account:\n${saInfo}"

                tokenContent = sh(
                        script: "oc create token jenkins --duration=${durationHours}h",
                        returnStdout: true
                ).trim()

            }

        } catch (Exception e) {
            echo "Error durante la generacin del token: ${e.message}"
            throw e
        }
    }

    if (tokenContent) {
        echo "Token generado: ${tokenContent.substring(0, 10)}...${tokenContent.substring(tokenContent.length() - 10)}"
        getContext().EPHEMERAL_TOKEN = tokenContent
        echo "Token generado y guardado en el contexto"
    }
}
</file>

<file path="bin/main/config.groovy">
import es.giss.framework.core.interfaces.IConfigClient

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

void load(List<Map> config= []) {
    IConfigClient configClient = getContext().getComponent(IConfigClient.class)
    configClient.configureEntities(config)
}
</file>

<file path="bin/main/errorHandler.groovy">
def call(Closure closure) {
    try {
        // Tu cdigo aqu
        closure()
    } catch (org.codehaus.groovy.control.MultipleCompilationErrorsException e) {
        def errors = e.errorCollector.errors
        errors.each { error ->
            if (error instanceof org.codehaus.groovy.control.CompilationFailedException) {
                echo "Compilation error in file: ${error.source.name}"
                echo "Line number: ${error.line}"
                echo "Column number: ${error.column}"
                echo "Error message: ${error.message}"
            }
        }
        error "Pipeline failed due to compilation errors"
    } catch (Exception e) {
        echo "Caught unexpected exception: ${e.toString()}"
        throw e
    }
}
</file>

<file path="bin/main/gitlab.groovy">
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.tools.restClients.GitLabTool
import es.giss.framework.core.tools.restClients.interfaces.IGitLabTool

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

IGitLabTool gitLab(steps) {
    ILogger logger = getContext().getComponent(ILogger.class)
    return new GitLabTool(steps, logger)
}


def getRawFile(Script steps, String url, String branch, String filePath) {
    def gitLabTool = gitLab(steps)
//    https://gitlab.pro.portal.ss/dvo/helm-charts/dvo_helm-charts_ms-java
    def result = gitLabTool.baseUrl('https://gitlab.pro.portal.ss')
            .credentialsId('oc-gs-jenkins-gitlab-auth')
            .ignoreSsl(true)
            .getRawFile(url, branch, filePath)

    echo "RawFile: ${result}"

}

def getProjectId(steps) {
    def gitLabTool = gitLab(steps)
//    https://gitlab.pro.portal.ss/dvo/helm-charts/dvo_helm-charts_ms-java
    def result = gitLabTool.baseUrl('https://gitlab.pro.portal.ss')
            .credentialsId('defaultGitlabToken')
            .ignoreSsl(true)
            .getProjectId('dvo/helm-charts/dvo_helm-charts_ms-java')

    echo "Project ID: ${result}"

}
</file>

<file path="bin/main/gitTool.groovy">
import es.giss.framework.core.interfaces.IGitService
import es.giss.framework.core.tools.interfaces.IGitTool

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

void cloneInAgent() {

    IGitService gitTool = getContext().getComponent(IGitService.class)
    gitTool.cloneInAgent()
}

void cloneInAgent(String url,
           String reference,
           String credentialsId = '',
           String cloneDir = '.',
           Boolean shallowClone = false) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    gitTool.cloneInAgent(url, reference, credentialsId, cloneDir, shallowClone)
}

Boolean createTag(String tag) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.createTag(tag)
}

Boolean tagExists(String tag) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.tagExists(tag)
}

Boolean branchExists(String branchName) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.branchExists(branchName)
}

Boolean currentHeadIsTagged() {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.currentHeadIsTagged()
}
</file>

<file path="bin/main/is.groovy">
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.release.DeployEnvironment
import es.giss.framework.core.vo.release.ReleaseDescriptor

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

boolean integration() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment == DeployEnvironment.INTEGRATION
    }
}

boolean certification() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment == DeployEnvironment.CERTIFICATION
    }
}

boolean preproduction() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment == DeployEnvironment.PREPRODUCTION
    }
}

boolean production() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment == DeployEnvironment.PRODUCTION
    }
}

boolean readyForPS() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        def environment = it.spec.releasePromotion.toEnvironment
        def version = it.spec.version
        return environment == DeployEnvironment.PRODUCTION &&
                version.isFinal()
    }
}

boolean manualExecution() {
    return getContext().getStore(PipelineDefinition.class).select { PipelineDefinition it ->
        it.status.jobStatus.buildTrigger.contains('MANUAL')
    }
}
</file>

<file path="bin/main/jsonPath.groovy">
def getValue(Map<String, Object> data, String jsonPath) {
    def parts = jsonPath.split('\\.')
    def current = data

    for (int i = 0; i < parts.size(); i++) {
        def part = parts[i]

        if (part.startsWith('[') && part.endsWith(']')) {
            def condition = part[1..-2]
            if (condition.startsWith('?')) {
                def lambda = condition[2..-2]
                def result = current.findAll { item ->
                    def itemValue = getValue(item, lambda)
                    return itemValue
                }
                current = result
            } else {
                def index = condition.toInteger()
                current = current[index]
            }
        } else if (part.startsWith('\'') && part.endsWith('\'')) {
            def key = part[1..-2]
            current = current[key]
        } else {
            current = current[part]
        }

        if (current == null) {
            return null
        }
    }

    return current
}


Map<String, Object> bookstoreMap = [
        bookstore: [
                [
                        book: [
                                category: 'cooking',
                                title: [
                                        lang: 'en',
                                        value: 'Everyday Italian'
                                ],
                                author: 'Giada De Laurentiis',
                                year: 2005,
                                price: 30.00
                        ]
                ],
                [
                        book: [
                                category: 'children',
                                title: [
                                        lang: 'en',
                                        value: 'Harry Potter'
                                ],
                                author: 'J K. Rowling',
                                year: 2005,
                                price: 29.99
                        ]
                ],
                [
                        book: [
                                category: 'web',
                                title: [
                                        lang: 'en',
                                        value: 'XQuery Kick Start'
                                ],
                                author: [
                                        'James McGovern',
                                        'Per Bothner',
                                        'Kurt Cagle',
                                        'James Linn',
                                        'Vaidyanathan Nagarajan'
                                ],
                                year: 2003,
                                price: 49.99
                        ]
                ],
                [
                        book: [
                                category: 'web',
                                title: [
                                        lang: 'en',
                                        value: 'Learning XML'
                                ],
                                author: 'Erik T. Ray',
                                year: 2003,
                                price: 39.95
                        ]
                ]
        ]
]
// Ejemplos de uso
println getValue(bookstoreMap, 'bookstore[?(@.book.category == \'web\')].book.title.value')
// [XQuery Kick Start, Learning XML]

println getValue(bookstoreMap, 'bookstore[?(@.book.price < 40)].book.author')
// [Giada De Laurentiis, J K. Rowling, Erik T. Ray]

println getValue(bookstoreMap, 'bookstore[?(@.book.year >= 2005)].book.title.value')
// [Everyday Italian, Harry Potter]

println getValue(bookstoreMap, 'bookstore[?(@.book.author.size() > 1)].book.category')
// [web]
</file>

<file path="bin/main/loggerTool.groovy">
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.logger.LogLevel

import static es.giss.framework.core.cdi.ContextSinglenton.getContext


void logLevel(String level) {
    ILogger logger = getContext().getComponent(ILogger.class)
    LogLevel logLevel = LogLevel.valueOf(level)
    logger.setLogLevel(logLevel)
}

void debug(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.debug(message)
}

void info(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.info(message)
}

void warn(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.warn(message)
}

void error(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.error(message)
}

void fatal(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.fatal(message)
}

void executeWhenDebug(Closure body) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.executeWhenDebug(body)
}

def <T> void printPrettyLog(String level, T obj) {
    ILogger logger = getContext().getComponent(ILogger.class)
    LogLevel logLevel = LogLevel.valueOf(level)
    logger.printPrettyLog(logLevel, obj)
}
</file>

<file path="bin/main/not.groovy">
import es.giss.framework.core.vo.release.DeployEnvironment
import es.giss.framework.core.vo.release.ReleaseDescriptor
import es.giss.framework.core.vo.pipeline.PipelineDefinition

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

boolean integration() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment != DeployEnvironment.INTEGRATION
    }
}

boolean certification() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment != DeployEnvironment.CERTIFICATION
    }
}

boolean preproduction() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment != DeployEnvironment.PREPRODUCTION
    }
}

boolean production() {
    return getContext().getStore(ReleaseDescriptor.class).select { ReleaseDescriptor it ->
        it.spec.releasePromotion.toEnvironment != DeployEnvironment.PRODUCTION
    }
}


boolean manualExecution() {
    return getContext().getStore(PipelineDefinition.class).select { PipelineDefinition it ->
        !(it.status.jobStatus.buildTrigger.contains('MANUAL'))
    }
}
</file>

<file path="bin/main/releaseStages.groovy">
import es.giss.framework.core.interfaces.IReleaseStages

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

void releaseSnapshot() {
    IReleaseStages releaseStages = getContext().getComponent(IReleaseStages.class)
    releaseStages.releaseSnapshot()
}

void releaseMaster() {
    IReleaseStages releaseStages = getContext().getComponent(IReleaseStages.class)
    releaseStages.releaseMaster()
}
</file>

<file path="bin/main/restClient.groovy">
import es.giss.framework.core.tools.ProxyHost
import es.giss.framework.core.tools.restClients.RestClient
import es.giss.framework.core.tools.restClients.interfaces.IRestClient

IRestClient create(Script steps) {
    return new RestClient(steps)

}


void pruebaConGet() {
    def restClient = create(this)
    ProxyHost proxy = new ProxyHost(
            protocol: 'http',
            host: 'proxy-sa.seg-social.es',
            port: 8080,
            proxyUser: '99guaxxx',
            proxyPassword: 'xxxxx'

    )
    def response = restClient.url('https://api.github.com/users/rubentxu')
            .debugMode(false)
            .get()
            .header('Content-Type', 'application/json')
            .proxy(proxy)
            .execute()
    echo "Response status code: ${response.statusCode} \n Response body: ${response.body}"
    echo "Response body parsed: ${response.parseJsonBody()}"
}

void pruebaConGet2() {
    def restClient = create(this)
    def response = restClient.url('http://backend-gpro-co-dvo.apps.giss.pro.portal.ss/jobs/getDevopsConfigByJenkinsType?environment=INT&jenkinsType=ALL')
            .debugMode(true)
            .get()
            .header('Content-Type', 'application/json')
//            .proxy('http://proxy-sa.seg-social.es', 8080)
            .execute()
    echo "Response status code: ${response.statusCode} \n Response body: ${response.body}"
}

void pruebaConCredenciales() {
    def restClient = create(this)
    def response = restClient.url('https://jsonplaceholder.typicode.com/posts')
            .get()
            .header('Content-Type', 'application/json')
            .proxy('http://proxy-sa.seg-social.es', 8080)
            .withAuthBasic('my-credentials-id', 'UsernamePasswordMultiBinding')
            .execute()
    echo response.toString()
}

void pruebaConPost() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts')
    restClient.post()
    restClient.header('Content-Type', 'application/json')
    restClient.body('{"title": "foo", "body": "bar", "userId": 1}')
    def response = restClient.execute()
    echo response.toString()
}

void pruebaConPut() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.put()
    restClient.header('Content-Type', 'application/json')
    restClient.body('{"id": 1, "title": "foo", "body": "bar", "userId": 1}')
    def response = restClient.execute()
    echo response.toString()
}

void pruebaConDelete() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.delete()
    def response = restClient.execute()
    echo response.toString()
}

void pruebaConDebugMode() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.get()
    restClient.debugMode(true)
    def response = restClient.execute()
    echo response.toString()
}


void pruebaConBody() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.get()
    restClient.body('{"id": 1, "title": "foo", "body": "bar", "userId": 1}')
    def response = restClient.execute()
    echo response.toString()
}
</file>

<file path="bin/main/when.groovy">
import es.giss.framework.core.interfaces.IPipelineContext

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

def call(Boolean expression, Closure code, Boolean autoCancelledStagesIfFalse = false) {
    if (expression) {
        code()
    } else if (autoCancelledStagesIfFalse) {
        autoCancelled(code)
    }
}


def predicate(Boolean expression, Closure code, Boolean autoCancelledStagesIfFalse = false) {
    call(expression, code, autoCancelledStagesIfFalse)
}

def not(Boolean expression, Closure code, Boolean autoCancelledStagesIfFalse = false) {
    if (!expression) {
        code()
    } else if (autoCancelledStagesIfFalse) {
        autoCancelled(code)
    }
}

def any(List<Boolean> expressions, Closure code, Boolean autoCancelledStagesIfFalse = false) {
    if (expressions.any { it }) {
        code()
    } else if (autoCancelledStagesIfFalse) {
        autoCancelled(code)
    }
}

def all(List<Boolean> expressions, Closure code, Boolean autoCancelledStagesIfFalse = false) {
    if (expressions.every { it }) {
        code()
    } else if (autoCancelledStagesIfFalse) {
        autoCancelled(code)
    }
}


def autoCancelled(Closure code) {
    boolean previousAutocancel = getContext().getComponent(IPipelineContext.class).autoCancelled
    getContext().getComponent(IPipelineContext.class).autoCancelled = true
    code()
    getContext().getComponent(IPipelineContext.class).autoCancelled = previousAutocancel
}
</file>

<file path="bin/main/workspace.groovy">
import es.giss.framework.core.tools.interfaces.IWorkspaceTool

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

Boolean checkWatchedFiles(Boolean abortPipeline = true) {
    getContext().getComponent(IWorkspaceTool.class).checkWatchedFiles(abortPipeline)
}

Boolean checkWatchedFiles(Boolean abortPipeline, List<String> inclusionPatterns, List<String> exclusionPatterns) {
    getContext().getComponent(IWorkspaceTool.class).checkWatchedFiles(abortPipeline, inclusionPatterns, exclusionPatterns)
}
</file>

<file path="bin/test/es/giss/framework/core/config/ConfigAdapterHelmTool.groovy">
package es.giss.framework.core.config

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ProjectEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.BuildStrategy

@PipelineComponent(name = 'ConfigAdapterHelmToolTest', priority = ConfigurationPriority.LOWEST)
class ConfigAdapterHelmTool implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        BuildStrategy first =  new BuildStrategy(
                id: 'id1',
                toolId: 'defaultHelm',
                buildCommand: 'package',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        BuildStrategy second =  new BuildStrategy(
                id: 'id2',
                toolId: 'defaultHelm',
                buildCommand: 'package ',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        ProjectTool tool = new ProjectTool(
                id: 'defaultHelm',
                name: 'helm',
                version: '3.6.3.low',
                cache: true
        )

        pipeline.dispatch(new ProjectEvent(payload: tool))
        pipeline.dispatch(new ProjectEvent(payload:first))
        pipeline.dispatch(new ProjectEvent(payload:second))

    }
}
</file>

<file path="bin/test/es/giss/framework/core/config/ConfigAdapterMaventTool.groovy">
package es.giss.framework.core.config

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ProjectEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.BuildStrategy

@PipelineComponent(name = 'ConfigAdapterMaventToolTest', priority = ConfigurationPriority.LOW)
class ConfigAdapterMaventTool implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        BuildStrategy first =  new BuildStrategy(
                id: 'id1',
                toolId: 'defaultMaven',
                buildCommand: 'package',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        BuildStrategy second =  new BuildStrategy(
                id: 'id2',
                toolId: 'defaultMaven',
                buildCommand: 'package ',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        ProjectTool tool = new ProjectTool(
                id: 'defaultMaven',
                name: 'maven',
                version: '3.6.3.low',
                cache: true
        )
        pipeline.dispatch(new ProjectEvent(payload: tool))
        pipeline.dispatch(new ProjectEvent(payload:first))
        pipeline.dispatch(new ProjectEvent(payload:second))

    }
}
</file>

<file path="bin/test/es/giss/framework/core/config/ConfigAdapterMaventToolOther.groovy">
package es.giss.framework.core.config

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ProjectEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.BuildStrategy

@PipelineComponent(name = 'ConfigAdapterMaventToolTestOther', priority = ConfigurationPriority.LOW)
class ConfigAdapterMaventToolOther implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return 'ConfigAdapterMaventToolTest'
    }

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        BuildStrategy first =  new BuildStrategy(
                id: 'defaultMaven',
                toolId: 'defaultMaven',
                buildCommand: 'install',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1.1',
                ]
        )
        BuildStrategy second =  new BuildStrategy(
                id: 'id2',
                toolId: 'defaultMaven',
                buildCommand: 'install',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1.1',
                ]
        )
        ProjectTool tool = new ProjectTool(
                id: 'defaultMaven',
                name: 'maven',
                version: '3.8',
                cache: true
        )
        pipeline.dispatch(new ProjectEvent(payload: tool))
        pipeline.dispatch(new ProjectEvent(payload:first))
        pipeline.dispatch(new ProjectEvent(payload:second))

    }
}
</file>

<file path="bin/test/es/giss/framework/core/config/ConfigAdapterToolsManager.groovy">
package es.giss.framework.core.config

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.pipeline.AsdfToolsManagerDescriptor
import es.giss.framework.core.vo.pipeline.ProxySettings

@PipelineComponent(name = 'AsdfToolsConfig', priority = ConfigurationPriority.LOWEST)
class ConfigAdapterToolsManager implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        AsdfToolsManagerDescriptor first = new AsdfToolsManagerDescriptor(
                defaultToolVersionsFileDir: '/tmp',
                forceClearCache: true,
                proxySettings: new ProxySettings(
                        httpProxy: 'http://proxy.com',
                        httpsProxy: 'https://proxy.com',
                        noProxy: 'localhost'
                ),
                plugins: [
                        maven: 'https://asdf.com/maven',
                ],
                tools: [
                        maven: '3.6.3',
                        helm : '3.0'
                ]
        )
        AsdfToolsManagerDescriptor second = new AsdfToolsManagerDescriptor(
                plugins: [
                        helm  : 'https://asdf.com/helm',
                        nodejs: 'https://asdf.com/nodejs',
                ],
                tools: [
                        nodejs: '14.17.0',
                ]
        )

        pipeline.updateDataModels(first, second)

    }
}
</file>

<file path="bin/test/es/giss/framework/core/storage/TestArtifact.groovy">
package es.giss.framework.core.storage

import es.giss.framework.core.vo.release.Artifact

class TestArtifact extends Artifact {
    String groupId
    String artifactId

    @Override
    Map<String, Object> toMap() {
        Map<String, Object> map = super.toMap()
        map.artifactId = artifactId
        map.groupId = groupId
        return map
    }

}
</file>

<file path="bin/test/es/giss/framework/core/utils/TestHelmDeployStrategy.groovy">
package es.giss.framework.core.utils

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.strategies.DeployStrategy

/**
 * Clase de utilidad para preparar archivos de Helm.
 */
class TestHelmDeployStrategy extends DeployStrategy {
    String releaseName = ''
    String namespace = ''

    TestHelmDeployStrategy() {
        this.type = TestHelmDeployStrategy.class.getSimpleName()
    }

    @Override
    void prepareEnvironment(IPipelineContext pipeline) {


    }

    @Override
    void postExecution(IPipelineContext context) {

    }

    @NonCPS
    @Override
    String toString() {
        return """
            TestHelmDeployStrategy {
                id: ${id}
                name: ${name}
                toolId: ${toolId}
                deployCommand: ${deployCommand}
                metadata: ${this.getMetadata()}          
                releaseName: ${releaseName}
                namespace: ${namespace}       
            }
        """
    }


    @NonCPS
    @Override
    Object clone() {
        return new TestHelmDeployStrategy(
                id: id,
                toolId: toolId,
                name: name,
                type: type,
                deployCommand: deployCommand,
                metadata: metadata,
                namespace: namespace,
                releaseName: releaseName
        )
    }
}
</file>

<file path="bin/test/fixtures/core/cdi/config/adapters/ExampleConfigAdapter.groovy">
package fixtures.core.cdi.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent(name = "ExampleConfigAdapter")
class ExampleConfigAdapter implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/config/adapters/TestConfigAdapter.groovy">
package fixtures.core.cdi.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class TestConfigAdapter implements IConfigAdapter {


    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/config/notAnnotated/NotAnnotatedConfigAdapter.groovy">
package fixtures.core.cdi.config.notAnnotated

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

class NotAnnotatedConfigAdapter implements IConfigAdapter {


    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/config/notQualified/ExampleConfigAdapter.groovy">
package fixtures.core.cdi.config.notQualified

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class ExampleConfigAdapter implements IConfigAdapter {


    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/config/notQualified/TestConfigAdapter.groovy">
package fixtures.core.cdi.config.notQualified


import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class TestConfigAdapter implements IConfigAdapter {


    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/interfaces/IAnimalCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface IAnimalCD {

    void breath()

    void eat()

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/interfaces/ICarCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface ICarCD extends IVehicleCD {

    void honk()

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/interfaces/ICompanyCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface ICompanyCD {

    void startWork(IHumanCD human)

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/interfaces/IHumanCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface IHumanCD extends IAnimalCD {

    void speak()

    void work()

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/interfaces/IVehicleCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface IVehicleCD {

    void startEngine()

    void move()

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/AnimalCarCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.cyclicdependencies.interfaces.IAnimalCD
import fixtures.core.cdi.cyclicdependencies.interfaces.ICarCD

@PipelineComponent
class AnimalCarCD extends Steps implements ICarCD {

    IAnimalCD animal

    AnimalCarCD(IAnimalCD animal) {
        this.animal = animal
    }

    @Override
    void honk() {
        steps.echo('Honking the animal car...')
    }

    @Override
    void startEngine() {
        steps.echo("Starting the animal car's engine...")
    }

    @Override
    void move() {
        steps.echo('Moving the animal car...')
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/CarCompanyCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.cyclicdependencies.interfaces.ICarCD
import fixtures.core.cdi.cyclicdependencies.interfaces.ICompanyCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IVehicleCD


@PipelineComponent(name = 'carCompany')
class CarCompanyCD implements ICompanyCD, IVehicleCD {

    ICarCD car

    CarCompanyCD(ICarCD car) {
        this.car = car
    }

    @Override
    void startWork(IHumanCD human) {
        human.work()
        car.startEngine()
        car.move()
    }

    @Override
    void startEngine() {
        print('Starting engine...')
    }

    @Override
    void move() {
        print('Moving...')
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/DuckCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.cyclicdependencies.interfaces.IAnimalCD


@PipelineComponent(priority = ConfigurationPriority.HIGH)
class DuckCD implements IAnimalCD {

    @Override
    void breath() {
        print('DuckCD breathing...')
    }

    @Override
    void eat() {
        print('DuckCD eating...')
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/GissCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.cyclicdependencies.interfaces.ICompanyCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD

@PipelineComponent(name = 'gissCompany')
class GissCD implements ICompanyCD {

    IHumanCD driver

    GissCD(@Qualifier('trucker') IHumanCD driver) {
        this.driver = driver
    }

    @Override
    void startWork(IHumanCD human) {
        print('Hiring a new employee for GissCD...')
        human.work()
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/TaxiDriverCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IVehicleCD


@PipelineComponent(name = 'cabby')
class TaxiDriverCD implements IHumanCD {

    IVehicleCD vehicle

    TaxiDriverCD(@Qualifier('carCompany') IVehicleCD vehicle) {
        this.vehicle = vehicle
    }

    @Override
    void breath() {
        println 'I am a taxi driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a taxi driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a taxi driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/cyclicdependencies/TruckDriverCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.cyclicdependencies.interfaces.ICompanyCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IVehicleCD

@PipelineComponent(name = 'trucker')
class TruckDriverCD implements IHumanCD {

    IVehicleCD vehicle
    ICompanyCD company

    TruckDriverCD(@Qualifier('carCompany') IVehicleCD vehicle, @Qualifier(value = 'gissCompany') ICompanyCD company) {
        this.vehicle = vehicle
        this.company = company
    }

    @Override
    void breath() {
        println 'I am a truck driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a truck driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a truck driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/interfaces/IBook.groovy">
package fixtures.core.cdi.interfaces

interface IBook {

    int countLines()

}
</file>

<file path="bin/test/fixtures/core/cdi/interfaces/IDummy.groovy">
package fixtures.core.cdi.interfaces

interface IDummy {

    void doSomething()

}
</file>

<file path="bin/test/fixtures/core/cdi/interfaces/IGreeting.groovy">
package fixtures.core.cdi.interfaces

interface IGreeting {

    void sayHello(String name)

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/interfaces/IExampleA.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleA {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/interfaces/IExampleB.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleB {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/interfaces/IExampleC.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleC {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/interfaces/IExampleE.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleE {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/interfaces/IExampleH.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleH {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/interfaces/IExampleZ.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleZ {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/ExampleA.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.legacy.interfaces.*

@PipelineComponent(name = 'ejemploA')
class ExampleA implements  IExampleZ, IExampleA {

    IExampleB exampleB
    IExampleC exampleC
    IExampleE exampleE

    ExampleA(IExampleB exampleB, @Qualifier(value = 'ejemploC') IExampleC exampleC, @Qualifier(value = 'ejemploE') IExampleE exampleE) {
        this.exampleB = exampleB
        this.exampleC = exampleC
        this.exampleE = exampleE
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/ExampleB.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleB
import fixtures.core.cdi.legacy.interfaces.IExampleC

@PipelineComponent()
class ExampleB implements IExampleB {

    IExampleC exampleD

    ExampleB(IExampleC exampleD) {
        this.exampleD = exampleD
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/ExampleC.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleC


@PipelineComponent(priority = ConfigurationPriority.HIGH, name = 'ejemploC')
class ExampleC implements IExampleC {

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/ExampleD.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleC
import fixtures.core.cdi.legacy.interfaces.IExampleH

@PipelineComponent
class ExampleD extends Steps implements IExampleC {

    IExampleH exampleH

    ExampleD(IExampleH exampleH) {
        this.exampleH = exampleH
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/ExampleE.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleC
import fixtures.core.cdi.legacy.interfaces.IExampleE


@PipelineComponent(name = 'ejemploE')
class ExampleE implements IExampleE {

    IExampleC exampleD

    ExampleE(IExampleC exampleD) {
        this.exampleD = exampleD
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/legacy/ExampleH.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleH

@PipelineComponent
class ExampleH implements IExampleH {

    ExampleH() {
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/interfaces/IAnimal.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface IAnimal {

    void breath()

    void eat()

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/interfaces/ICar.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface ICar extends IVehicle {

    void honk()

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/interfaces/ICompany.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface ICompany {

    void startWork(IHuman human)

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/interfaces/IHuman.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface IHuman extends IAnimal {

    void speak()

    void work()

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/interfaces/IVehicle.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

import es.giss.framework.core.interfaces.Configurable

interface IVehicle extends Configurable {

    void startEngine()

    void move()

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/AnimalCar.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.nocyclicdependencies.interfaces.IAnimal
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICar

@PipelineComponent
class AnimalCar extends Steps implements ICar {

    IAnimal animal

    AnimalCar(IAnimal animal) {
        this.animal = animal
    }

    @Override
    void honk() {
        steps.echo('Honking the animal car...')
    }

    @Override
    void startEngine() {
        steps.echo("Starting the animal car's engine...")
    }

    @Override
    void move() {
        steps.echo('Moving the animal car...')
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/CarCompany.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICar
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICompany
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman
import fixtures.core.cdi.nocyclicdependencies.interfaces.IVehicle

@PipelineComponent(name = 'carCompany')
class CarCompany implements ICompany, IVehicle {

    ICar car

    CarCompany(ICar car) {
        this.car = car
    }

    @Override
    void startWork(IHuman human) {
        human.work()
        car.startEngine()
        car.move()
    }

    @Override
    void startEngine() {
        print('Starting engine...')
    }

    @Override
    void move() {
        print('Moving...')
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/Duck.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.nocyclicdependencies.interfaces.IAnimal

@PipelineComponent(priority = ConfigurationPriority.HIGH)
class Duck implements IAnimal {

    @Override
    void breath() {
        print('Duck breathing...')
    }

    @Override
    void eat() {
        print('Duck eating...')
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/Giss.groovy">
package fixtures.core.cdi.nocyclicdependencies


import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICompany
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman

@PipelineComponent(name = 'gissCompany')
class Giss implements ICompany {

    IHuman driver

    Giss(@Qualifier('trucker') IHuman driver) {
        this.driver = driver
    }

    @Override
    void startWork(IHuman human) {
        print('Hiring a new employee for Giss...')
        human.work()
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/TaxiDriver.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman
import fixtures.core.cdi.nocyclicdependencies.interfaces.IVehicle

@PipelineComponent(name = 'cabby')
class TaxiDriver implements IHuman {

    IVehicle vehicle

    TaxiDriver(@Qualifier('carCompany') IVehicle vehicle) {
        this.vehicle = vehicle
    }

    @Override
    void breath() {
        println 'I am a taxi driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a taxi driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a taxi driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/nocyclicdependencies/TruckDriver.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICompany
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman
import fixtures.core.cdi.nocyclicdependencies.interfaces.IVehicle

@PipelineComponent(name = 'trucker')
class TruckDriver implements IHuman {

    IVehicle vehicle
    ICompany company

    TruckDriver(@Qualifier('carCompany') IVehicle vehicle, @Qualifier(value = 'carCompany') ICompany company) {
        this.vehicle = vehicle
        this.company = company
    }

    @Override
    void breath() {
        println 'I am a truck driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a truck driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a truck driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/withdiprovider/BookAnnotated.groovy">
package fixtures.core.cdi.withdiprovider

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.interfaces.IBook

@PipelineComponent
class BookAnnotated extends Steps implements IBook, Configurable {

    @Override
    int countLines() {
        return 30
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/withdiprovider/DummyNotAnnotated.groovy">
package fixtures.core.cdi.withdiprovider

import es.giss.framework.core.Steps
import fixtures.core.cdi.interfaces.IDummy

class DummyNotAnnotated extends Steps implements IDummy {

    void doSomething() {
        println 'Doing something'
    }

}
</file>

<file path="bin/test/fixtures/core/cdi/withdiprovider/GreetingNotAnnotated.groovy">
package fixtures.core.cdi.withdiprovider

import es.giss.framework.core.Steps
import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.interfaces.IDummy
import fixtures.core.cdi.interfaces.IGreeting

class GreetingNotAnnotated extends Steps implements IGreeting, Configurable {

    IDummy dummy

    @Override
    void sayHello(String name) {
        print("Hello, ${name}!")
        dummy.doSomething()
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/AnnotatedClass.groovy">
package fixtures.core.cdi

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.ILogger
import fixtures.core.cdi.interfaces.IGreeting

@PipelineComponent
class AnnotatedClass implements IGreeting {
    @Inject
    ILogger logger

    @Inject
    Script script

    @Override
    void sayHello(String name) {
        print("Hello, ${name}!")

    }
}
</file>

<file path="bin/test/fixtures/core/cdi/AnnotatedClassWithoutPipelineComponent.groovy">
package fixtures.core.cdi


import es.giss.framework.core.interfaces.ILogger
import fixtures.core.cdi.interfaces.IGreeting

class AnnotatedClassWithoutPipelineComponent implements IGreeting {

    ILogger logger

    @Override
    void sayHello(String name) {
        print("Hello, ${name}!")
    }
}
</file>

<file path="bin/test/fixtures/core/cdi/AnnotatedClassWithQualifier.groovy">
package fixtures.core.cdi

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.cdi.annotations.Qualifier
import es.giss.framework.core.interfaces.ILogger

class AnnotatedClassWithQualifier {
    @Inject
    @Qualifier('special')
    ILogger logger

    @Inject
    Script script
}
</file>

<file path="bin/test/fixtures/core/TestStage.groovy">
package fixtures.core

import es.giss.framework.core.Stage

class TestStage extends Stage {


    def testStage(Closure body) {
        super.stage('TestStage', body)
    }

}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/credentials/Credentials.groovy">
package es.giss.framework.fixtures.mocks.credentials

interface Credentials {
    String getId()
}

class UsernamePasswordCredentials implements Credentials {
    String id
    String username
    String password

    UsernamePasswordCredentials(String id, String username, String password) {
        this.id = id
        this.username = username
        this.password = password
    }

    String getId() {
        return id
    }

    String getUsername() {
        return username
    }

    String getPassword() {
        return password
    }
}

class StringCredentials implements Credentials {
    String id
    String secret

    StringCredentials(String id, String secret) {
        this.id = id
        this.secret = secret
    }

    String getId() {
        return id
    }

    String getSecret() {
        return secret
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/credentials/ProviderCredentialsMock.groovy">
package es.giss.framework.fixtures.mocks.credentials

import java.util.concurrent.ConcurrentHashMap

class ProviderCredentialsMock {
    Map<String, Credentials> credentialsConfig

    ProviderCredentialsMock() {
        this.credentialsConfig = new ConcurrentHashMap()
    }

    Credentials getCredentials(String id) {
        return credentialsConfig[id]
    }

    void setCredentials(Map<String, Credentials> credentialsConfig) {
        credentialsConfig.each { id, credentials ->
            this.credentialsConfig[id] = credentials
        }
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/AssertFailException.groovy">
package es.giss.framework.fixtures.mocks


class AssertFailException extends Exception {
    AssertFailException(String message) {
        super(formatMessage(message))
    }

    static String formatMessage(String message) {
        Integer maxLength = message.split("\n").max { it.length() }.length()
        def padding = "-" * (maxLength - 2)
        return "\n${padding} \n${message} \n${padding}".toString()
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/HttpClientMock.groovy">
package es.giss.framework.fixtures.mocks
//class HttpClientMock implements IHttpClient {

//    String resourceBasePath = 'http-responses'
//    ResourceMockRegistry resourceMockRegistry = new ResourceMockRegistry()
//
//    File getResourceFile(String url, String method) {
//        ResourceIdentifier id = ResourceIdentifier.fromUrl(url, method)
//        ResponseMock response = resourceMockRegistry.get(id)
//
//        String pathResource = Paths.get(resourceBasePath, response.path()) as String
//
//        URI uriResource = getClass().getClassLoader().getResource(pathResource)?.toURI()
//        if (uriResource) {
//            return new File(uriResource)
//        }
//        return null
//    }
//
//    void addResponseInCallIteration(String method, String path, String fileName, int iteration) {
//        resourceMockRegistry.addResponseInCallIteration(method, path, fileName, iteration)
//    }
//
//    void changeDefaultResponse(String method, String path, String fileName) {
//        resourceMockRegistry.addResponseInCallIteration(method, path, fileName, 0)
//    }
//
//    @Override
//    void initialize(Map configuration) {
//
//    }
//
//    @Override
//    void parse(Map configuration) {
//    }
//
//    @Override
//    HttpResponse get(String url) {
//        File resourceFile = getResourceFile(url, "get")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    private HttpResponse resolveHttpResponse( File resourceFile) {
//        if(resourceFile !=null && resourceFile.exists()) {
//            def responseContent = new JsonSlurper().parseText(resourceFile.text)
//            String body = JsonOutput.toJson(responseContent.body)
//            if(!body || body == "null") {
//                print("""
//                    Body is empty in Mock file ${resourceFile.absolutePath}
//                    Wrapper response to:
//                        {
//                          "statusCode" : 200,
//                          "headers" : {},
//                          "body" : {}
//                        }
//                """)
//            }
//            return new HttpResponse(statusCode: responseContent.statusCode as Integer, body: body, headers: responseContent.headers)
//        } else {
//            return new HttpResponse(statusCode: 404, body: """{"error": "Not found file in path ${resourceFile.absolutePath}"}""", headers: [:])
//        }
//
//    }
//
//    @Override
//    HttpResponse get(String url, Map options) {
//        return get(url)
//    }
//
//    @Override
//    HttpResponse post(String url, Object payload) {
//        File resourceFile = getResourceFile(url, "post")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    @Override
//    HttpResponse post(String url, Object payload, Map options) {
//        return post(url, payload)
//    }
//
//    @Override
//    HttpResponse post(String url, FormDataCollection formDataCollection, Map options) {
//        return post(url, [:])
//    }
//
//    @Override
//    HttpResponse postFile(String url, String filePath) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse postFile(String url, String filePath, Map options) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse put(String url, Object payload) {
//        File resourceFile = getResourceFile(url, "put")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    @Override
//    HttpResponse put(String url, Object payload, Map options) {
//        return put(url, payload)
//    }
//
//    @Override
//    HttpResponse putFile(String url, String filePath) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse putFile(String url, String filePath, Map options) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse delete(String url) {
//        File resourceFile = getResourceFile(url, "delete")
//        return resolveHttpResponse(resourceFile)
//
//
//
//    }
//
//    @Override
//    HttpResponse patch(String url, Object payload) {
//        File resourceFile = getResourceFile(url, "patch")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    @Override
//    HttpResponse delete(String url, Map options) {
//        return delete(url)
//    }
//
////    @Override
////    String buildUrl(String baseUrl, String path, Map<String, Serializable> queryParams) {
////        def uriBuilder = new URIBuilder(baseUrl)
////        def pathSegments = decodePathSegments(path.tokenize('/'))
////        def fullPathSegments = uriBuilder.isPathEmpty()
////                ? pathSegments
////                : decodePathSegments(uriBuilder.getPath().tokenize('/')) + pathSegments
////        uriBuilder.setPathSegments(fullPathSegments)
////        queryParams.each { param, value -> uriBuilder.setParameter(param, value as String) }
////        return uriBuilder.build().toString()
////    }
//
//    private static List<String> decodePathSegments(List<String> pathSegments) {
//        pathSegments.collect { URLDecoder.decode(it, Charset.defaultCharset()) }
//    }
//
//    @Override
//    HttpResponse withBasicAuthUsernamePassword(String usernamePasswordCredentialsId, Closure body) {
//        body.delegate = this
//        return body()
//    }
//
//    @Override
//    HttpResponse withBasicAuthString(String stringCredentialsId, Closure body) {
//        body.delegate = this
//        return body()
//    }
//
//    @Override
//    HttpResponse<String> get(URI url) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> get(URI url, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> post(URI url, Map payload) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> post(URI url, Map payload, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> postFile(URI url, String filePath) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> postFile(URI url, String filePath, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> put(URI url, Map payload) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> put(URI url, Map payload, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> putFile(URI url, String filePath) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> putFile(URI url, String filePath, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> delete(URI url) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> patch(URI url, Map payload) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> delete(URI url, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    URI buildUrl(String baseUrl, String path, Map<String, Serializable> queryParams) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> withBasicAuthUsernamePassword(String usernamePasswordCredentialsId, RequestOptions body) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> withBasicAuthString(String stringCredentialsId, RequestOptions body) {
//        return null
//    }
//
//    @Override
//    Object mapJsonString(String jsonString) {
//        return new JsonSlurper().parseText(jsonString)
//    }
//
//    @Override
//    void configure(IConfigClient config) {
//
//    }
//
//    @Override
//    String execute(String taskName, List<String> options) {
//        return null
//    }
//}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/HttpResponseMock.groovy">
package es.giss.framework.fixtures.mocks

class ResourceCallCounter extends HashMap<ResourceIdentifier, Integer> {

    Integer get(ResourceIdentifier resourceIdentifier) {
        return super.get(resourceIdentifier) ?: 0
    }

    Integer increment(ResourceIdentifier resourceIdentifier) {
        Integer counter = get(resourceIdentifier)
        counter++
        put(resourceIdentifier, counter)
        return counter
    }
}

class ResourceMockRegistry extends HashMap<ResourceIdentifier, ResponseMock>  {

    ResourceCallCounter resourceCallCounter = new ResourceCallCounter()

    ResponseMock get(ResourceIdentifier resourceIdentifier) {
        ResponseMock responseMock = super.get(resourceIdentifier)
        if( responseMock?.isIteration(resourceCallCounter)) {
            resourceCallCounter.increment(resourceIdentifier)
            return responseMock
        } else {
            resourceCallCounter.increment(resourceIdentifier)
            return new ResponseMock(id: resourceIdentifier, iteration: 0, fileName: "${resourceIdentifier.method}-${resourceIdentifier.resourceName}")
        }
    }

    void addResponseInCallIteration(String method, String path, String fileName, int iteration) {
        ResourceIdentifier id = ResourceIdentifier.fromPath(path, method)
        ResponseMock responseMock = new ResponseMock(id: id, iteration: iteration, fileName: fileName)
        put(id, responseMock)
    }

}


class ResourceIdentifier {
    final String path
    final String method

    ResourceIdentifier(String path, String method) {
        this.path = path
        this.method = method
    }

    String getResourceName() {
        int lastSlashIndex = path.lastIndexOf("/")
        return path.substring(lastSlashIndex + 1)
    }

    static ResourceIdentifier fromUrl(String url, String method) {
        String urlWithoutDomain = url.replaceFirst("https?://[^/]+", "")
        String urlPath = urlWithoutDomain.replaceFirst("\\?.*", "")
        return new ResourceIdentifier(urlPath, method)
    }

    static ResourceIdentifier fromPath(String path, String method) {
        return new ResourceIdentifier(path, method)
    }

    @Override
    String toString() {
        return "ResourceIdentifier [path=${path}, method=${method}]"
    }


    @Override
    int hashCode() {
        return Objects.hash(path, method);
    }

    @Override
    boolean equals(Object obj) {
        if (!(obj instanceof ResourceIdentifier))
            return false
        ResourceIdentifier other = (ResourceIdentifier) obj
        return Objects.equals(path, other.path) && Objects.equals(method, other.method)
    }
}


class ResponseMock {
    ResourceIdentifier id
    int iteration
    String fileName

    Boolean isIteration(ResourceCallCounter resourceCallCounter) {
        return iteration == resourceCallCounter.get(id)
    }

    String path() {
        String fileNameWithExtension = this.fileName.endsWith(".json") ? this.fileName : "${this.fileName}.json"
        return "${id.path}/${fileNameWithExtension}".toString()
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/MethodInvocation.groovy">
package es.giss.framework.fixtures.mocks


abstract class MethodInvocation<T> {

    abstract Boolean verifyArgs(T expectedArgs)



    Boolean checkArgsAreEqual(expectedArg, actualArg) {
        def expected = expectedArg
        def actual = actualArg instanceof GString || actualArg instanceof String? actualArg.toString() : actualArg
        if (expectedArg instanceof Map) {
            expected = expectedArg.value
        }
        if(expectedArg instanceof Closure<Boolean>) {
            return expectedArg.call(actual)
        }
        return expected == actual
    }

    static void ensure(boolean condition, String message) {
        if (!condition) {
            throw new AssertFailException(message)
        }
    }

    @Override
    def String toString() {
        return "MethodInvocation{${this.getClass().getSimpleName()}"
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/MethodInvocationRecorder.groovy">
package es.giss.framework.fixtures.mocks

class MethodInvocationRecorder {

    Map<String, List<MethodInvocation>> methodCalls = [:]

    Boolean containsKey(String methodName) {
        return methodCalls.containsKey(methodName)
    }

    def methodMissing(String methodName, args) {
        // Convertir args a una lista si no lo es
        def argumentsResolved = getArgs(args)

        MethodInvocation expectedMethodInvocation = argumentsResolved instanceof Map
                ? new NamedArgsMethodInvocation(methodName, argumentsResolved, null)
                : new PositionalArgsMethodInvocation(methodName, argumentsResolved, null)

        return new Object() {
            def getAt(int pos) {
                def methodMock = verifyInvocation(methodName, pos)
                return methodMock.equals(expectedMethodInvocation)
            }
        }

    }

    def getArgs(args) {
        def argsList= args.toList()
        if (argsList[0] instanceof Map) {
            return argsList[0]
        }
        return argsList
    }

    private MethodInvocation verifyInvocation(String methodName, int pos = 0) {
        def calls = methodCalls[methodName] ?: []
        def result = calls.getAt(pos)
        MethodInvocation.ensure(result != null,
                "Step ${methodName} was not called ${pos} times")
        return result

    }

    void createList(String methodName) {
        methodCalls[methodName] = []
    }

    void addMock(String methodName, MethodInvocation methodInvocation) {
        List<MethodInvocation> invocations = methodCalls[methodName]
        invocations.add(methodInvocation)
    }

    def PositionalArgsMethodInvocation get(String methodName) {
        return methodCalls[methodName]
    }

    @Override
    public String toString() {
        return "MethodInvocationRecorder{" +
                "methodCalls=" + methodCalls +
                '}';
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/NamedArgsMethodInvocation.groovy">
package es.giss.framework.fixtures.mocks

import org.spockframework.lang.SpreadWildcard

class NamedArgsMethodInvocation extends MethodInvocation<Map<String, Object>> {
    Map<String, Object> namedArgs
    private String methodName
    Object output

    NamedArgsMethodInvocation(String methodName, Map<String, Object> args, Object output) {
        this.methodName = methodName
        this.output = output
        this.namedArgs = args
    }

    @Override
    Boolean verifyArgs(Map<String, Object> expectedNamedArgs) {
        ensure(expectedNamedArgs.size() <= namedArgs.size(),
        """
        Number of arguments are not the same, Actual: ${namedArgs.size()}, Expected: ${expectedNamedArgs.size()}
          Actual: ${namedArgs}
          Expected: ${expectedNamedArgs}
        """)

        expectedNamedArgs.each { String key, value ->
            // Ignora el argumento si es '_'
            if (!(containsSpreadWildcard(value))) {
                def actualValue = namedArgs[key]
                ensure(checkArgsAreEqual(value ,actualValue),
                        """Argument with name '${key}' is not the expected,
                                    Expected: >${value}<
                                    Actual:   >${actualValue}<
                    """)
            }
        }
        return this
    }

    @Override
    boolean equals(Object o) {
        ensure(o instanceof NamedArgsMethodInvocation,
                """You are passing positional arguments and you are expected to use named arguments.
                    Redefine method invocation 'steps.${this.methodName}' with the correct arguments.
                    For example:
                    steps.${this.methodName}(${this.namedArgs.collect { key, value -> "${key} : expectedValue" }.join(", ") })
                  """)
        
        NamedArgsMethodInvocation that = (NamedArgsMethodInvocation) o
        return Objects.equals(methodName, that.methodName) &&  verifyArgs(that.namedArgs)
    }


    Boolean containsSpreadWildcard(argument) {
        if (argument instanceof Map.Entry) {
            return argument.value instanceof SpreadWildcard
        }
        if(argument instanceof List) {
            return argument.any { it instanceof SpreadWildcard }
        }
        return argument instanceof SpreadWildcard
    }

}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/PositionalArgsMethodInvocation.groovy">
package es.giss.framework.fixtures.mocks

import org.spockframework.lang.SpreadWildcard
import org.spockframework.lang.Wildcard

class PositionalArgsMethodInvocation extends MethodInvocation<List> {
    List<Object> args
    private String methodName
    Object output

    PositionalArgsMethodInvocation(String methodName, List<Object> args, Object output) {
        this.methodName = methodName
        this.output = output
        this.args = args
    }


    Boolean rightShift(Closure body) {
        body.delegate = this
        body() == this.output
    }


    @Override
    Boolean verifyArgs(List list) {
        ensure(list.size() <= args.size(),
                """
        Number of arguments are not the same, Actual: ${args.size()}, Expected: ${list.size()}
          Actual: ${args}
          Expected: ${list}                
        """)

        for (int i = 0; i < list.size(); i++) {
            // Ignora el argumento si es '_'
            if (!(containsSpreadWildcard(list[i]))) {
                ensure(checkArgsAreEqual(list[i], args[i]),
                        """Argument at index ${i} is not the expected, 
                           Expected: >${list[i]}< 
                             Actual: >${args[i]}<
                        """)
            }
        }
        return this
    }

    @Override
    boolean equals(Object o) {
        if (!(o instanceof PositionalArgsMethodInvocation)) return false

        PositionalArgsMethodInvocation that = (PositionalArgsMethodInvocation) o
        return Objects.equals(methodName, that.methodName) &&  verifyArgs(that.args)
    }



    Boolean containsSpreadWildcard(argument) {
        if (argument instanceof Wildcard) {
            return argument.any { it instanceof SpreadWildcard }
        }
        return false
    }

    @Override
    String toString() {
        return "MethodMock{methodName='${methodName}', args=${args}, output=${output}}"
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/StepsMock.groovy">
package es.giss.framework.fixtures.mocks


import groovy.io.FileType
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import org.yaml.snakeyaml.Yaml

import java.nio.file.FileSystems
import java.nio.file.Path
import java.nio.file.Paths
import java.util.concurrent.ConcurrentHashMap

//@CompileStatic
class StepsMock extends Script {

    Map<String, Object> dynamicProps
    Map<String, Integer> invocationCounts
    private MethodInvocationRecorder recorder = new MethodInvocationRecorder()
//    ProviderCredentialsMock credentialsProvider

    MethodInvocationRecorder validate() {
        return recorder
    }

    StepsMock() {
        dynamicProps = [
                env                  : [
                        JENKINS_URL: 'https://jenkins-gint-ps-dvo.apps.giss.int.portal.ss',
                        JOB_NAME   : 'fdar/ot_fdarback_main/develop',
                        WORKSPACE  : '.',
                ],
                params               : [:],
                currentBuild         : ['getBuildCauses': { null }],
                timeout              : this.&defaultMethodClosure,
                configFileProvider   : this.&defaultMethodClosure,
                ansiColor            : this.&defaultMethodClosure,
                container            : this.&defaultMethodClosure,
                dir                  : this.&dirMock,
                readYaml             : this.&readYamlMock,
                readJSON             : this.&readJsonMock,
                readFile             : this.&readFileMock,
                readProperties       : this.&readPropertiesMock,
                fileExists           : this.&fileExistsMock,
                withCredentials      : this.&defaultMethodClosure,
                withEnv              : this.&defaultMethodClosure,
                withSonarQubeEnv     : this.&defaultMethodClosure,
                node                 : this.&defaultMethodClosure,
                stage                : this.&defaultMethodClosure,
                retry                : this.&retryMock,
                libraryResource      : this.&libraryResourceMock,
                archiveArtifacts     : {},
                configFile           : {},
                waitUntil            : this.&waitUntilMock,
                writeFile            : {},
                writeJSON            : this.&writeJSONMock,
                writeYaml            : this.&writeYAMLMock,
                writeMavenPom        : {},
                usernamePassword     : this.&usernamePasswordMock,
                usernameColonPassword: this.&usernameColonPasswordMock,
                string               : this.&tokenCredentialMock,
                token                : this.&tokenCredentialMock,
                unstash              : {},
                publishHTML          : {},
                parallel             : this.&parallelMock,
                emailext             : {},
                sleep                : {},
                string               : {},
                file                 : {},
                sh                   : { args -> if (args?.returnStatus) { return 0 } else { return '' } },
                echo                 : { System.out.println(it.toString()) }, // groovylint-disable-line SystemOutPrint
                error                : { String message -> throw new TestException(message) },
                catchError           : this.&defaultMethodClosure,
                zip                  : {},
                unzip                : {},
        ]

        invocationCounts = new ConcurrentHashMap()
//        credentialsProvider = new ProviderCredentialsMock()

    }

    def usernamePasswordMock(Map args) {
        String usernameVariable = args.usernameVariable
        String passwordVariable = args.passwordVariable
        this.env[usernameVariable] = 'usernameMock'
        this.env[passwordVariable] = 'passwordMock'
    }

    def usernameColonPasswordMock(Map args) {
        String variable = args.variable
        this.env[variable] = 'userMock:passwordMock'
    }

    def tokenCredentialMock(Map args) {
        String variable = args.variable
        this.env[variable] = 'secretToken'
    }

    def withCredentialsMock(Map args, Closure body) {
        def credentialsId = args.credentialsId
        def credentials = credentialsProvider.getCredentials(credentialsId)
        dynamicProps.env['CREDENTIALS'] = credentials
        body.delegate = this
        return body()
    }


    def defaultMethodClosure(ignored, Closure body) {
        body.delegate = this
        return body()
    }

    def catchErrorMock(ignored, messageIgnored, Closure body) {
        return defaultMethodClosure(ignored, body)
    }

    def timeoutMock(_, closure) {
        closure.delegate = this
        return closure()
    }


    /**
     * Simulate a real invocation for the jenkins retry step
     * @param times number of times to retry
     * @param body closure to be executed
     * @return the output of the closure
     * @throws TestException if the closure fails after the number of retries
     */
    def retryMock(int times, body) {
        def retries = 0
        while (retries < times) {
            try {
                return body()
            } catch (Exception e) {
                retries++
            }
        }
        throw new TestException("Retry failed after ${times} attempts")
    }

    /**
     * Simulate a real invocation for the jenkins libraryResource step
     * @param args jenkins libraryResource step arguments
     * @return the content of the file (or script) in the library
     */
    String libraryResourceMock(args) {
        assert (args instanceof Map && args.resource != null) || args instanceof String
        return '#!/bin/bash\necho "mocked script content"'
    }

    def dirMock(String path, Closure block) {
        def currentPwd = dynamicProps.env?.PWD
        def currentDir = currentPwd ?: '.'
        dynamicProps.env['PWD'] = Paths.get(currentDir).toAbsolutePath().resolve(path).toString()
        def result = block()
        if (currentPwd) {
            dynamicProps.env.PWD = currentPwd
        } else {
            (dynamicProps.env as Map).remove('PWD')
        }
        return result
    }

    def parallelMock(Map args) {
        args.findAll { k, v -> k != 'failFast' }.each { k, v -> v() }
    }

    def readYamlMock(Map args, baseDir = '') {
        if (args?.file?.contains('build')) {
            args.file = args.file.replace('build/', '')
        }
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        if (content?.contains('---')) {
            def result = new Yaml().loadAll(content).toList()
            result.size() == 1 ? result[0] : result
        } else {
            return new Yaml().load(content)
        }
    }

    def readJsonMock(Map args, baseDir = '') {
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        return new JsonSlurper().parseText(content ?: '')
    }

    def readPropertiesMock(Map args, baseDir = '') {
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        Properties properties = new Properties()
        if (content == null) {
            throw new TestException("File not found in resources: ${args.file} for Mock readPropertiesMock")
        }
        properties.load(new StringReader(content))
        Map<String, String> map = new HashMap<String, String>();
        properties.each { k, v -> map[k] = v }
        return map
    }

    def findFilesMock(Map args, baseDir = 'topics') {
        Path parentPath = Paths.get(getClass().getClassLoader().getResource(baseDir as String).toURI()).resolve('../').normalize()

        List<File> files = []
        parentPath.toFile().eachFileRecurse(FileType.FILES) {
            def relativePath = parentPath.relativize(it.toPath())
            if (matchesGlobExpression(args.glob as String, relativePath)) {
                files.add(relativePath.toFile())
            }
        }
        return files
    }

    def readCSVMock(Map args, baseDir = '') {
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        def campos
        def datos = content.readLines().collect { line ->
            if (!campos) {
                // Si es la primera lnea, crea el mapa de campos
                campos = line.split(',').collect { it.trim() }
                [:] // Devuelve un mapa vaco para indicar que no se deben procesar los datos de esta lnea
            } else {
                // Si no es la primera lnea, crea un mapa de valores para cada registro
                def values = line.split(',')
                def registro = [:]
                campos.eachWithIndex { campo, i ->
                    registro[campo] = values[i].trim()
                }
                registro
            }
        }.findAll()
        return datos

    }

    private Boolean matchesGlobExpression(String globPattern, Path path) {
        return FileSystems
                .getDefault()
                .getPathMatcher("glob:${globPattern}")
                .matches(path)
    }

    def readFileMock(Map args, String baseDir = '') {
        return this.getResourceContent(Paths.get(baseDir, args.file as String) as String)
    }

    def writeJSONMock(Map args) {
        if (args.returnText) {
            JsonBuilder builder = new JsonBuilder()
            builder(args.json)
            builder.toString()
        }
    }

    def waitUntilMock(Closure body) {
        for (int i = 0; i < 20; i++) {
            if (body.call()) {
                return
            }
        }
        throw new TestException('Wait until did not return true after 20 retries')
    }

    def writeYAMLMock(Map args) {
        if (args.returnText) {
            return new Yaml().load(args.data as String ?: args.datas as String)
        }
    }

    def fileExistsMock(Map args, String baseDir = '') {
        if (args?.file?.contains('build')) {
            args.file = args.file.replace('build/', '')
        }
        println("Resolve fileExistsMock in path: ${args.file.toString()}")
        return getClass().getClassLoader().getResource(args.file.toString()) != null ? Boolean.TRUE : Boolean.FALSE
    }


    Object sleep(long arg) {
        // To simulate steps.sleep(time) in a pipeline
        methodMissing('sleep', [arg])
    }

    def getAllDynamicProps() {
        return dynamicProps
    }

    @Override
    def getProperty(String propName) {
        return dynamicProps[propName]
    }

    @Override
    void setProperty(String propName, val) {
        dynamicProps[propName] = val
    }

    @Override
    Object run() {
        return null
    }

    def methodMissing(String methodName, args) {
        // Incrementa el contador de invocaciones del mtodo
        incrementInvocationCount(methodName)

        def prop = dynamicProps[methodName]
        if (prop instanceof Closure) {
            def result = prop(*args)
            recordMethodInvocation(methodName, args, result)
            return result
        }
        throw new TestException("\u001B[1;31m************ Method Missing with name $methodName and args $args **************\u001B[0m")
    }

    private void incrementInvocationCount(String methodName) {
        // Si el mtodo no ha sido invocado antes, inicializa su contador a 0
        if (!invocationCounts.containsKey(methodName)) {
            invocationCounts[methodName] = 0
        }
        // Incrementa el contador de invocaciones del mtodo
        invocationCounts[methodName] = invocationCounts[methodName] + 1
    }

    private void recordMethodInvocation(String methodName, args, result) {
        // Si el mtodo no ha sido registrado antes, crea una nueva lista para l
        if (!this.recorder.containsKey(methodName)) {
            this.recorder.createList(methodName)
        }
        def argumentsResolved = recorder.getArgs(args)

        // Crea una nueva instancia de MethodInvocation dependiendo del tipo de argumentos
        MethodInvocation methodInvocation = argumentsResolved instanceof Map
                ? new NamedArgsMethodInvocation(methodName, argumentsResolved, result)
                : new PositionalArgsMethodInvocation(methodName, argumentsResolved, result)
        // Registra la invocacin del mtodo
        this.recorder.addMock(methodName, methodInvocation)
    }

    String getResourceContent(String file) {
        return getClass().getClassLoader().getResource(file.replaceAll('\\\\', '/'))?.text
    }


}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/TestContext.groovy">
package es.giss.framework.fixtures.mocks

import es.giss.framework.core.PipelineContext
import es.giss.framework.core.cdi.ContextSinglenton
import es.giss.framework.core.cdi.dependencies.DependencyResolver
import es.giss.framework.core.cdi.scanner.ClassesInPackageScanner
import es.giss.framework.core.cdi.scanner.PackageScanner
import es.giss.framework.core.config.ConfigClient
import es.giss.framework.core.events.interfaces.DataModel
import es.giss.framework.core.interfaces.IConfigClient
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.Logger
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.tools.restClients.interfaces.IGitLabTool
import es.giss.framework.core.utils.ExpressionEvaluator
import spock.lang.Specification

class TestContext  extends Specification {

    protected StepsMock steps
    protected ILogger loggerSpy
    protected IConfigClient configClient
    protected DependencyResolver resolver
    protected IPipelineContext pipeline


    def setup() {
        steps = new StepsMock()
        loggerSpy = Spy(new Logger(steps))

        pipeline = new PipelineContext(steps)
        ContextSinglenton.instance = pipeline
        resolver = pipeline.dependencyResolver
        pipeline.logger = loggerSpy
        resolver.registerCoreComponent(Script.class, steps)
        resolver.registerCoreComponent(ILogger.class, loggerSpy)
        resolver.registerCoreComponent(IPipelineContext.class, pipeline)
        resolver.registerCoreComponent(IGitTool.class, Mock(IGitTool.class))
        resolver.registerCoreComponent(IWorkspaceTool.class, Mock(IWorkspaceTool.class))
        resolver.registerCoreComponent(IToolsManager.class, Mock(IToolsManager.class))

    }

    protected IPipelineContext configureTest(List<DataModel> pipelineModels = []) {

        configClient = new ConfigClient()
        pipeline.initializePipelineDefaultStore()
        pipeline.initializeProjectDescriptorStore()
        pipeline.initializeTelemetryStore()
        pipeline.initializeReleaseStore()
        pipeline.updateDataModels(*pipelineModels)
        injectFields(configClient)
        return pipeline
    }

    void resolverConfiguracionForNaua() {
        resolveConfiguration(pipeline, "naua")
    }

    void resolveConfiguration(IPipelineContext context, String projectType) {

        try {
            configureTest([])
            String FILE = "${projectType}/pipeline.yaml"
            if (steps.fileExists(file: FILE)) {
                String contentFile = steps.readFile(file: FILE)

                if (!contentFile.trim()) {
                    steps.error("Error getting file pipeline.yaml from pipelines repository. Content is null or empty.")
                    return
                }
                def data = steps.readYaml(text: contentFile, encoding: 'UTF-8')

                context.updateDataModelsFromMap(data)
            }


        } catch (Exception e) {
            steps.error("Error getting Mocck Local file pipeline.yaml. Error: ${e.getMessage()}")

        }

    }

    def <T> T injectFields(T instance) {
        resolver.injectDependenciesByFields(instance)
        return instance
    }

    void registerComponent(Class type, Object instance) {
        resolver.registerCoreComponent(type, instance)
    }
}
</file>

<file path="bin/testFixtures/es/giss/framework/fixtures/mocks/TestException.groovy">
package es.giss.framework.fixtures.mocks

class TestException extends RuntimeException {

    TestException(String message) {
        super(message)
    }

}
</file>

<file path="bin/testFixtures/naua/pipeline.yaml">
kind: ProjectDescriptor
apiVersion: project.giss.es/v1
metadata:
  name: naua
  namespace: gint-ot-fdar
spec:
  projectType: Naua
  settings:
    name: ot-fdarback
    description: Proyecto backend para el servicio
    inceptionYear: ''
    developCenter: ot
    codeCapp: fdar
    promotableItem: back
    currentVersion: 1.0.0-140-SNAPSHOT
    suffix: main
  sourceRepositories:
    - id: defaultHelmChartsSourceRepository
      name: dvo_helm-charts_ms-java
      url: https://gitlab.pro.portal.ss/dvo/helm-charts/dvo_helm-charts_ms-java
      branch: master
      credentialsId: oc-gs-jenkins-gitlab-auth
    - id: csiHelmChartsSourceRepository
      name: dvo_helm-charts_csi
      url: https://gitlab.pro.portal.ss/dvo/helm-charts/dvo_helm-charts_csi
      branch: master
      credentialsId: oc-gs-jenkins-gitlab-auth
  notifications:
    emails:
      - name: 'Maria Nadie'
        email: maria-nadie13@seg-social.es
        notificationsInterested:
          - jenkins
      - name: 'Pepa Nadie'
        email: pepa.nadie@seg-social.es
        notificationsInterested:
          - nexus
  tools:
    - id: defaultMavenTool
      name: maven
      version: 3.6.3
      cache: true
      toolConfigurationFilePath: pom.xml
      artifactsRepositoryId: defaultNexusRepository
      buildStrategies:
        - id: defaultMavenBuild
          name: Build con Maven
          buildCommand: -B clean verify -DskipTests --no-transfer-progress
          type: BuildStrategy
          metadata: { }
      publishStrategies:
        - id: defaultMavenPublish
          name: Subida a repositorio con Maven
          publishCommand: deploy -DskipTests -DaltDeploymentRepository=nexus::default::${urlRepoDeploy} --no-transfer-progress # urlRepoDeploy es una variable que se resuelve a partir del artifactRepository asignado
          metadata:
            urlRepoDeploy: https://nexus-gint-co-dvo.apps.giss.int.portal.ss/
      testStrategies:
        - id: defaultMavenTest
          name: Test con Maven
          testCommand: clean test -DargLine="-Xmx1g -XX:MaxMetaspaceSize=256m" --no-transfer-progress
          metadata:
            testType: unit
            testFramework: junit

    - id: defaultHelmTool
      name: helm
      version: 3.12.1
      cache: true
      artifactsRepositoryId: defaultNexusRepository
      toolConfigurationFilePath: chart.yaml

  artifactsRepositories:
    - id: defaultNexusRepository
      name: Nexus Repository
      url: https://nexus-gpro-co-dvo.apps.giss.pro.portal.ss/repository/ot__maven/
      type: UNKNOWN
      credentialsId: oc-gs-jenkins-nexus-int-auth
    - id: gissDeployRepository
      name: gissDeployRepository
      url: https://nexus-gint-co-dvo.apps.giss.int.portal.ss/
      type: DEPLOY
      credentialsId: oc-gs-jenkins-nexus-int-auth
      metadata:
        pathRepoDeploy: naua/nauawebr/ri-web/1.0/1.0.0-229

  scannerTools:
    - id: defaultUtf8Tool
      name: UTF-8
      description: Analisis de UTF-8
      command: ""
      metadata:
        validExtensions:
          java: [ ".java" ]
        excludePaths:

---


kind: PipelineDefinition
apiVersion: pipeline.giss.es/v1
metadata:
  name: naua
spec:
  cache:
    baseDir: /opt/cache/
    cacheFolders:
      - helm/v3/cache
      - helm/v3/config
      - helm/v3/data
      - maven
    exportEnvVar: CACHE_BASE_DIR
    forceClearCache: false
  environmentVars:
    GIT_URL: https://gitlab.pro.portal.ss
    GIT_CREDENTIALSID_GITLAB: oc-gs-jenkins-gitlab-auth
    OCP_SERVER_URL: https://gitlab-gint-ps-dvo.apps.giss.int.portal.ss
    ENABLE_CSS: true
    M2_HOME: ${CACHE_BASE_DIR}/maven/
    MAVEN_OPTS: -Djavax.net.ssl.trustStore=/etc/ssl/certs/java/cacerts -Djavax.net.ssl.trustStorePassword=changeit -Dmaven.repo.local=${CACHE_BASE_DIR}/maven/ -Xmx512m -Xms256m -XX:+UseG1GC -XX:+ExplicitGCInvokesConcurrent -XX:+ParallelRefProcEnabled -XX:+UseStringDeduplication
    HELM_CACHE_HOME: ${CACHE_BASE_DIR}/helm/v3/cache
    HELM_CONFIG_HOME: ${CACHE_BASE_DIR}/helm/v3/config
    HELM_DATA_HOME: ${CACHE_BASE_DIR}/helm/v3/data
    HELM_HOME: ${CACHE_BASE_DIR}/helm/v2
    JAVA_OPTS: -Djavax.net.ssl.trustStore=/etc/pki/ca-trust/extracted/java/cacerts -Djavax.net.ssl.trustStorePassword=changeit
    _JAVA_OPTIONS: -Djavax.net.ssl.trustStore=/etc/pki/ca-trust/extracted/java/cacerts
    JENKINS_JAVA_OPTIONS: -Dhttps.protocols=TLSv1.2 -Xmx1536m -Xms512m -XX:+UseG1GC -XX:+ExplicitGCInvokesConcurrent -XX:+ParallelRefProcEnabled -XX:+UseStringDeduplication -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=20 -XX:+UnlockDiagnosticVMOptions -XX:G1SummarizeRSetStatsPeriod=1
  toolsManager:
    alternatives:
      javaEngine: java_sdk_11_openjdk
    asdf:
      plugins:
        maven: https://github.com/halcyon/asdf-maven.git
        helm: https://github.com/Antiarchitect/asdf-helm.git
      tools:
        maven: 3.6.3
        helm: 3.12.1
    graalVmTools:
      javaEngine: 22.3.0-java17
      plugins:
        - native-image

---

kind: ReleaseDescriptor
apiVersion: release.giss.es/v1
metadata:
  name: back-main
  namespace: gint-ot-fdar
spec:
  releaseConfigs:
    - id: defaultReleaseConfig
      runtimeTech: java
      runtimeTechVersion: '21'
      runtimeTechTag: ''
      configPath: "src/main"
      ocNamespaceSuffix: ot-fdar # Si no se especifica se toma el valor extrayendolo del nombre del repositorio
      chartVersion: "1.19.0"
      chartName: ot-fdarback_main
      baseImageName: openjdk
</file>

<file path="src/es/giss/framework/core/cdi/annotations/Inject.groovy">
package es.giss.framework.core.cdi.annotations

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.FIELD])
@interface Inject {

}
</file>

<file path="src/es/giss/framework/core/cdi/annotations/PipelineComponent.groovy">
package es.giss.framework.core.cdi.annotations

import es.giss.framework.core.cdi.ConfigurationPriority

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target


@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE])
@interface PipelineComponent {

    String name() default ''

    ConfigurationPriority priority() default ConfigurationPriority.LOWEST

}
</file>

<file path="src/es/giss/framework/core/cdi/annotations/Qualifier.groovy">
package es.giss.framework.core.cdi.annotations

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.FIELD, ElementType.PARAMETER])
@interface Qualifier {

    String value() default ''

}
</file>

<file path="src/es/giss/framework/core/cdi/dependencies/DependencyGraph.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.Qualifier

import java.lang.annotation.Annotation
import java.lang.reflect.Constructor

class DependencyGraph {

    private final Map<DependencyKey, Node> graph = [:]

    @NonCPS
    Node addNode(DependencyKey key, Class<?> clazz) {
        if (graph.containsKey(key)) {
            throw new Exception("""The interfaz ${key.type.simpleName} is already registered with qualifier name '${key.name}'.
              Please ensure that the class ${clazz.name} is annotated with @PipelineComponent and the qualifier name is unique.                                   
            """)
        }
        Node node = new Node(key, clazz)
        graph.put(key, node)
        return node
    }

    @NonCPS
    List<Node> resolveDependencies() {
        for (Node node : graph.values()) {
            addDependencies(node)
        }
        return sortNodesByDependencies()
    }

    @NonCPS
    private void addDependencies(Node node) {
        Class<?> clazz = node.getClazz()
        Constructor<?> constructor = clazz.getConstructors()[0]
        Annotation[][] paramAnnotations = constructor.getParameterAnnotations()
        Class<?>[] paramTypes = constructor.getParameterTypes()

        for (int i = 0; i < paramTypes.length; i++) {
            String name = ''
            for (Annotation annotation : paramAnnotations[i]) {
                if (annotation instanceof Qualifier) {
                    name = ((Qualifier) annotation).value()
                }
            }

            DependencyKey keyDependency = resolveDependencyKey(paramTypes[i], name, node.getKey().getPriority())
            Node paramNode = graph.get(keyDependency)

            if (paramNode == null) {
                throw new Exception("Dependency not found: ${keyDependency} for ${node.clazz.name}. Check if the class exists or the qualifier name is correct")
            }
            node.addDependency(paramNode)
        }
    }

    @NonCPS
    private List<Node> sortNodesByDependencies() {
        Set<Class> references = findCyclicReferences()

        if (references.size() > 0) {
            throw new Exception("Circular dependency detected: ${references.collect { it.name }.join(' depends on ')}")
        }

        List<Node> nodes = new ArrayList<>(graph.values())
        List<Node> sortedNodes = new ArrayList<>(nodes.size())
        Set<Node> visited = [] as Set

        for (Node node : nodes) {
            topologicalSort(node, visited, sortedNodes)
        }

        return sortedNodes.reverse()
    }

    @NonCPS
    private void topologicalSort(Node node, Set<Node> visited, List<Node> sortedNodes) {
        if (!visited.any { it.key == node.key }) {
            visited.add(node)

            for (Node dependency : node.getDependencies()) {
                topologicalSort(dependency, visited, sortedNodes)
            }
            sortedNodes.add(0, node)
        }
    }

    @NonCPS
    private Set<Class> findCyclicReferences() {
        Set<Node> visited = [] as Set
        Set<Node> recursionStack = [] as Set

        for (Node node : graph.values()) {
            if (detectCycle(node, visited, recursionStack)) {
                return recursionStack.collect { it.clazz }
            }
        }
        return [] as Set
    }

    @NonCPS
    private boolean detectCycle(Node node, Set<Node> visited, Set<Node> recursionStack) {
        if (recursionStack.contains(node)) {
            return true
        }

        if (visited.contains(node)) {
            return false
        }

        visited.add(node)
        recursionStack.add(node)

        for (Node dependency : node.getDependencies()) {
            if (detectCycle(dependency, visited, recursionStack)) {
                return true
            }
        }

        recursionStack.remove(node)
        return false
    }

    @NonCPS
    static DependencyKey resolveDependencyKey(Class type, String name, ConfigurationPriority priority = ConfigurationPriority.LOW) {
        DependencyKey dependencyKey = new DependencyKey(type, name, priority)
        return dependencyKey
    }

}
</file>

<file path="src/es/giss/framework/core/cdi/dependencies/DependencyKey.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority


class DependencyKey {

    String name
    Class<?> type
    ConfigurationPriority priority

    DependencyKey(
            Class<?> type,
            String name = '',
            ConfigurationPriority priority = ConfigurationPriority.LOW
    ) {
        this.name = name
        this.type = type
        this.priority = priority
    }

    @NonCPS
    @Override
    boolean equals(Object obj) {
        if (obj == null) {
            return false
        }
        if (obj instanceof DependencyKey) {
            DependencyKey other = (DependencyKey) obj
            return name.equals(other.name) && type.equals(other.type)
        }
        return false
    }

    @NonCPS
    @Override
    int hashCode() {
        return Objects.hash(name, type.name)
    }

    @NonCPS
    @Override
    String toString() {
        return "DependencyKey name: $name, type: $type, priority: $priority"
    }

}
</file>

<file path="src/es/giss/framework/core/cdi/dependencies/DependencyResolver.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.cdi.annotations.Qualifier
import es.giss.framework.core.cdi.annotations.PipelineComponent

import java.lang.reflect.Field
import java.util.concurrent.ConcurrentHashMap

class DependencyResolver implements IDependencyResolver {
    private Map<DependencyKey, Object> instances
    private DependencyGraph graph

    DependencyResolver() {
        graph = new DependencyGraph()
        instances = new ConcurrentHashMap<>()
    }

    @NonCPS
    Map<DependencyKey, Object> getInstances() {
        return instances
    }

    @NonCPS
    int getSizedInstances() {
        return instances.size()
    }


    @NonCPS
    def <T> T getInstance(Class<T> type, String name = '') {
        DependencyKey keyDependency = DependencyGraph.resolveDependencyKey(type, name)
        def instance = instances.get(keyDependency) as T
        if (instance == null) {
            throw new Exception("Dependency not found for type: '${type.simpleName}' and Qualifier name: '${name}'. Check if the class exists or the qualifier name is correct. Current Instances Names: ${instances.keySet().collect { it.name }}.")
        }
        return instance
    }

    @NonCPS
    void register(Class<?> type, Class<?> dependencyClass) {
        def annotation = dependencyClass.getAnnotation(PipelineComponent)
        if (annotation == null) {
            throw new IllegalArgumentException("The class ${dependencyClass.name} is not annotated with @PipelineComponent. Please annotate the class with @PipelineComponent.")
        }
        def name = annotation?.name()
        def priority = annotation?.priority()
        DependencyKey dependencyKey = DependencyGraph.resolveDependencyKey(type, name, priority)
        registerWithKey(dependencyKey, dependencyClass)
    }

    @NonCPS
    void registerWithKey(DependencyKey dependencyKey, Class<?> componentClass) {
        if (!instances.containsKey(dependencyKey)) {
            ensureIsInstanceOf(dependencyKey.type, componentClass)
            graph.addNode(dependencyKey, componentClass)
        }
    }


    @NonCPS
    void initialize() {
        // Only process the nodes that are not already initialized
        List<Node> nodes = graph.resolveDependencies().findAll { this.instances[it.key] == null }

        nodes.each { node ->
            def instance = createNewInstanceByConstructor(node)
            if(instance == null) {
                throw new Exception("The class ${node.getClazz().name} does not have a public constructor. Please ensure that the class has a public constructor.")
            }
            if(this.instances.containsKey(node.key)) {
                throw new Exception("The class ${node.getClazz().name} is already registered. Please ensure that the class annotated with @PipelineComponent and the qualifier name is unique.")
            }
            this.instances[node.key] = instance
        }

        nodes.each { node ->
            injectDependenciesByFields(this.instances[node.key])
        }
    }

    @NonCPS
    void registerCoreComponent(Class<?> type, Object instance) {
        DependencyKey key = DependencyGraph.resolveDependencyKey(type, '')
        instances.put(key, instance)
        graph.addNode(key, instance.getClass())
    }

    @NonCPS
    protected Object createNewInstanceByConstructor(Node node) {
        def clazz = node.getClazz()
        def constructor = clazz.getConstructors()[0]
        def dependencies = node.getDependencies().collect { this.instances[it.key] }
        return constructor.newInstance(dependencies.toArray())
    }

    @NonCPS
    protected void injectDependenciesByFields(Object instance) {
        for (def instanceClass = instance.class; instanceClass != null; instanceClass = instanceClass.getSuperclass()) {
            for (Field field : instanceClass.declaredFields) {
                if (!isAnnotated(field)) {
                    continue
                }
                Qualifier qualifierAnnotation = field.getAnnotation(Qualifier)
                def fieldType = field.getType()
                Object dependency
                if (qualifierAnnotation) {
                    dependency = getInstance(fieldType, qualifierAnnotation.value())
                } else {
                    dependency = getInstance(fieldType)
                }

                ensureIsInstanceOf(fieldType, dependency.getClass())

                field.setAccessible(true)
                field.set(instance, dependency)
            }
        }
    }

    @NonCPS
    private void ensureIsInstanceOf(Class<?> type, Class<?> dependency) {
        if (!type.isAssignableFrom(dependency)) {
            throw new IllegalArgumentException("The registered class ${dependency.name} does not implement the dependency interface ${type.simpleName}. Please ensure that the registered class is an implementation of the dependency interface.")
        }
    }

    @NonCPS
    private static Boolean isAnnotated(Field field) {
        return !field.synthetic && field.getAnnotation(Inject)
    }

}
</file>

<file path="src/es/giss/framework/core/cdi/dependencies/IDependencyResolver.groovy">
package es.giss.framework.core.cdi.dependencies

interface IDependencyResolver {
    Map<DependencyKey, Object> getInstances()
    int getSizedInstances()
    def <T> T getInstance(Class<T> type)
    def <T> T getInstance(Class<T> type, String name)
    void register(Class<?> type, Class<?> dependencyClass)
    void initialize()
    void registerCoreComponent(Class<?> type, Object instance)
}
</file>

<file path="src/es/giss/framework/core/cdi/dependencies/Node.groovy">
package es.giss.framework.core.cdi.dependencies

import com.cloudbees.groovy.cps.NonCPS

class Node {

    private final DependencyKey key
    private final Class<?> clazz
    private final List<Node> dependencies

    Node(DependencyKey key, Class<?> clazz) {
        this.key = key
        this.clazz = clazz
        this.dependencies = []
    }

    @NonCPS
    void addDependency(Node node) {
        this.dependencies.add(node)
    }

    @NonCPS
    List<Node> getDependencies() {
        return dependencies
    }

    @NonCPS
    Class<?> getClazz() {
        return clazz
    }

    @NonCPS
    DependencyKey getKey() {
        return key
    }

    @NonCPS
    @Override
    boolean equals(Object obj) {
        if (obj == null) {
            return false
        }

        if (obj instanceof Node) {
            Node other = (Node) obj
            def collectKeyAndClass = { node -> [node.key, node.clazz] }
            return key.equals(other.key) &&
                    clazz.equals(other.clazz) &&
                    dependencies.size() == other.dependencies.size() &&
                    dependencies.collect(collectKeyAndClass) == other.dependencies.collect(collectKeyAndClass)
        }
        return false
    }

    @NonCPS
    @Override
    int hashCode() {
        return key.hashCode() + clazz.hashCode() + dependencies.collect { [it?.key, it?.clazz] }.hashCode()
    }

    @NonCPS
    @Override
    String toString() {
        return "Node key: $key, clazz: $clazz"
    }

}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/fiters/AcceptEverythingResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

class AcceptEverythingResourceFilter<T> implements ResourceFilter<T> {
    @NonCPS
    @Override
    boolean acceptScannedResource(T item) {
        return true
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/fiters/AnnotatedClassResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

import java.lang.annotation.Annotation

class AnnotatedClassResourceFilter implements ResourceFilter<Class<?>> {

    protected Class<? extends Annotation> annotationClass;

    AnnotatedClassResourceFilter(Class<? extends Annotation> annotationClass) {
        this.annotationClass = annotationClass;
    }

    @NonCPS
    @Override
    public boolean acceptScannedResource(Class<?> item) {
        return item.isAnnotationPresent(annotationClass);
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/fiters/ChainedResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

class ChainedResourceFilter<T> implements ResourceFilter<T> {

    enum Mode {
        And, Or, Not
    }

    protected List<ResourceFilter<T>> filters
    protected Mode mode

    ChainedResourceFilter(Mode mode, ResourceFilter<T>... filters) {

        if (filters == null || filters.length == 0) {
            throw new IllegalArgumentException("no filters provided")
        }

        this.filters = Arrays.asList(filters)
        this.mode = mode
    }

    @NonCPS
    @Override
    boolean acceptScannedResource(T item) {

        for (ResourceFilter<T> filter : filters) {
            boolean accepted = filter.acceptScannedResource(item)

            if (accepted) {
                if (mode == Mode.Or) {
                    return true
                }

                if (mode == Mode.Not) {
                    return false
                }
            } else if (mode == Mode.And) {
                return false
            }
        }

        // And and Not are fail-fast, so if we reach the end, then our criteria is met.
        // Or would have already returned if it were successful.
        return mode == Mode.And || mode == Mode.Not
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/fiters/ExtendsClassResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.fiters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter

import java.lang.reflect.Modifier

class ExtendsClassResourceFilter implements ResourceFilter<Class<?>> {

    protected Class baseClass
    protected boolean concreteOnly

    ExtendsClassResourceFilter(Class baseClass, boolean concreteOnly) {
        this.baseClass = baseClass
        this.concreteOnly = concreteOnly
    }

    @NonCPS
    @Override
    boolean acceptScannedResource(Class item) {
        return baseClass.isAssignableFrom(item) && (!concreteOnly || !(item.isInterface() || Modifier.isAbstract(item.getModifiers())))
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/interfaces/ResourceFilter.groovy">
package es.giss.framework.core.cdi.scanner.interfaces

interface ResourceFilter<T> {

    /**
     * Convenience implementation that doesn't filter anything.
     * Provided as a class instead of a static final member to take advantage of generics.*/

    /**
     * Convenience implementation that filters everything.
     * Provided as a class instead of a static final member to take advantage of generics.*/
    boolean acceptScannedResource(T item);
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/interfaces/ResourceLoader.groovy">
package es.giss.framework.core.cdi.scanner.interfaces


import java.util.jar.JarEntry
import java.util.jar.JarFile

interface ResourceLoader<T> {

    T loadFromJarfile(String packageName, JarFile jarFile, JarEntry entry);

    T loadFromFilesystem(String packageName, File directory, String fileName);
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/interfaces/ResourceVisitor.groovy">
package es.giss.framework.core.cdi.scanner.interfaces

interface ResourceVisitor<T> {

    /**
     * called once for each resources that has been loaded and passed all filter criteria.
     * @param resource as loaded by a {@link ResourceLoader} implementation.
     */
    void visit(T resource);
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/ClassesInPackageScanner.groovy">
package es.giss.framework.core.cdi.scanner

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.fiters.AnnotatedClassResourceFilter
import es.giss.framework.core.cdi.scanner.fiters.ChainedResourceFilter
import es.giss.framework.core.cdi.scanner.fiters.ExtendsClassResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceLoader
import org.apache.commons.lang.StringUtils

import java.lang.annotation.Annotation
import java.util.jar.JarEntry
import java.util.jar.JarFile

class ClassesInPackageScanner extends PackageScanner<Class<?>> {

    ClassesInPackageScanner() {
        this(getDefaultClassLoader(), false)
    }

    ClassesInPackageScanner(ClassLoader classLoader, boolean includeInnerClasses) {
        super(new ClassResourceLoader(classLoader, includeInnerClasses))
    }

    @NonCPS
    Set<Class<?>> findAnnotatedClasses(String packageName, Class<? extends Annotation> annoClass) throws IOException {
        return scanWithExtraFilter(packageName, new AnnotatedClassResourceFilter(annoClass));
    }


    @NonCPS
    <T> Set<Class<? extends T>> findImplementers(String packageName, Class<T> baseClass) throws IOException {
        // javac fails to compile without the generic clue
        //noinspection RedundantTypeArguments
        return this.<T> scanWithExtraFilter(packageName, new ExtendsClassResourceFilter(baseClass, true))
    }

    @NonCPS
    Set<Class<?>> findDefaultImplementers(String packageName, Class<?> baseClass) throws IOException {
        return scan(packageName)
    }

    @NonCPS
    protected <T> Set<Class<? extends T>> scanWithExtraFilter(String packageName, ResourceFilter<Class<?>> extraFilter) throws IOException {

        ResourceFilter<Class<?>> currentFilter = this.resourceFilter
        try {
            this.resourceFilter = new ChainedResourceFilter<Class<?>>(ChainedResourceFilter.Mode.And,
                    extraFilter,
                    currentFilter)

            Set classes = scan(packageName)

            //noinspection unchecked
            return (Set<Class<? extends T>>) classes
        } finally {
            this.resourceFilter = currentFilter
        }
    }

    static class ClassResourceLoader implements ResourceLoader<Class<?>> {


        protected ClassLoader classLoader
        protected boolean includeInnerClasses

        ClassResourceLoader(ClassLoader classLoader, boolean includeInnerClasses) {
            this.classLoader = classLoader
            this.includeInnerClasses = includeInnerClasses
        }


        @NonCPS
        @Override
        Class<?> loadFromJarfile(String packageName, JarFile jarFile, JarEntry entry) {
            return loadClassFromFile(packageName, StringUtils.substringAfterLast(entry.getName(), "/"))
        }

        @NonCPS
        @Override
        Class<?> loadFromFilesystem(String packageName, File directory, String fileName) {
            return loadClassFromFile(packageName, fileName)
        }

        @SuppressWarnings('grvy:org.codenarc.rule.logging.PrintlnRule')
        @NonCPS
        protected Class<?> loadClassFromFile(String packageName, String fileName) {
            if (((fileName.endsWith(".groovy") || fileName.endsWith(".class")) && (includeInnerClasses || fileName.indexOf("\$") < 0))) {
                try {
                    GroovyClassLoader cLoader = new GroovyClassLoader(classLoader)
                    return cLoader.loadClass(packageName + "." + StringUtils.substringBeforeLast(fileName, "."))
                } catch (Exception e) {
                    println("Error classNotFound $e.message")
                }
            }

            return null
        }
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/scanner/PackageScanner.groovy">
package es.giss.framework.core.cdi.scanner

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.scanner.fiters.AcceptEverythingResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceFilter
import es.giss.framework.core.cdi.scanner.interfaces.ResourceLoader
import es.giss.framework.core.cdi.scanner.interfaces.ResourceVisitor
import org.apache.commons.io.FileUtils
import org.apache.commons.lang.StringUtils

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.regex.Matcher
import java.util.regex.Pattern

class PackageScanner<T> {
    protected ClassLoader classLoader
    protected ResourceLoader<T> resourceLoader
    protected boolean recursive = true
    protected ResourceFilter<T> resourceFilter = new AcceptEverythingResourceFilter<T>()

    /**
     * Creates an instance with the {@link ResourceLoader} and a default {@link ClassLoader}.
     * @param resourceLoader
     */
    PackageScanner(ResourceLoader<T> resourceLoader) {
        this(getDefaultClassLoader(), resourceLoader)
    }

    /**
     * Advanced : use this constructor if you need to specify the {@link ClassLoader}.
     * @param classLoader
     * @param resourceLoader
     */
    PackageScanner(ClassLoader classLoader, ResourceLoader<T> resourceLoader) {
        this.classLoader = classLoader
        this.resourceLoader = resourceLoader
    }

    @NonCPS
    PackageScanner<T> setResourceFilter(ResourceFilter<T> resourceFilter) {
        this.resourceFilter = resourceFilter
        return this
    }

    /**
     * performs an exhaustive recursive scan under package <code>packageName</code>.
     * @param packageName
     * @return
     * @throws IOException
     */
    @NonCPS
    Set<T> scan(String packageName) throws IOException {
        final Set<T> result = new HashSet<T>()
        visit({
            result.add(it)
        } as ResourceVisitor, packageName)

        return result
    }

    @NonCPS
    void visit(ResourceVisitor<T> visitor, String packageName) throws IOException {

        // on windows, the Sun JVM uses uses '/' and not '\' (File.separatorChar) in the classpath
        // thanks to jeremy chone (http://www.bitsandbuzz.com/) for this insight.
        //
        // NOTE : for non-Sun JVMs, i have not idea what the behavior is.  but i'm not going to lose
        // any sleep over it. ;)
        packageName = packageName.replace('.', '/')
        Pattern packageDirMatcher = Pattern.compile("(" + Pattern.quote(packageName) + "(/.*)?)\$")

        Enumeration<URL> dirs = classLoader.getResources(packageName)

        while (dirs.hasMoreElements()) {
            String path = URLDecoder.decode(dirs.nextElement().getPath(), "UTF-8")

            if (path.contains(".jar!") || path.contains("zip!")) {
                String jarName = path.substring("file:".length())
                jarName = jarName.substring(0, jarName.indexOf('!'))

                JarFile jarFile = new JarFile(jarName)
                visitJarFile(jarFile, packageName, visitor)

            } else {
                File dir = new File(path)
                Matcher dirMatcher = packageDirMatcher.matcher(path)

                if (dirMatcher.find()) {
                    visitDirectory(dir, packageDirMatcher, visitor)
                }
            }
        }
    }

    @NonCPS
    protected void visitJarFile(JarFile jarFile, String packageNameForJarPath, ResourceVisitor<T> visitor) {

        Enumeration<JarEntry> entries = jarFile.entries()
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement()

            String entryPackage = StringUtils.substringBeforeLast(entry.getName(), "/")
            if (packageNameForJarPath.equals(entryPackage) || (recursive && entryPackage.startsWith(packageNameForJarPath))) {

                String packageName = entryPackage.replace('/', '.')
                if (!entry.isDirectory()) {

                    T resource = resourceLoader.loadFromJarfile(packageName, jarFile, entry)
                    if (resource != null && resourceFilter.acceptScannedResource(resource)) {
                        visitor.visit(resource)
                    }
                }
            }
        }
    }

    @NonCPS
    protected void visitDirectory(File dir, Pattern packageDirMatcher, ResourceVisitor<T> visitor) {

        for (Object obj : FileUtils.listFiles(dir, null, recursive)) {
            File file = (File) obj

            // because the JVM appears to use '/' on all platforms in the classpath entries, this pattern
            // always ends up with '/' and never File.separatorChar.  so, on windows, we'll need to modify
            // our search pattern.
            String absolutePath = file.getParentFile().getAbsolutePath()
            if (File.separatorChar != '/') {
                absolutePath = absolutePath.replace(File.separatorChar, '/' as char)
            }

            Matcher dirMatcher = packageDirMatcher.matcher(absolutePath)
            if (dirMatcher.find()) {
                String packageNameForDir = dirMatcher.group(1).replace('/', '.')


                T resource = resourceLoader.loadFromFilesystem(packageNameForDir, file.getParentFile(), file.getName())
                if (resource != null && resourceFilter.acceptScannedResource(resource)) {
                    visitor.visit(resource)
                }

            }
        }
    }

    @NonCPS
    static ClassLoader getDefaultClassLoader() {
        return PackageScanner.class.getClassLoader()
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/ConfigurationPriority.groovy">
package es.giss.framework.core.cdi

enum ConfigurationPriority {

    HIGHEST(1), HIGH(2), MEDIUM(5), LOW(10), LOWEST(15)

    final Integer value

    private ConfigurationPriority(Integer value) {
        this.value = value
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/ContextSinglenton.groovy">
package es.giss.framework.core.cdi


import es.giss.framework.core.PipelineContext

class ContextSinglenton {
    private static PipelineContext instance

    private ContextSinglenton() {
        // constructor privado
    }

    static synchronized PipelineContext getContext() {
        if (instance == null) {
            throw new IllegalStateException('Pipeline context not created')
        }
        return instance
    }

    static synchronized PipelineContext createPipelineContext(
            Script steps,
            List<String> scanPackageNames = ['es.giss.framework']) {
        if (instance == null) {
            instance = new PipelineContext(steps)
            instance.registerComponentsFromPackages(scanPackageNames)
            instance.registerConfigAdaptersFromPackages(scanPackageNames)
        }
        return instance
    }
}
</file>

<file path="src/es/giss/framework/core/cdi/IServiceLocator.groovy">
package es.giss.framework.core.cdi


interface IServiceLocator extends Serializable {

    void registerComponentsFromPackages()

    void registerComponentsFromPackages(List<String> packageNames)

    void registerConfigAdaptersFromPackages()

    void registerConfigAdaptersFromPackages(List<String> packageName)

    def <T> T getComponent(Class<T> type, String name)

    def <T> T getComponent(Class<T> type)

}
</file>

<file path="src/es/giss/framework/core/config/ConfigClient.groovy">
package es.giss.framework.core.config

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Stage
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IConfigClient
import es.giss.framework.core.logger.LogLevel

@PipelineComponent
class ConfigClient extends Stage implements IConfigClient {

    private List<IConfigAdapter> adapters = []

    @Override
    void addAdapter(IConfigAdapter adapter) {
        adapters.add(adapter)
    }

    @Override
    void loadData() {
        sortAdapters(adapters)
                .each { adapter ->
                    try {
                        adapter.resolveConfiguration(pipeline)
                        logger.debug("Configuration loaded from adapter ${adapter.getClass().name}")
                    } catch (Exception e) {
                        logger.warn("Error processing adapter ${adapter.getClass().name}. Error Message: ${e.message}")
                    }

                }
        logger.printPrettyLog(LogLevel.DEBUG, 'Configuration is resolved:', pipeline.modelDataToMap())

    }

    @Override
    void configureEntities() {
        stage('Process Configuration') {
            loadData()
            pipeline.configureServicesByPriority()
        }
    }

    @NonCPS
    def sortAdapters(List<IConfigAdapter> l) {
        return l.sort { a, b -> getPriority(b) <=> getPriority(a) }
    }

    @NonCPS
    int getPriority(Object a) {
        PipelineComponent pipelineComponent = a.class.getAnnotation(PipelineComponent)
        return pipelineComponent?.priority().value ?: 1000
    }


}
</file>

<file path="src/es/giss/framework/core/events/interfaces/DataModel.groovy">
package es.giss.framework.core.events.interfaces

interface DataModel extends Cloneable, Serializable {

    Map<String, Object> toMap()

}
</file>

<file path="src/es/giss/framework/core/events/interfaces/PipelineModel.groovy">
package es.giss.framework.core.events.interfaces

interface PipelineModel extends DataModel {}
</file>

<file path="src/es/giss/framework/core/events/interfaces/ProjectDescriptorModel.groovy">
package es.giss.framework.core.events.interfaces

interface ProjectDescriptorModel extends DataModel {}
</file>

<file path="src/es/giss/framework/core/events/interfaces/TelemetryModel.groovy">
package es.giss.framework.core.events.interfaces

interface TelemetryModel extends DataModel {}
</file>

<file path="src/es/giss/framework/core/events/ConfiguredPipelineEvent.groovy">
package es.giss.framework.core.events

import es.giss.framework.core.events.interfaces.PipelineModel

class ConfiguredPipelineEvent extends PipelineEvent<PipelineModel> {}
</file>

<file path="src/es/giss/framework/core/events/ConfiguredProjectDescriptorEvent.groovy">
package es.giss.framework.core.events

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ConfiguredProjectDescriptorEvent extends PipelineEvent<ProjectDescriptorModel> {}
</file>

<file path="src/es/giss/framework/core/events/PipelineEvent.groovy">
package es.giss.framework.core.events

abstract class PipelineEvent<T> implements Serializable {
    String description = ''
    long timeMillis = 0
    T payload

}
</file>

<file path="src/es/giss/framework/core/events/TelemetryEvent.groovy">
package es.giss.framework.core.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class TelemetryEvent extends PipelineEvent<TelemetryModel> {}
</file>

<file path="src/es/giss/framework/core/interfaces/AssignableArtifactsRepository.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.project.ArtifactsRepository

interface AssignableArtifactsRepository {

    ArtifactsRepository getArtifactsRepository()

    void setArtifactsRepository(ArtifactsRepository artifactsRepository)

}
</file>

<file path="src/es/giss/framework/core/interfaces/AutomationToolDefinition.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.resources.ProjectDefinitionFile

import java.nio.file.Path

interface AutomationToolDefinition <F extends ProjectDefinitionFile> {

    void setFileDefinitionPath(Path fileDefinitionPath)

    F readFileDefinition()

}
</file>

<file path="src/es/giss/framework/core/interfaces/Configurable.groovy">
package es.giss.framework.core.interfaces



interface Configurable {

    void configure(IPipelineContext context)
}
</file>

<file path="src/es/giss/framework/core/interfaces/IArtifactRepositoryType.groovy">
package es.giss.framework.core.interfaces

interface IArtifactRepositoryType {

}
</file>

<file path="src/es/giss/framework/core/interfaces/IArtifactType.groovy">
package es.giss.framework.core.interfaces

interface IArtifactType {
    String getName()

    String getExtension()

}
</file>

<file path="src/es/giss/framework/core/interfaces/IBuildAutomationTool.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.project.Artifact
import es.giss.framework.core.vo.project.strategies.BuildStrategy
import es.giss.framework.core.vo.project.strategies.PublishStrategy
import es.giss.framework.core.vo.project.strategies.TestStrategy
import es.giss.framework.core.vo.resources.ProjectDefinitionFile

interface IBuildAutomationTool<A extends Artifact, F extends ProjectDefinitionFile> extends ITool,
        AssignableArtifactsRepository, AutomationToolDefinition<F>, IToolVersionable {

    boolean test(TestStrategy testStrategy)

    A build(BuildStrategy buildStrategy)

    void publish(PublishStrategy publishStrategy, A artifact)

}
</file>

<file path="src/es/giss/framework/core/interfaces/IConfigAdapter.groovy">
package es.giss.framework.core.interfaces


interface IConfigAdapter  {
    void resolveConfiguration(IPipelineContext context)
}
</file>

<file path="src/es/giss/framework/core/interfaces/IConfigClient.groovy">
package es.giss.framework.core.interfaces

interface IConfigClient {

    void addAdapter(IConfigAdapter adapter)

    void loadData()

    void configureEntities()


}
</file>

<file path="src/es/giss/framework/core/interfaces/Identifiable.groovy">
package es.giss.framework.core.interfaces

interface Identifiable {

    String getId()

    void setId(String id)
}
</file>

<file path="src/es/giss/framework/core/interfaces/IDeployAutomationTool.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.vo.project.Artifact
import es.giss.framework.core.vo.project.strategies.DeployStrategy
import es.giss.framework.core.vo.project.strategies.RollbackStrategy
import es.giss.framework.core.vo.project.strategies.UndeployStrategy
import es.giss.framework.core.vo.resources.ProjectDefinitionFile


interface IDeployAutomationTool<A extends Artifact, F extends ProjectDefinitionFile>
        extends ITool, AssignableArtifactsRepository, AutomationToolDefinition<F>, IToolVersionable {

    def deploy(DeployStrategy deployStrategy, A artifact)

    def undeploy(UndeployStrategy unDeployStrategy, A artifact)

    def rollback(RollbackStrategy rollBackStrategy, A artifact)

}
</file>

<file path="src/es/giss/framework/core/interfaces/ILogger.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.logger.LogLevel

interface ILogger extends Configurable {

    void setLogLevel(LogLevel level)

    void info(String message)

    void warn(String message)

    void debug(String message)

    void error(String message)

    void fatal(String message)

    void info(String tag, String message)

    void warn(String tag, String message)

    void debug(String tag, String message)

    void error(String tag, String message)

    void fatal(String tag, String message)

    void executeWhenDebug(Closure body)

    def <T> void printPrettyLog(LogLevel level, T obj)

    def <T> void printPrettyLog(LogLevel level, String title, T obj)

    void logPrettyMessages(LogLevel level, List<String> messages)

    void logPrettyError(List<String> msgs)

}
</file>

<file path="src/es/giss/framework/core/interfaces/Initializable.groovy">
package es.giss.framework.core.interfaces

interface Initializable {
    void initialize()
}
</file>

<file path="src/es/giss/framework/core/interfaces/INotificationSender.groovy">
package es.giss.framework.core.interfaces

interface INotificationSender {

}
</file>

<file path="src/es/giss/framework/core/interfaces/IPipelineContext.groovy">
package es.giss.framework.core.interfaces

import es.giss.framework.core.cdi.IServiceLocator
import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.events.interfaces.PipelineModel
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.storage.Store

interface IPipelineContext extends IServiceLocator {

    List<String> getSkipStages()

    void addSkipStage(String stage)

    void injectEnvironmentVariables(Map<String, String> envVars)

    void configureServicesByPriority()

    void setAutoCancelled(Boolean autoCancel)

    Boolean isAutoCancelled()

    void setDebugMode(Boolean debugMode)

    Boolean isDebugMode()

    Map groupInstancesByPriority()

    String resolveControllerName()

    String getEnvironment()

    String resolveControllerDomain()

    String getAppNamespace()

    Store<? extends PipelineModel> getStore(Class<? extends PipelineModel> modelClass)

    void addStore(Class<? extends PipelineModel> modelClass, Store<? extends PipelineModel> store)

    void dispatch(PipelineEvent event)

    void initializePipelineDefaultStore(PipelineModel... models)

    void initializeProjectDescriptorStore(ProjectDescriptorModel... models)

    void initializeTelemetryStore(TelemetryModel... models)

    Map modelDataToMap()


}
</file>

<file path="src/es/giss/framework/core/interfaces/IStage.groovy">
package es.giss.framework.core.interfaces

interface IStage {
    def stage(String name, Closure body)
}
</file>

<file path="src/es/giss/framework/core/interfaces/ISteps.groovy">
package es.giss.framework.core.interfaces


interface ISteps {

}
</file>

<file path="src/es/giss/framework/core/interfaces/ITool.groovy">
package es.giss.framework.core.interfaces

interface ITool extends Configurable {

    Integer executeWithStatus(String command, options)

    String execute(String command, options)


}
</file>

<file path="src/es/giss/framework/core/interfaces/IToolVersionable.groovy">
package es.giss.framework.core.interfaces

interface IToolVersionable {

    void useToolVersion(String version)

    String getToolVersion()
}
</file>

<file path="src/es/giss/framework/core/interfaces/Versionable.groovy">
package es.giss.framework.core.interfaces

interface Versionable {

    String getCurrentVersion()

    void useVersion(String version)

}
</file>

<file path="src/es/giss/framework/core/logger/AnsiColor.groovy">
package es.giss.framework.core.logger

import com.cloudbees.groovy.cps.NonCPS

enum AnsiColor implements Serializable {
    RESET('\u001B[0m'),
    BOLD('\u001B[1m'),
    ITALIC('\u001B[3m'),
    EMPTY_STYLE(''),
    RED('\u001B[38;5;1m'),
    GREEN('\u001B[32m'),
    DARK_GREEN('\u001B[38;5;28m'),
    YELLOW('\u001B[38;5;208m'),
    MAGENTA('\u001B[35m'),
    DARK_MAGENTA('\u001B[38;5;5m'),
    BLUE('\u001B[34m'),
    DARK_BLUE('\u001B[38;5;25m'),
    CYAN('\u001B[36m'),
    DARK_CYAN('\u001B[38;5;39m'),





    final String colorCode

    AnsiColor(String colorCode) {
        this.colorCode = colorCode
    }

    @NonCPS
    @Override
    String toString() {
        return this.colorCode
    }
}
</file>

<file path="src/es/giss/framework/core/logger/Logger.groovy">
package es.giss.framework.core.logger

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class Logger implements ILogger {

    private LogLevel level = LogLevel.INFO
    protected Script steps

    Logger(Script steps) {
        this.steps = steps
    }

    void logMessage(LogLevel level, String tag, String message) {
        if (isLoggable(level)) {
            String header = "${level.getColor().colorCode}${level.getStyle().colorCode}[${level}] "
            String tagFormatted = tag ? "[${tag}] " : ''
            String body = message;
            String footer = AnsiColor.RESET.colorCode;

            steps.ansiColor('xterm') {
                String msg = "${header}${tagFormatted}${body}${footer}"
                this.steps.echo msg;
            }
        }
    }

    private Boolean isLoggable(LogLevel level) {
        return level.levelNumber <= this.level.levelNumber
    }

    @Override
    void setLogLevel(LogLevel level) {
        this.level = level
        info("Logger configured with log level: ${this.level}")

    }

    @Override
    void info(String message) {
        info('', message)
    }

    @Override
    void warn(String message) {
        warn('', message)
    }

    @Override
    void debug(String message) {
        debug('', message)
    }

    @Override
    void error(String message) {
        error('', message)
    }

    @Override
    void error(String tag, String message) {
        logMessage(LogLevel.ERROR, tag, message)
    }

    @Override
    void fatal(String tag, String message) {
        logMessage(LogLevel.FATAL, tag, message)
    }

    @Override
    void fatal(String message) {
        fatal('', message)
    }

    @Override
    void info(String tag, String message) {
        logMessage(LogLevel.INFO, tag, message)
    }

    @Override
    void warn(String tag, String message) {
        logMessage(LogLevel.WARN, tag, message)
    }

    @Override
    void debug(String tag, String message) {
        logMessage(LogLevel.DEBUG, tag, message)
    }

    @Override
    void executeWhenDebug(Closure body) {
        if (level == LogLevel.DEBUG) {
            info("Executing debug closure")
            body()
        }
    }

    @Override
    <T> void printPrettyLog(LogLevel level, T obj) {
        if (isLoggable(level)) {
            logMessage(level, '', extendPrettyPrint(obj, 0, new StringBuilder()).toString())
        }
    }

    @Override
    <T> void printPrettyLog(LogLevel level, String title, T obj) {
        if (isLoggable(level)) {
            StringBuilder sb = new StringBuilder()
            sb.append(title).append('\n')
            sb.append('='.multiply(title.length()+8)).append('\n')
            logMessage(level, '', extendPrettyPrint(obj, 0, sb).toString())
        }

    }

    protected <T> StringBuilder extendPrettyPrint(T obj, Integer level = 0, StringBuilder sb) {
        def indent = { lev -> sb.append('  ' * lev) }
        if (obj instanceof Map) {
            sb.append('{\n')
            obj.each { name, value ->
                // if(name.contains('.'))  return // skip keys like "a.b.c", which are redundant
                indent(level + 1).append(name)
                (value instanceof Map) ? sb.append(' ') : sb.append(' = ')
                extendPrettyPrint(value, level + 1, sb)
                sb.append('\n')
            }
            indent(level).append('}')
        } else if (obj instanceof List) {
            sb.append('[\n')
            obj.eachWithIndex { value, index ->
                indent(level + 1)
                def isLatestElement = (index == obj.size() - 1)
                isLatestElement ? extendPrettyPrint(value, level + 1, sb) : extendPrettyPrint(value, level + 1, sb).append(',')
                sb.append('\n')
            }
            indent(level).append(']')
        } else if (obj instanceof String) {
            sb.append('"').append(obj).append('"')
        } else {
            sb.append(obj)
        }
        return sb
    }

    @Override
    void logPrettyMessages(LogLevel level, List<String> messages) {
        logMessage(level, createPrettyMessage(messages))
    }

    @Override
    void logPrettyError(List<String> msgs) {
        error(createPrettyMessage(msgs))
    }

    @NonCPS
    static String createPrettyMessage(List<String> msgs) {
        return [
                '===========================================',
                 flattenMessage(null, msgs.findAll { !it?.isEmpty() }).join('\n'),
                '===========================================',
        ].join('\n')
    }


    @NonCPS
    protected static List<String> flattenMessage(def list, def msgs) {
        list = list ?: []
        if (!(msgs instanceof String) && !(msgs instanceof GString)) {
            msgs.each { msg ->
                list = flattenMessage(list, msg)
            }
        } else {
            list += msgs
        }

        return list
    }

    @Override
    void configure(IPipelineContext context) {
        Boolean isDebugMode = context.optional('projectDescriptor.debugMode', false)
        if (isDebugMode) {
            setLogLevel(LogLevel.DEBUG)
        }

    }
}
</file>

<file path="src/es/giss/framework/core/logger/LogLevel.groovy">
package es.giss.framework.core.logger

import com.cloudbees.groovy.cps.NonCPS


enum LogLevel implements Serializable {
    FATAL(100, AnsiColor.RED, AnsiColor.BOLD),
    ERROR(200, AnsiColor.RED, AnsiColor.BOLD),
    WARN(300, AnsiColor.YELLOW, AnsiColor.ITALIC),
    INFO(400, AnsiColor.DARK_BLUE, AnsiColor.EMPTY_STYLE),
    DEBUG(500, AnsiColor.DARK_GREEN, AnsiColor.ITALIC)

    final int levelNumber
    final AnsiColor color
    final AnsiColor style

    LogLevel(int levelNumber, AnsiColor color, AnsiColor style) {
        this.levelNumber = levelNumber
        this.color = color
        this.style = style
    }

    @NonCPS
    @Override
    String toString() {
        return this.name()
    }
}
</file>

<file path="src/es/giss/framework/core/storage/interfaces/Effect.groovy">
package es.giss.framework.core.storage.interfaces

import es.giss.framework.core.events.PipelineEvent

interface Effect {
    void handleEvent(PipelineEvent event)
}
</file>

<file path="src/es/giss/framework/core/storage/interfaces/Mutation.groovy">
package es.giss.framework.core.storage.interfaces

import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.events.interfaces.DataModel

interface Mutation<State extends DataModel> {
    void apply(State state, PipelineEvent event)
}
</file>

<file path="src/es/giss/framework/core/storage/interfaces/Selector.groovy">
package es.giss.framework.core.storage.interfaces

import es.giss.framework.core.events.interfaces.DataModel

interface Selector<State extends DataModel, T> {
    T select(State state)
}
</file>

<file path="src/es/giss/framework/core/storage/mutations/PipelineMutation.groovy">
package es.giss.framework.core.storage.mutations

import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.storage.interfaces.Mutation
import es.giss.framework.core.utils.MapUtils
import es.giss.framework.core.vo.pipeline.AlternativesToolsDescriptor
import es.giss.framework.core.vo.pipeline.AsdfToolsManagerDescriptor
import es.giss.framework.core.vo.pipeline.CacheDescriptor
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.pipeline.PipelineSettings

class PipelineMutation implements Mutation<PipelineDefinition> {


    @Override
    void apply(PipelineDefinition state, PipelineEvent event) {
        def payload = event.payload
        switch (payload.getClass()) {
            case PipelineSettings:
                PipelineSettings settings = payload as PipelineSettings
                if(settings.skipStages) {
                    state.settings.skipStages.addAll(settings.skipStages)
                }
                if(settings.environmentVars) {
                    state.settings.environmentVars = MapUtils.deepMerge(state.settings.environmentVars, settings.environmentVars)
                }
                if(settings.devopsEnvironment) {
                    state.settings.devopsEnvironment = settings.devopsEnvironment
                }
                if(settings.debugMode) {
                    state.settings.debugMode = settings.debugMode
                }
                break

            case CacheDescriptor:
                CacheDescriptor cache = payload as CacheDescriptor
                if(cache.baseDir) {
                    state.cache.baseDir = cache.baseDir
                }
                if(cache.cacheFolders) {
                    state.cache.cacheFolders.addAll(cache.cacheFolders)
                }
                if(cache.exportEnvVar) {
                    state.cache.exportEnvVar = cache.exportEnvVar
                }
                if(cache.forceClearCache) {
                    state.cache.forceClearCache = cache.forceClearCache
                }
                break

            case AlternativesToolsDescriptor:
                AlternativesToolsDescriptor alternativesTools = payload as AlternativesToolsDescriptor
                if(alternativesTools.javaEngine) {
                    state.toolsManager.alternatives = alternativesTools
                }
                break

            case AsdfToolsManagerDescriptor:
                AsdfToolsManagerDescriptor asdfToolsManager = payload as AsdfToolsManagerDescriptor
                if(asdfToolsManager) {
                    asdfToolsManager.plugins.each { plugin, version ->
                        state.toolsManager.asdf.plugins[plugin] = version
                    }
                    asdfToolsManager.tools.each { tool, version ->
                        state.toolsManager.asdf.tools[tool] = version
                    }
                    if(asdfToolsManager.defaultToolVersionsFileDir) {
                        state.toolsManager.asdf.defaultToolVersionsFileDir = asdfToolsManager.defaultToolVersionsFileDir
                    }
                    if(asdfToolsManager.forceClearCache) {
                        state.toolsManager.asdf.forceClearCache = asdfToolsManager.forceClearCache
                    }
                    if(asdfToolsManager.proxySettings) {
                        state.toolsManager.asdf.proxySettings = asdfToolsManager.proxySettings
                    }
                }
                break
            default:
                break
        }
    }




}
</file>

<file path="src/es/giss/framework/core/storage/mutations/ProjectDescriptorMutation.groovy">
package es.giss.framework.core.storage.mutations

import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.storage.interfaces.Mutation
import es.giss.framework.core.vo.project.*
import es.giss.framework.core.vo.project.strategies.*

class ProjectDescriptorMutation implements Mutation<ProjectDescriptor> {

    @Override
    void apply(ProjectDescriptor state, PipelineEvent event) {
        def payload = event.payload
        switch (payload.getClass()) {
            case ProjectSettings:
                mergeProjectSettings(state, payload)
                break
            case SourceRepository:
                mergeSourceRepository(state, payload)
                break
            case Notification:
                mergeNotifications(state, payload)
                break
            case ProjectTool:
                mergeProjectTool(state, payload)
                break
            case ArtifactsRepository:
                mergeArtifactsRepository(state, payload)
                break
            case DeployTarget:
                mergeDeployTarget(state, payload)
                break
            case ScannerTool:
                mergeScannerTool(state, payload)
                break
            case Artifact:
                mergeArtifact(state, payload)
                break
            case BuildStrategy:
            case DeployStrategy:
            case PublishStrategy:
            case RollbackStrategy:
            case UndeployStrategy:
            case TestStrategy:
                mergeStrategy(state, payload)
                break
            default:
                break
        }
    }

    private void mergeProjectSettings(ProjectDescriptor state, ProjectSettings payload) {
        mergeObjects(state.projectSettings, payload)
    }

    private void mergeSourceRepository(ProjectDescriptor state, SourceRepository payload) {
        SourceRepository repository = payload
        SourceRepository currentRepository = state.sourceRepositories.find { it.id == repository.id }
        if (currentRepository) {
            mergeObjects(currentRepository, repository)
        } else {
            state.sourceRepositories.add(repository)
        }
    }

    private void mergeNotifications(ProjectDescriptor state, Notification payload) {
        Notification notifications = payload
        notifications.emails.each { email ->
            Email currentEmail = state.notifications.emails.find { it.email == email.email }
            if (currentEmail) {
                email.notificationsInterested = email.notificationsInterested + currentEmail.notificationsInterested
                email.email = currentEmail.email
                email.name = currentEmail.name
            } else {
                state.notifications.emails.add(email)
            }
        }
    }

    private void mergeProjectTool(ProjectDescriptor state, ProjectTool payload) {
        ProjectTool tool = payload
        ProjectTool currentTool = state.spec.tools.find { it.id == tool.id }
        if (currentTool) {
            currentTool.version = tool.version?: currentTool.version
            currentTool.cache = tool.cache?: currentTool.cache
            currentTool.toolConfigurationFile = tool.toolConfigurationFile?: currentTool.toolConfigurationFile
            currentTool.artifactsRepositoryId = tool.artifactsRepositoryId?: currentTool.artifactsRepositoryId
            tool.strategies.each { strategy ->
                mergeStrategy(state, strategy)
            }
        } else {
            state.spec.tools.add(tool)
        }
    }

    private void mergeArtifactsRepository(ProjectDescriptor state, ArtifactsRepository payload) {
        ArtifactsRepository repository = payload
        ArtifactsRepository currentRepository = state.spec.artifactsRepositories.find { it.id == repository.id }
        if (currentRepository) {
            mergeObjects(currentRepository, repository)
        } else {
            state.spec.artifactsRepositories.add(repository)
        }
    }

    private void mergeDeployTarget(ProjectDescriptor state, DeployTarget payload) {
        DeployTarget target = payload
        DeployTarget currentTarget = state.spec.deployTargets.find { it.id == target.id }
        if (currentTarget) {
            mergeObjects(currentTarget, target)
        } else {
            state.spec.deployTargets.add(target)
        }
    }

    private void mergeScannerTool(ProjectDescriptor state, ScannerTool payload) {
        ScannerTool tool = payload
        ScannerTool currentTool = state.spec.tools.find { it.id == tool.id }
        if (currentTool) {
            mergeObjects(currentTool, tool)
        } else {
            state.spec.tools.add(tool)
        }
    }

    private void mergeArtifact(ProjectDescriptor state, Artifact payload) {
        Artifact artifact = payload
        Artifact currentArtifact = state.status.artifacts.find { it.id == artifact.id }
        if (currentArtifact) {
            mergeObjects(currentArtifact, artifact)
        } else {
            state.status.artifacts.add(artifact)
        }
    }
    private void mergeStrategy(ProjectDescriptor state, ProjectActionStrategy payload) {
        if (payload.toolId == null) {
            throw new IllegalArgumentException("Tool id is required to add a strategy to the project descriptor.")
        }
        if (payload.id == null) {
            throw new IllegalArgumentException("Strategy id is required to add a strategy to the project descriptor and tool config.")
        }
        ProjectTool currentTool = state.spec.tools.find { it.id == payload.toolId }
        ProjectActionStrategy currentStrategy = currentTool.strategies.find { it.id == payload.id }

        if (!currentTool) {
            throw new IllegalArgumentException("Tool with id ${payload.toolId} not found in the project descriptor. No strategy can be added to a non existing tool.")
        }

        if (currentStrategy) {
            mergeObjects(currentStrategy, payload)
        } else if (currentTool) {
            if (currentTool.strategies == null) {
                currentTool.strategies = []
            }
            currentTool.strategies.add(payload)
        }
    }

    private Object mergeObjects(Object currentState, Object overrideState) {
        overrideState.properties.each { property, value ->
            if (property != 'class' && value != null && currentState.hasProperty(property)) {
                currentState[property] = value
            }
        }
        return currentState
    }
}
</file>

<file path="src/es/giss/framework/core/storage/Store.groovy">
package es.giss.framework.core.storage

import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.events.interfaces.DataModel
import es.giss.framework.core.storage.interfaces.Effect
import es.giss.framework.core.storage.interfaces.Mutation

class Store<State extends DataModel> {
    private State state
    private State readStateCache
    private Map<Class<? extends PipelineEvent>, Mutation<State>> mutations
    private Map<Class<? extends PipelineEvent>, List<Effect>> effectMap
    private List<PipelineEvent> eventQueue

    Store(State initialState) {
        state = initialState
        readStateCache = initialState.clone() as State
        mutations = [:]
        effectMap = [:].withDefault { [] }
        eventQueue = []
    }

    void dispatch(PipelineEvent event) {
        synchronized (this) {
            eventQueue << event
            Mutation<State> mutation = mutations[event.getClass()]
            if (mutation) {
                mutation.apply(state, event)
                readStateCache = state.clone() as State // Invalidate the cache
            } else {
                println "No mutation found for event type: ${event.class.simpleName}"
            }
            List<Effect> effects = effectMap[event.getClass()]
            effects.each { it.handleEvent(event) }
        }
    }

    State getState() {
        synchronized (this) {
            if (readStateCache == null) {
                readStateCache = state.clone() as State
            }
            return readStateCache
        }
    }

    def void addMutation(Class<? extends PipelineEvent> eventType, Mutation<State> mutation) {
        mutations[eventType] = mutation
    }

    void addEffect(Class<? extends PipelineEvent> eventType, Effect effect) {
        effectMap[eventType] << effect
    }

    def <T> T select(Closure<T> selector) {
        return selector(getState()) as T
    }

}
</file>

<file path="src/es/giss/framework/core/tools/interfaces/IGitTool.groovy">
package es.giss.framework.core.tools.interfaces


import es.giss.framework.core.interfaces.ITool
import es.giss.framework.core.vo.project.SourceRepository

interface IGitTool extends ITool {

    void cloneInAgent()

    void cloneInAgent(String url, String reference)

    void cloneInAgent(String url, String reference, String credentialsId)

    void cloneInAgent(String url, String reference, String credentialsId, String cloneDir)

    void cloneInAgent(String url, String reference, String credentialsId, String cloneDir, Boolean shallowClone)

    void setUserDetails(Boolean override)

    void setUserDetails(Boolean override, String directory)

    String getGitRemoteUrl()

    String getGitRemoteUrl(String name)

    void fetchTags()

    Boolean createTag(String tag)

    Boolean tagExists(String tag)

    Boolean branchExists(String branchName)

    List<String> getAllTags()

    List<String> getAllTags(Boolean fromHead)

    String getLatestTagFromCurrentHead()

    String describeTagWithGitSuffix(String tag)

    Boolean currentHeadIsTagged()

    String getCurrentHeadSha()

    String getFirstCommitSha()

    String getCommitMessage()

    String getCommitMessage(String reference)

    String getCommitEmail()

    String getCommitEmail(String reference)

    List<String> getChangedFilesBetweenCommits(String fromRef, String toRef)

    Boolean isWorkingDirectoryUnmodified()

    Boolean switchToBranch(String branch)

    Boolean addChanges()

    Boolean addFiles(List<String> fileList)

    Boolean createCommit(String message)

    Boolean push()

    Boolean push(boolean force)

    SourceRepository getDefaultSourceRepository()

}
</file>

<file path="src/es/giss/framework/core/tools/interfaces/IToolsManager.groovy">
package es.giss.framework.core.tools.interfaces

import es.giss.framework.core.interfaces.ITool

interface IToolsManager extends ITool {

    void setToolVersion(String tool, String version)
}
</file>

<file path="src/es/giss/framework/core/tools/interfaces/IWorkspaceTool.groovy">
package es.giss.framework.core.tools.interfaces

import es.giss.framework.core.interfaces.ITool
import es.giss.framework.core.vo.WatchFiles

import java.nio.file.Path

interface IWorkspaceTool extends ITool {

    Boolean directoryExists(String directory)

    Boolean fileExists(String file)

    void createDirectoriesIfNotExist(List<String> dirs)

    void writeFile(String file, String text)

    String readFile(String file)

    Boolean globMatch(String pattern, String filePath)

    Boolean globMatch(String pattern, String filePath, boolean caseSensitive)

    Boolean checkWatchedFiles()

    Boolean checkWatchedFiles(Boolean abortPipeline)

    Boolean checkWatchedFiles(Boolean abortPipeline, List<String> inclusions, List<String> exclusions)

    List<Path> findFiles(String directory, String pattern)

    Path findClosestFile(String directory, String pattern)

    void setWatchFiles(WatchFiles watchFiles)
}
</file>

<file path="src/es/giss/framework/core/tools/restClients/interfaces/IGitLabTool.groovy">
package es.giss.framework.core.tools.restClients.interfaces

interface IGitLabTool {

    IGitLabTool credentialsId(String credentialsId)

    IGitLabTool baseUrl(String baseUrl)

    IGitLabTool ignoreSsl(Boolean ignoreSsl)

    IGitLabTool apiNamespace(String apiNamespace)

    IGitLabTool debugMode(Boolean debugMode)

    Map<String, Serializable> getMergeRequest(Object projectIdOrPath, Integer mergeRequestId)

    List<Map<String, Serializable>> getOpenedMergeRequests(Object projectIdOrPath,
                                                           String sourceBranch,
                                                           String targetBranch)

    Map<String, Serializable> createMergeRequest(Object projectIdOrPath,
                                                 String sourceBranch,
                                                 String targetBranch,
                                                 String title,
                                                 String description,
                                                 Boolean removeSourceBranch,
                                                 Boolean squash)

    Map<String, Serializable> approveMergeRequest(Object projectIdOrPath, Integer mergeRequestIid)

    Map<String, Serializable> acceptMergeRequest(Object projectIdOrPath,
                                                 Integer mergeRequestIid,
                                                 String mergeCommitMessage,
                                                 Boolean shouldRemoveSourceBranch,
                                                 Boolean mergeWhenPipelineSucceeds)

    Map<String, Serializable> createReleaseNotes(Object projectIdOrPath, String tagId, String notes)

    List<Map<String, Serializable>> getMergeRequestStatuses(Object projectIdOrPath, Integer mergeRequestIid)

    List<Map<String, Serializable>> getCommitStatuses(Object projectIdOrPath, String sha)

    List<Map<String, Serializable>> listProjectUsers(Object projectIdOrPath)

    Integer getUserId(String username)

    List<Map<String, Serializable>> userInParentGroups(Object projectIdOrPath, List<Integer> userIds)

    Boolean projectUserExists(Object projectIdOrPath, String username, Boolean includeParentGroups)

    Boolean projectUserExists(Object projectIdOrPath, String username)

    Integer getProjectId(Object projectIdOrPath)

    Integer getGroupId(Object groupIdOrPath)

    Map<String, Serializable> getGroupOrNull(Object groupIdOrPath)

    String getProjectPathFromUrl(String url)

    String getRawFile(Object projectIdOrPath, String ref, String filePath)

    List<Map<String, String>> getTags(Object projectIdOrPath, String tagPattern)

    Boolean existTag(Object projectIdOrPath, String tagReference)

    Map<String, String> createTag(String projectIdOrPath, String tagName, String message, String releaseNotes)

    List<Map<String, Serializable>> getDirectoryContent(Object projectIdOrPath, String ref, String dirPath)

    void fetchGitLabDirFiles(Object projectIdOrPath, String ref, String dirPath, String destinationPath)
}
</file>

<file path="src/es/giss/framework/core/tools/restClients/interfaces/IRestClient.groovy">
package es.giss.framework.core.tools.restClients.interfaces


import es.giss.framework.core.tools.ProxyHost
import es.giss.framework.core.tools.restClients.CredentialType
import es.giss.framework.core.tools.restClients.RestClient
import es.giss.framework.core.vo.resources.http.HttpResponse

import java.nio.file.Path

interface IRestClient {

    IRestClient url(String url)

    IRestClient header(String name, String value)

    IRestClient body(String body)

    IRestClient get()

    IRestClient get(Map<String,Object> queryParams)

    IRestClient post()

    IRestClient post(Map<String,Object> body)

    IRestClient put()

    IRestClient put(Map<String,Object> body)

    IRestClient delete()

    RestClient withAuthBasic(String credentialsId)

    RestClient withAuthBasic(String credentialsId, CredentialType credentialType)

    RestClient withAuthBearer(String credentialsId)

    RestClient withAuthBearer(String credentialsId,  CredentialType credentialType)

    IRestClient withCustomHeaderAuth(String credentialsId, String headerName)

    IRestClient withCustomHeaderAuth(String credentialsId, String headerName,  CredentialType credentialType)

    IRestClient debugMode(Boolean debugMode)

    IRestClient proxy(ProxyHost proxyHost)

    IRestClient caCert(Path caCertPath)

    IRestClient ignoreSsl(Boolean ignoreSsl)

    HttpResponse execute()

}
</file>

<file path="src/es/giss/framework/core/tools/restClients/CredentialType.groovy">
package es.giss.framework.core.tools.restClients

enum CredentialType {
    TOKEN,
    USERNAME_PASSWORD,
    STRING,
    USERNAME_COLON_PASSWORD
}
</file>

<file path="src/es/giss/framework/core/tools/restClients/GitLabTool.groovy">
package es.giss.framework.core.tools.restClients


import es.giss.framework.core.Steps
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.tools.restClients.interfaces.IGitLabTool
import es.giss.framework.core.tools.restClients.interfaces.IRestClient
import es.giss.framework.core.vo.resources.http.HttpResponse


import java.nio.charset.StandardCharsets


class GitLabTool extends Steps implements IGitLabTool {

    private String apiNamespace = 'api/v4'
    private String credentialsId
    private String baseUrl
    private Boolean ignoreSsl = false
    private Script steps
    private Boolean isDebug = false


    GitLabTool(Script steps, ILogger logger) {
        this.steps = steps
        this.logger = logger
    }

    GitLabTool credentialsId(String credentialsId) {
        this.credentialsId = credentialsId
        return this
    }

    GitLabTool baseUrl(String baseUrl) {
        this.baseUrl = baseUrl
        return this
    }

    GitLabTool debugMode(Boolean debugMode) {
        this.isDebug = debugMode
        return this
    }

    GitLabTool ignoreSsl(Boolean ignoreSsl) {
        this.ignoreSsl = ignoreSsl
        return this
    }

    GitLabTool apiNamespace(String apiNamespace) {
        this.apiNamespace = apiNamespace
        return this
    }


    @Override
    Map<String, Serializable> getMergeRequest(Object projectIdOrPath, Integer mergeRequestId) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests/${mergeRequestId}") as Map
    }

    @Override
    List<Map<String, Serializable>> getOpenedMergeRequests(Object projectIdOrPath, String sourceBranch, String targetBranch) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        def params = [
                source_branch: sourceBranch,
                target_branch: targetBranch,
                state        : 'opened'
        ]
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests", [:], params) as List<Map>
    }

    @Override
    Map<String, Serializable> createMergeRequest(
            Object projectIdOrPath, String sourceBranch, String targetBranch, String title, String description,
            Boolean removeSourceBranch, Boolean squash
    ) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        Map payload = [source_branch       : sourceBranch,
                       target_branch       : targetBranch,
                       title               : title,
                       description         : description,
                       remove_source_branch: removeSourceBranch,
                       squash              : squash
        ]
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests", payload) as Map
    }

    @Override
    Map<String, Serializable> approveMergeRequest(Object projectIdOrPath, Integer mergeRequestIid) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests/${mergeRequestIid}/approve") as Map
    }

    @Override
    Map<String, Serializable> acceptMergeRequest(
            Object projectIdOrPath, Integer mergeRequestIid, String mergeCommitMessage,
            Boolean shouldRemoveSourceBranch, Boolean mergeWhenPipelineSucceeds
    ) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        Map payload = [
                merge_commit_message        : mergeCommitMessage,
                should_remove_source_branch : shouldRemoveSourceBranch,
                merge_when_pipeline_succeeds: mergeWhenPipelineSucceeds
        ]
        return performRequest('PUT', "${apiNamespace}/projects/${encodedProjectIdOrPath}/merge_requests/${mergeRequestIid}/merge", payload) as Map
    }

    @Override
    Map<String, Serializable> createReleaseNotes(Object projectIdOrPath, String tagId, String notes) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        Map payload = [
                tag_name   : tagId,
                description: notes
        ]
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/releases", payload) as Map
    }

    @Override
    List<Map<String, Serializable>> getMergeRequestStatuses(Object projectIdOrPath, Integer mergeRequestIid) {
        def mergeRequest = getMergeRequest(projectIdOrPath, mergeRequestIid)
        return getCommitStatuses(projectIdOrPath, mergeRequest.sha as String)
    }

    @Override
    List<Map<String, Serializable>> getCommitStatuses(Object projectIdOrPath, String sha) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/commits/${sha}/statuses") as List<Map>
    }

    @Override
    List<Map<String, Serializable>> listProjectUsers(Object projectIdOrPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/members") as List
    }

    @Override
    Boolean projectUserExists(Object projectIdOrPath, String username, Boolean includeParentGroups = false) {
        Integer userId = getUserId(username)
        List users = []
        if (includeParentGroups) {
            users.addAll(userInParentGroups(projectIdOrPath, [userId]))
        }
        users.addAll(listProjectUsers(projectIdOrPath))
        logger.debug "users check if exists: ${users}"
        List userExists = users.findAll { user ->
            user.state == 'active' && user.username.equalsIgnoreCase(username)
        }

        return userExists.size() > 0
    }

    @Override
    Integer getUserId(String username) {
        Map queryParams = [username: username]
        List<Map> user = performRequest('GET', "${apiNamespace}/users", [:], queryParams) as List<Map>
        return user[0].id as Integer
    }

    @Override
    List<Map<String, Serializable>> userInParentGroups(Object projectIdOrPath, List<Integer> user_ids) {
        Map queryParams = [user_ids: user_ids.join(',')]
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}/members/all", [:], queryParams) as List
    }

    @Override
    Map<String, String> createTag(String projectIdOrPath, String tagName, String message, String releaseNotes) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath)
        Map payload = [
                tag_name           : tagName,
                ref                : 'master',
                message            : message,
                release_description: releaseNotes
        ]
        return performRequest('POST', "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/tags/", payload) as Map
    }

    @Override
    Integer getProjectId(Object projectIdOrPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        def project = performRequest('GET', "${apiNamespace}/projects/${encodedProjectIdOrPath}") as Map
        return project.id as Integer
    }

    @Override
    String getRawFile(Object projectIdOrPath, String ref, String filePath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        String encodedFilePath = encodeValue(filePath)
        return performRequest(
                'GET',
                "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/files/${encodedFilePath}/raw",
                [:],
                [ref: ref],
                false)
    }

    @Override
    List<Map<String, Serializable>> getDirectoryContent(Object projectIdOrPath, String ref, String dirPath) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        String encodedDirPath = encodeValue(dirPath.replaceAll(/\/$/, ''))
        return   performRequest(
                'GET',
                "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/tree",
                [:],
                [ref: ref, path: encodedDirPath, recursive: true],
                true) as List<Map>
    }

    @Override
    void fetchGitLabDirFiles(Object projectIdOrPath, String ref, String dirPath, String destinationPath) {
        List<Map<String, Serializable>> directoryContent = getDirectoryContent(projectIdOrPath, ref, dirPath)
        logger.debug("Gitlab Repository Files in ${dirPath}: ${directoryContent}")
        directoryContent.each { item ->
            logger.debug("Gitlab Repository Item ${item.name} in ${dirPath}")
            if (item.type == "blob") { // Es un archivo
                String fileContent = getRawFile(projectIdOrPath, ref, "${item.path}")
                // Hacer algo con fileContent
                steps.sh("mkdir -p ${destinationPath}/${(item.path as String).replaceAll(item.name, '')}")
                steps.writeFile(file: "${destinationPath}/${item.path}", text: fileContent)
                logger.debug("Gitlab Repository File ${item.path} fetched")
            }
            // Si queremos a futuro recorrer subdirectorios
//            else if (item.type == "tree") { // Es un subdirectorio
//                getAllFilesInDirectory(projectIdOrPath, ref, "${dirPath}/${item.name}")
//            }
        }
    }

    @Override
    List<Map<String, String>> getTags(Object projectIdOrPath, String tagPattern) {
        String encodedProjectIdOrPath = encodeValue(projectIdOrPath as String)
        return performRequest(
                'GET',
                "${apiNamespace}/projects/${encodedProjectIdOrPath}/repository/tags",
                [:],
                [order_by: 'updated', sort: 'desc', search: tagPattern ?: '']
        ) as List<Map<String, String>>
    }

    @Override
    Boolean existTag(Object projectIdOrPath, String tagReference) {
        def listTags = getTags(projectIdOrPath, tagReference)
        return listTags.isEmpty() ? false : true
    }

    @Override
    Integer getGroupId(Object groupIdOrPath) {
        String encodedGroupIdOrPath = encodeValue(groupIdOrPath as String)
        def group = performRequest('GET', "${apiNamespace}/groups/${encodedGroupIdOrPath}") as Map
        return group.id as Integer
    }

    @Override
    Map<String, Serializable> getGroupOrNull(Object groupIdOrPath) {
        String encodedGroupIdOrPath = encodeValue(groupIdOrPath as String)
        try {
            return performRequest('GET', "${apiNamespace}/groups/${encodedGroupIdOrPath}") as Map
        } catch (ignored) {
            return [:]
        }
    }

    @Override
    String getProjectPathFromUrl(String url) {
        // We want to get the project path (including group and subgroups)
        if (url =~ /^http/ || url =~ /^\/opt\//) {
            // The repository url follows the expression 'protocol://gitlab_domain/group1/group2.../project'
            return url.trim().tokenize('/').drop(2).join('/').replaceAll(/.git$/, '')
        }

        // Here for ssh protocol user@gitlab_domain:group1/group2.../project.git
        return url.trim().tokenize(':').takeRight(1).join('/').replaceAll(/.git$/, '')
    }

    private static String encodeValue(String value) {
        return URLEncoder.encode(value, StandardCharsets.UTF_8.toString())
    }

    private Object performRequest(
            String method, String path, Map body = [:], Map queryParams = [:], Boolean mapJsonBody = true
    ) {

        IRestClient client = new RestClient(steps)
                .withCustomHeaderAuth(credentialsId, 'PRIVATE-TOKEN', CredentialType.USERNAME_PASSWORD)
                .url("$baseUrl/${path}")
                .debugMode(true)
                .ignoreSsl(ignoreSsl)

        switch (method.toUpperCase()) {
            case 'GET':
                client.get(queryParams)
                break
            case 'POST':
                client.post(body)
                break
            case 'PUT':
                client.put(body)
                break
            case 'DELETE':
                client.delete()
                break
            default:
                throw new IllegalArgumentException("Method $method not supported")
        }

        HttpResponse response = client.execute()


        if (response.statusCode >= 400) {
            def bodyString = body.collect { "$it.key : $it.value".toString() } as String
            logger.error("GitlabTool response: ${response.statusCode} - ${response.body}")
            steps.error("GitLabTool Error in request to GitLab with credentialsId: $credentialsId, baseUrl: $baseUrl, path: $path, method: $method, body: $bodyString, queryParams: $queryParams")
        }

        return mapJsonBody ? response.parseJsonBody() : response.body
    }
}
</file>

<file path="src/es/giss/framework/core/tools/restClients/RestClient.groovy">
package es.giss.framework.core.tools.restClients

import es.giss.framework.core.tools.ProxyHost
import es.giss.framework.core.tools.restClients.interfaces.IRestClient
import es.giss.framework.core.vo.resources.http.HttpResponse
import groovy.json.JsonOutput

import java.nio.file.Path

/**
 * RestClient class.
 * This class provides methods to perform HTTP requests.
 */
class RestClient implements IRestClient {

    private Script steps
    private String method = 'GET'
    private String url = ''
    private Map<String, String> headers = [:]
    private String body = ''
    private String credentialsId = ''
    private CredentialType credentialType = CredentialType.USERNAME_PASSWORD
    private String authType = 'basic'
    private Boolean debugMode = false
    private ProxyHost proxy
    private Path caCertPath
    private Map<String, Object> queryParams = [:]
    private Boolean disableSecureConnectionVerification
    private String customAuthHeaderName


    RestClient(Script steps) {
        this.steps = steps
    }

    RestClient proxy(ProxyHost proxyHost) {
        this.proxy = proxyHost
        return this
    }

    /**
     * Sets the base URI for the HTTP request.
     *
     * @param url The base URI.
     * @return The RestClient instance.
     */
    @Override
    RestClient url(String url) {
        this.url = url
        return this
    }

    @Override
    RestClient header(String name, String value) {
        this.headers[name] = value
        return this
    }

    @Override
    RestClient body(String body) {
        this.body = body
        return this
    }

    @Override
    RestClient get() {
        return get([:])
    }

    @Override
    IRestClient get(Map<String, Object> queryParams) {
        this.method = 'GET'
        this.queryParams = queryParams
        return this
    }

    @Override
    RestClient post() {
        return post([:])
    }

    @Override
    IRestClient post(Map<String, Object> bodyParams) {
        this.method = 'POST'
        if (bodyParams) {
            this.body = JsonOutput.toJson(bodyParams)
        }
        return this
    }

    @Override
    RestClient put() {
        this.method = 'PUT'
        return this
    }

    @Override
    IRestClient put(Map<String, Object> bodyParams) {
        if (bodyParams) {
            this.body = JsonOutput.toJson(bodyParams)
        }
        return this
    }

    @Override
    RestClient delete() {
        this.method = 'DELETE'
        return this
    }

    RestClient uploadFile(String filePath) {
        this.method = 'POST'
        this.body = "-F @${filePath}"
        return this
    }

    @Override
    RestClient withAuthBasic(String credentialsId, CredentialType credentialType = CredentialType.USERNAME_PASSWORD) {
        this.credentialsId = credentialsId
        this.credentialType = credentialType
        this.authType = 'basic'
        return this

    }

    @Override
    RestClient withAuthBearer(String credentialsId, CredentialType credentialType = CredentialType.STRING) {
        this.credentialsId = credentialsId
        this.credentialType = credentialType
        this.authType = 'bearer'
        return this
    }

    @Override
    IRestClient withCustomHeaderAuth(String credentialsId, String headerName, CredentialType credentialType = CredentialType.STRING) {
        this.credentialsId = credentialsId
        this.credentialType = credentialType
        this.authType = 'customHeader'
        this.customAuthHeaderName = headerName
        return this
    }

    @Override
    RestClient debugMode(Boolean debugMode) {
        this.debugMode = debugMode
        return this
    }

    @Override
    IRestClient caCert(Path caCertPath) {
        this.caCertPath = caCertPath
        return this
    }

    @Override
    IRestClient ignoreSsl(Boolean disableSecureConnectionVerification) {
        this.disableSecureConnectionVerification = disableSecureConnectionVerification
        return this
    }

    Map getUsernamePassword(String credentialsId) {
        steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'USER', passwordVariable: 'PASS')]) {
            return ['user': steps.env.USER, 'pass': steps.env.PASS]
        }
    }

    Map getStringCredentials(String credentialsId) {
        steps.withCredentials([steps.string(credentialsId: credentialsId, variable: 'TOKEN')]) {
            return ['token': steps.env.TOKEN]
        }
    }

    Map getTokenCredentials(String credentialsId) {
        steps.withCredentials([steps.token(credentialsId: credentialsId, variable: 'TOKEN') ]) {
            return ['token': steps.env.TOKEN]
        }
    }

    Map getUsernameColonPassword(String credentialsId) {
        steps.withCredentials([steps.usernameColonPassword(credentialsId: credentialsId, variable: 'USER_PASS')]) {
            return ['userPass': steps.env.USER_PASS]
        }
    }

    String normalizeQueryParams(Map<String, Object> params) {
        return params.collect { k, v -> "${URLEncoder.encode(k.toString(), "UTF-8")}=${URLEncoder.encode(v.toString(), "UTF-8")}" }.join('&')
    }

    String getUrlWithQueryParams(String url, Map<String, Object> queryParams) {
        return url + (queryParams ? "?${normalizeQueryParams(queryParams)}" : '')
    }

/**
 * Executes the HTTP request.
 *
 * Example usage:
 * <pre>
 * {@code
 * def client = new RestClient(steps)
 * def response = client
 *     .url('https://jsonplaceholder.typicode.com/posts/1')
 *     .header('Content-Type', 'application/json')
 *     .withAuthBasic('my-credentials-id', CredentialType.USERNAME_PASSWORD)
 *     .get()
 *     .execute()
 * println "Status: ${response.status}"
 * println "Body: ${response.body}"
 *}
 * </pre>
 *
 * @return A Map containing the status and body of the HTTP response.
 */
    @Override
    HttpResponse execute() {
        String headerOptions = headers.collect { k, v -> "-H \"$k: $v\"" }.join(' ')
        String bodyOption = body ? "--data \"$body\"" : ''
        String caCertOption = caCertPath ? "--cacert $caCertPath" : ''
        String ignoreSslOption = disableSecureConnectionVerification ? "-k" : ''
        String fileSuffix = System.currentTimeMillis()
        String scriptName = "curl_script_${fileSuffix}.sh"
        String responseFileName = "response_${fileSuffix}.txt"
        String responseCode = ''
        String responseBody = ''
        String urlWithQueryParams = getUrlWithQueryParams(url, queryParams)


        String commandArgs = "-s -o ${responseFileName} -w \"%{http_code}\" -X $method"
        if (headerOptions) {
            commandArgs = "${commandArgs} ${headerOptions}"
        }

        if (bodyOption) {
            commandArgs = "${commandArgs} ${bodyOption}"
        }

        if (caCertOption) {
            commandArgs = "${commandArgs} ${caCertOption}"
        }

        if (ignoreSslOption) {
            commandArgs = "${ignoreSslOption} ${commandArgs}"
        }

        try {
            if (credentialsId) {
                    switch (authType) {
                        case 'basic':
                            if(credentialType == CredentialType.USERNAME_PASSWORD) {
                                def userPass = getUsernamePassword(credentialsId)
                                commandArgs = "-u ${userPass.user}:${userPass.pass} ${commandArgs}"
                            } else if(credentialType == credentialType.USERNAME_COLON_PASSWORD) {
                                def userPass = getUsernameColonPassword(credentialsId)
                                commandArgs = "-u ${userPass.userPass} ${commandArgs}"
                            } else {
                                steps.error("Credential type $credentialType not supported")
                            }
                            break
                        case 'bearer':
                            if(credentialType == CredentialType.STRING) {
                                def token = getStringCredentials(credentialsId).token
                                commandArgs = "-H \"Authorization: Bearer ${token}\" ${commandArgs}"
                            } else if(credentialType == CredentialType.TOKEN) {
                                def token = getTokenCredentials(credentialsId).token
                                commandArgs = "-H \"Authorization: Bearer ${token}\" ${commandArgs}"
                            } else {
                                steps.error("Credential type $credentialType not supported")
                            }
                            break
                        case 'customHeader':
                            if (credentialType == CredentialType.STRING) {
                                def token = getStringCredentials(credentialsId).token
                                commandArgs = "-H \"${customAuthHeaderName}: ${token}\" ${commandArgs}"
                            } else if (credentialType == credentialType.TOKEN) {
                                def token = getTokenCredentials(credentialsId).token
                                commandArgs = "-H \"${customAuthHeaderName}: ${token}\" ${commandArgs}"
                            } else if (credentialType == credentialType.USERNAME_PASSWORD) {
                                def userPass = getUsernamePassword(credentialsId)
                                commandArgs = "-H \"${customAuthHeaderName}: $userPass.pass\" ${commandArgs}"
                            } else  {
                                steps.error("Credential type $credentialType not supported")
                            }
                            break
                        default:
                            steps.error("Auth type $authType not supported")
                    }

            }

            if (debugMode) {
                commandArgs = "-v ${commandArgs}"
            }

            String debugCommand = debugMode ? 'set -x' : 'set +x'
            String proxyCommand = proxy ? "export http_proxy=${proxy.toString()}; export https_proxy=${proxy.toString()};" : ''
            String unsetProxyCommand = proxy ? "unset http_proxy; unset https_proxy;" : ''


            steps.writeFile(file: scriptName, text: """
                    ${debugCommand}\n
                    ${proxyCommand}\n
                    curl ${commandArgs} "${urlWithQueryParams}"\n
                    ${unsetProxyCommand}\n
                """)

            responseCode = steps.sh(
                    script: """
                        ${debugCommand}
                        chmod +x ${scriptName}
                        bash ./${scriptName}
                    """,
                    returnStdout: true)
                    .trim()

            responseBody = steps.readFile(file: responseFileName)
            return new HttpResponse(statusCode: responseCode.toInteger(), body: responseBody)

        } catch (Exception e) {
            // TODO: Eliminar cuando sea estable
            steps.sh(script: "cat ${responseFileName} || true")
            steps.sh(script: "cat ${scriptName} || true")

            if(!responseBody) {
                responseBody = "Error executing request: ${e.message}, with url: $url  and credentialType: $credentialType and credentialsId: $credentialsId and authType: $authType and debugMode: $debugMode and proxy: $proxy and caCertPath: $caCertPath and ignoreSsl: $disableSecureConnectionVerification and customAuthHeaderName: $customAuthHeaderName"
            }
            return new HttpResponse(statusCode: responseCode.isEmpty()? 500: responseCode.toInteger(), body: responseBody)

        } finally {
            if (debugMode) {
                steps.sh(script: "cat ${responseFileName} || true")
                steps.sh(script: "cat ${scriptName} || true")
            }
            steps.sh(script: "rm -f ${scriptName} ${responseFileName} || true")
        }
    }

}
</file>

<file path="src/es/giss/framework/core/tools/GitTool.groovy">
package es.giss.framework.core.tools


import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.vo.observability.TelemetryMap
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.project.SourceRepository


@PipelineComponent
class GitTool extends Steps implements IGitTool {

    List<SourceRepository> sourceRepositories

    @Override
    void cloneInAgent() {
        SourceRepository defaultSourceRepository = getDefaultSourceRepository()
        if (defaultSourceRepository == null) {
            steps.error("Source repositories not found in configuration for this project")
        }
        cloneInAgent(defaultSourceRepository.url, defaultSourceRepository.branch, defaultSourceRepository.credentialsId)
    }

    @Override
    void cloneInAgent(String url,
                      String reference,
                      String credentialsId = '',
                      String cloneDir = '.',
                      Boolean shallowClone = false) {
        String repositoryUrl = (url ==~ /http.*/) ? getGitRepoUrlWithBasicAuth(url, credentialsId) : url

        steps.withEnv(["REPO_URL=${repositoryUrl}"]) {
            logger.info "Clone repository ${url} and reference ${reference}"
            pipeline.publishEvent('GitCloneEvent',
                    [url          : url,
                     reference    : reference,
                     credentialsId: credentialsId,
                     cloneDir     : cloneDir,
                     shallowClone : shallowClone])
            if (shallowClone && isCommitSha(reference)) {
                steps.sh """
                    set +x
                    git clone --depth 1 \$REPO_URL ${cloneDir}
                    cd ${cloneDir}
                    git fetch --depth=1 origin ${reference}
                    git checkout ${reference}
                """
            } else if (shallowClone) {
                steps.sh """
                    set +x
                    git clone --depth 1 --branch ${reference} --single-branch \$REPO_URL ${cloneDir}
                    cd ${cloneDir}
                """
            } else {
                steps.sh """
                    set +x
                    git clone \$REPO_URL ${cloneDir}
                    cd ${cloneDir}
                    git checkout ${reference}
                """
            }
        }
    }

    private Boolean isCommitSha(String reference) {
        reference ==~ /(?i)^[0-9a-f]{40}$/
    }

    @Override
    void setUserDetails(Boolean override, String directory = '.') {
        Integer gitUserKeysCount = steps.sh(returnStdout: true,
                script: """
                    cd ${directory}
                    git config --local --name-only --get-regexp "user.(name|email)" || true
                """).tokenize()?.size()

        if (gitUserKeysCount != 2 || override) {
            steps.sh """
                cd ${directory}
                git config --local user.name "${this.user}"
                git config --local user.email "${this.email}"
            """
        }
    }

    @Override
    String getGitRemoteUrl(String name = 'origin') {
        def remoteUrl = steps.sh(returnStdout: true, script: "git remote get-url ${name}")?.trim()
        return remoteUrl
    }


    private String getGitRepoUrlWithBasicAuth(final String url, String credentialsId) {
        steps.withCredentials([steps.usernamePassword(credentialsId: credentialsId, usernameVariable: 'USR', passwordVariable: 'PSW')]) {
            // Encode PASS and build basic authentication in format USR:PASS
            String basicAuth = "${steps.env.USR}:${URLEncoder.encode(steps.env.PSW, 'UTF-8')}@"

            // Convert repo url to https://<username>:<password>@<server>/<repo>
            String fullRepoUrl = url.replaceAll(/(http[s]?:\/\/)/, "\$1${basicAuth}")
            return fullRepoUrl
        }
    }

    @Override
    void fetchTags() {
        String credentialsId = sourceRepositories && sourceRepositories?.size() > 0 ? sourceRepositories[0]?.credentialsId : ''
        execute('git fetch --tags', [credentialsId: credentialsId])
    }

    @Override
    Boolean createTag(String tag) {
        try {
            String credentialsId = sourceRepositories && sourceRepositories?.size() > 0 ? sourceRepositories[0]?.credentialsId : ''
            // Primero, crea el tag localmente
            execute("git tag ${tag}", [credentialsId: credentialsId])
            logger.debug("Tag '${tag}' created locally")

            // Luego, empuja el tag al repositorio remoto
            execute("git push origin ${tag}", [credentialsId: credentialsId])
            logger.debug("Tag '${tag}' pushed to remote repository")
            Boolean tagExists = tagExists(tag)

            if (tagExists) {
                logger.info("Tag '${tag}' created successfully")
                pipeline.dispatch(new TelemetryEvent( payload: new TelemetryMap(tag: tag, sourceRepositoryUrl: sourceRepositories[0].url)))
            } else {
                logger.error("Tag '${tag}' was not created")
            }
            return tagExists

        } catch (Exception e) {
            logger.error("Error creating remote tag '${tag}': ${e.message}")
            return Boolean.FALSE
        }
    }

    @Override
    Boolean tagExists(String tag) {
        try {
            // Ejecuta el comando para listar todos los tags remotos
            String output = execute("git ls-remote --tags origin ${tag}", [credentialsId: sourceRepositories.size() > 0 ? sourceRepositories[0]?.credentialsId : ''])

            // Busca el tag en la salida del comando
            if (output.contains("refs/tags/${tag}")) {
                logger.debug("Tag '${tag}' exists")
                return Boolean.TRUE
            } else {
                logger.debug("Tag '${tag}' does not exist")
                return Boolean.FALSE
            }
        } catch (Exception e) {
            logger.error("Error checking tag '${tag}': ${e.message}")
            return Boolean.FALSE
        }
    }

    @Override
    Boolean branchExists(String branchName) {
        String result = execute("git ls-remote --heads origin refs/heads/${branchName}",
                [credentialsId: sourceRepositories.size() > 0 ? sourceRepositories[0]?.credentialsId : ''])

        Boolean existBranch = result.contains("refs/heads/${branchName}")
        logger.debug("Branch '${branchName}' ${existBranch ? 'exists' : 'does not exist'}")
        return existBranch
    }

    @Override
    List<String> getAllTags(Boolean fromHead = false) {
        fetchTags()
        return steps.sh(returnStdout: true,
                script: "git tag --sort=-creatordate ${fromHead ? '--merged' : ''}").tokenize('\n')
    }


    @Override
    String getLatestTagFromCurrentHead() {
        fetchTags()
        return steps.sh(returnStdout: true, script: 'git describe --abbrev=0 --tags || true').trim()
    }

    @Override
    String describeTagWithGitSuffix(String tag) {
        return steps.sh(returnStdout: true, script: "git describe --tags --match=${tag}").trim()
    }

    @Override
    Boolean currentHeadIsTagged() {
        fetchTags()
        steps.sh(returnStatus: true, script: 'git describe --tags --exact-match') == 0
    }

    @Override
    String getCurrentHeadSha() {
        return steps.sh(returnStdout: true, script: 'git rev-list HEAD -n 1').trim()
    }

    @Override
    String getFirstCommitSha() {
        return steps.sh(returnStdout: true, script: 'git rev-list --reverse HEAD | head -1').trim()
    }

    @Override
    String getCommitMessage(String reference = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git log -1 --pretty=format:'%B' ${reference}").trim()
    }

    @Override
    String getCommitEmail(String reference = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git log -1 --pretty=format:'%ae' ${reference}").trim()
    }

    @Override
    List<String> getChangedFilesBetweenCommits(String fromRef = null, String toRef = 'HEAD') {
        return steps.sh(returnStdout: true, script: "git diff --name-only ${fromRef?.trim()} ${toRef?.trim()}").tokenize()
    }

    @Override
    Boolean isWorkingDirectoryUnmodified() {
        return steps.sh(returnStdout: true, script: 'git status --porcelain').trim() == ''
    }

    /**
     * Used to set the current branch of a repository
     *
     * @param branch Branch name that will be set
     * @return True if branch was switched successfully, False in the other case
     */
    @Override
    Boolean switchToBranch(String branch) {
        int result = steps.sh(script: "git checkout ${branch}", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    /**
     * Used to update index of repository and add all changes
     *
     * @return True if commit was created successfully, False in the other case
     */
    @Override
    Boolean addChanges() {
        int result = steps.sh(script: 'git add -A .', returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    /**
     * Used to update index of repository and add all changes
     * @param fileList is a String formatted list of files to add to stash
     * @return True if commit was created successfully, False in the other case
     */
    @Override
    Boolean addFiles(List<String> fileList) {
        int result = steps.sh(script: "git add ${fileList.join(' ')}", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }
    /**
     * Used to create a commit
     *
     * @param msg Message used to create the commit
     * @return True if index was updated successfully, False in the other case
     */
    @Override
    Boolean createCommit(String msg) {
        int result = steps.sh(script: "git commit --no-verify -m '${msg}'", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    /**
     * Push the changes to remote repository using the current branch
     *
     * @param force Push the changes ignoring warnings messages
     * @return True if push successfully, False in the other case
     */
    @Override
    Boolean push(boolean force = false) {
        int result = steps.sh(script: "git push --no-verify origin \$(git branch --show-current) ${force ? '--force' : ''}", returnStatus: true)
        if (result == 0) {
            return true
        } else {
            return false
        }
    }

    @Override
    Integer executeWithStatus(String taskName, options) {
        assert options instanceof Map: "Options in execute method from GitTool must be a Map"
        String repoUrl = getGitRemoteUrl()
        String repositoryUrlFinal = repoUrl

        if (!repoUrl.matches(/^https:\/\/.*:.*@.*$/) && options.containsKey('credentialsId') && options.credentialsId) {
            repositoryUrlFinal = getGitRepoUrlWithBasicAuth(repoUrl, options.credentialsId)
        }

        // sh +x for avoiding printing command arguments in console
        steps.withEnv(["REPO_URL=${repositoryUrlFinal}"]) {
            steps.sh(returnStdout: true, script: 'set +x; git remote set-url origin "$REPO_URL"')
        }
        return steps.sh(script: taskName, returnStatus: true)
    }

    @Override
    String execute(String taskName, options) {
        assert options instanceof Map: "Options in execute method from GitTool must be a Map"
        String repoUrl = getGitRemoteUrl()
        String repositoryUrlFinal = repoUrl

        if (!repoUrl.matches(/^https:\/\/.*:.*@.*$/) && options.containsKey('credentialsId') && options.credentialsId) {
            repositoryUrlFinal = getGitRepoUrlWithBasicAuth(repoUrl, options.credentialsId)
        }

        // sh +x for avoiding printing command arguments in console
        steps.withEnv(["REPO_URL=${repositoryUrlFinal}"]) {
            steps.sh(returnStdout: true, script: 'set +x; git remote set-url origin "$REPO_URL"')
        }
        return steps.sh(returnStdout: true, script: taskName)?.trim()
    }

    SourceRepository getDefaultSourceRepository() {
        def userRemoteConfigs = steps.scm?.getUserRemoteConfigs()
        if (userRemoteConfigs == null || userRemoteConfigs.isEmpty()) {
            logger.warn("User remote configs cannot be null or empty in jenkins scm object")
            return null
        }
        String url = userRemoteConfigs[0]?.getUrl()
        if (url == null) {
            steps.error("URL cannot be null")
        }

        // Extrae la referencia (rama o commit) del objeto scm
        def branches = steps.scm?.getBranches()
        if (branches == null || branches.isEmpty()) {
            steps.error("Branches cannot be null or empty in jenkins scm object")
        }
        String reference = branches[0]?.getName()
        if (reference == null) {
            steps.error("Reference cannot be null")
        }

        // Extrae las credenciales del objeto scm
        String credentialsId = userRemoteConfigs[0]?.getCredentialsId()
        if (credentialsId == null) {
            logger.warn("Credentials ID in remote scm url ${url} is null")
        }
        String id = url.split('/').last().replaceAll('.git', '')

        return new SourceRepository(
                id: "${id}DefaultJenkins",
                url: url,
                branch: reference,
                email: 'cicdBot@giss.devops.es',
                userName: 'Giss Jenkins Bot',
                credentialsId: credentialsId ?: '')
    }



    @Override
    void configure(IPipelineContext context) {
        Store<ProjectDescriptor> store = pipeline.getStore(ProjectDescriptor.class)
        sourceRepositories = store.select { ProjectDescriptor it-> it.sourceRepositories }
        if (sourceRepositories == null || sourceRepositories.isEmpty()) {
            sourceRepositories = getDefaultSourceRepository()
        }

    }

}
</file>

<file path="src/es/giss/framework/core/tools/ProxyHost.groovy">
package es.giss.framework.core.tools

class ProxyHost {
    private String protocol = 'http'
    private String host
    private int port = 8080
    private String proxyUser
    private String proxyPassword

    @Override
    String toString() {
        if (proxyUser || proxyPassword) {
            return "${protocol}://${proxyUser}:${proxyPassword}@${host}:${port}"
        }
        return "${protocol}://${host}:${port}"

    }
}
</file>

<file path="src/es/giss/framework/core/tools/ToolsManager.groovy">
package es.giss.framework.core.tools

import es.giss.framework.core.Stage
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.pipeline.PipelineDefinition

import java.nio.file.Path
import java.nio.file.Paths

@PipelineComponent()
class ToolsManager extends Stage implements IToolsManager {

    private static final String TOOLS_PLUGINS_SCRIPT_SH = 'tools_install_plugins.sh'
    private static final String TOOLS_VERSIONS_SCRIPT_SH = 'tools_install.sh'

    private IWorkspaceTool workspace

    private Path defaultToolsFilesDir
    private Map<String, String> toolVersions
    private Map<String, String> toolPlugins
    private Boolean forceClearCache
    private String httpsProxy
    private String toolJava


    ToolsManager(IWorkspaceTool workspace) {
        this.workspace = workspace
    }

    @Override
    String execute(String command, options) {
        return steps.sh(script: "${command}".trim(), returnStdout: true)?.trim()
    }

    void writeToolVersionsFile(Map<String, String> tools, Path toDir = defaultToolsFilesDir) {
        logger.debug("Tool versions to write:")
        logger.printPrettyLog(LogLevel.DEBUG, tools)
        String toolVersionsContent = tools.collect { k, v -> "${k} ${v}" }.join('\n')
        workspace.writeFile(Paths.get(toDir as String, '.tool-versions') as String, toolVersionsContent)
        logger.debug("Tool versions file written to ${toDir}/.tool-versions")

        logger.executeWhenDebug {
            steps.sh "cat ${toDir}/.tool-versions"
            logger.debug("Tool versions file content:")
            logger.printPrettyLog(LogLevel.DEBUG, workspace.readFile("${toDir}/.tool-versions"))
        }
    }

    void writePluginFile(Map<String, String> plugins, Path toDir = defaultToolsFilesDir) {
        logger.debug("Missing asdf plugins: ${plugins.keySet().join(', ')}")
        logger.printPrettyLog(LogLevel.DEBUG, plugins)
        String toolsPlugins = plugins.collect { k, v -> "${k} ${v}" }.join('\n')
        if (toolsPlugins.isEmpty()) {
            logger.warn("No plugins to install")
            return
        }
        workspace.writeFile(Paths.get(toDir as String, '.tool-plugins') as String, toolsPlugins)
    }


    void updatePlugins(Map<String, String> plugins, String asdfDir, Path toDir = defaultToolsFilesDir) {
        logger.debug("Plugins to install: ${plugins}")
        logger.printPrettyLog(LogLevel.DEBUG, plugins)
        writePluginFile(plugins, toDir)
        String toolPluginsFilePath = "${toDir}/.tool-plugins"
        String result = execute("${asdfDir}/${TOOLS_PLUGINS_SCRIPT_SH} ${httpsProxy} ${toolPluginsFilePath}", [:])
        logger.debug("Result Update asdf plugins: ${result}")

    }


    void installTools(String asdfDir, Path fromDir = defaultToolsFilesDir) {
        String toolsVersion = "${fromDir}/.tool-versions"
        execute("${asdfDir}/${TOOLS_VERSIONS_SCRIPT_SH} ${httpsProxy} ${toolsVersion}", [:])
        logger.executeWhenDebug {
            steps.sh 'cd ${fromDir} && asdf current'
        }
        logger.debug("Tools installed")
    }

    @Override
    void setToolVersion(String tool, String version) {
        if (tool.contains('java')) {
            setJavaVersion(version)
            return
        }
        execute("""
            asdf install $tool $version
            asdf global $tool $version
        """, [])

    }

    private void setJavaVersion(String javaVersion) {
        execute("""
        java_path=\$(update-alternatives --list  | grep "java_sdk_${javaVersion}_openjdk" | sed "s/.*\\s\\(.*\\)/\\1\\/bin\\/java/");
        if [ -n "\$java_path" ];
        then
          update-alternatives --set java "\$java_path";
        else
          echo "No se encontr la versin de Java: java-${javaVersion}";
        fi
        """, [:])
    }

    private void clearCacheIfConfigured() {
        if (forceClearCache) {
            logger.warn 'Force removing asdf cache directory. This action may take a while...'
            execute('rm -fr ${ASDF_DATA_DIR:-$HOME/.asdf}/*', [:])
        }
    }

    def copyResourcesToFile(String targetPath) {

        // Verifica si el archivo ya existe
        if (workspace.fileExists("${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}") && workspace.fileExists("${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}")) {
            logger.debug("El archivo ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH} ya existe, no se realizar ninguna accin.")
            return
        }

        String resourceInstallPluginScriptPath = "scripts/${TOOLS_PLUGINS_SCRIPT_SH}"
        // Obtn el recurso como una cadena
        String resourceInstallPluginContent = steps.libraryResource(resourceInstallPluginScriptPath)
        // Escribe el contenido del recurso en el archivo de destino
        workspace.createDirectoriesIfNotExist([Path.of(targetPath).getParent().toString()])
        logger.debug("Copiando recurso $resourceInstallPluginScriptPath a ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}")
        workspace.writeFile("${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}", resourceInstallPluginContent)
        steps.sh(script: "chmod +x ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH} && dos2unix ${targetPath}/${TOOLS_PLUGINS_SCRIPT_SH}".toString())

        String resourceInstallToolsScriptPath = "scripts/${TOOLS_VERSIONS_SCRIPT_SH}"
        String resourceInstallToolsContent = steps.libraryResource(resourceInstallToolsScriptPath)

        logger.debug("Copiando recurso $resourceInstallToolsScriptPath a ${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}")
        workspace.writeFile("${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}", resourceInstallToolsContent)
        steps.sh(script: "chmod +x ${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH} && dos2unix ${targetPath}/${TOOLS_VERSIONS_SCRIPT_SH}")
    }

    void deleteToolVersionsFile(Path file) {
        steps.sh(script: "rm -f ${file}/.tool-plugins")
    }


    @Override
    Integer executeWithStatus(String command, Object options) {
        return steps.sh(script: "${command}".trim(), returnStatus: true)
    }


    @Override
    void configure(IPipelineContext context) {

        defaultToolsFilesDir = Path.of("${steps.env.WORKSPACE}")

        String asdfDataDir = '/opt/cache/tools/.asdf-data'
        Store<PipelineDefinition> pipelineStorage = context.getStore(PipelineDefinition.class)
        pipelineStorage.select { PipelineDefinition descriptor ->
            toolJava = descriptor.toolsManager.alternatives.javaEngine
            toolPlugins = descriptor.toolsManager.asdf.plugins
            toolVersions = descriptor.toolsManager.asdf.tools
            defaultToolsFilesDir = Path.of(descriptor.toolsManager.asdf.defaultToolVersionsFileDir)
            httpsProxy = descriptor.toolsManager.asdf.proxySettings.httpsProxy
            asdfDataDir = descriptor.toolsManager.asdf.defaultDataDir
        }

        logger.debug("Installing plugins and tool versions for tools manager... with proxy ${httpsProxy}")
        clearCacheIfConfigured()

        workspace.createDirectoriesIfNotExist([asdfDataDir,])
        copyResourcesToFile(asdfDataDir)//

        logger.debug("Tool plugins: ${toolPlugins}")

        Boolean asdfDirExist = workspace.directoryExists('$ASDF_DIR')
        if(toolPlugins || !asdfDirExist) {
            updatePlugins(toolPlugins, asdfDataDir)
        }

        if (toolVersions) {
            writeToolVersionsFile(toolVersions)
            installTools(asdfDataDir)
        }

        if (toolJava) {
            setToolVersion('java', toolJava)
        }
        deleteToolVersionsFile(defaultToolsFilesDir)

    }

}
</file>

<file path="src/es/giss/framework/core/tools/WorkspaceTool.groovy">
package es.giss.framework.core.tools

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.WatchFiles

import java.nio.file.FileSystems
import java.nio.file.Path
import java.nio.file.Paths

@PipelineComponent
class WorkspaceTool extends Steps implements IWorkspaceTool {
    private WatchFiles watchFiles
    private IGitTool gitTool

    WorkspaceTool(IGitTool gitTool) {
        this.gitTool = gitTool
        this.watchFiles = new WatchFiles(inclusions: [], exclusions: [])
    }

    @Override
    Boolean directoryExists(String directory) {
        String result = execute("test -d '${directory}'"   )
        if(result.contains('El comando fall')) {
            return false
        }
        return true
    }

    void setWatchFiles(WatchFiles watchFiles) {
        this.watchFiles = watchFiles
    }

    @Override
    Boolean fileExists(String file) {
        String result =  execute("test -f ${file}")
        if(result.contains('El comando fall')) {
            return false
        }
        return true
    }

    @Override
    void createDirectoriesIfNotExist(List<String> dirs) {
        execute("mkdir -p ${dirs.join(' ')}")
    }

    @Override
    void writeFile(String file, String text) {
        String scrCat = """cat <<'EOF' > "${file}"\n${text.trim()}\nEOF"""
        int result = executeWithStatus(scrCat,[:])
        logger.debug("[WorkspaceTool.writeFile] Ejecutado con resultado: ${result}")
        checkAndThrowException(result, scrCat)
    }

    @Override
    String readFile(String file) {
        String result = execute("cat ${file}")
        checkAndThrowException(result)
        return result
    }

    @Override
    Boolean globMatch(String pattern, String str) {
        return globMatch(pattern, str, true)
    }

    @Override
    Boolean globMatch(String pattern, String str, boolean caseSensitive) {
        def globPattern = caseSensitive ? pattern : pattern.toLowerCase()
        def filePath = caseSensitive ? str : str.toLowerCase()
        return FileSystems
                .getDefault()
                .getPathMatcher("glob:${globPattern}")
                .matches(Paths.get(filePath))
    }

    @Override
    Boolean checkWatchedFiles(Boolean abortPipeline = true) {
        List<String> watchFilesInclusionsList = watchFiles?.inclusions ?: []
        List<String> watchFilesExclusionsList = watchFiles?.exclusions ?: []
        checkWatchedFiles(abortPipeline, watchFilesInclusionsList, watchFilesExclusionsList)
    }

    @Override
    Boolean checkWatchedFiles(Boolean abortPipeline, List<String> inclusions, List<String> exclusions) {
        if (!inclusions) {
            logger.warn 'No watchFiles configured'
            return true
        }

        List<String> changedFiles = getChangedFileList()
        logger.info "Files that have changed are ${changedFiles.join(', ')}"

        // Find any file included in `watchFilesInclusionsList` and not excluded in `watchFilesInclusionsList`
        Boolean foundCoincidence = changedFiles.any { file ->
            logger.debug "Checking if file '${file}' matches any inclusion patterns"
            Boolean fileFound = findFileInGlobExpressions(file, inclusions)
            Boolean fileIgnored = false

            if (fileFound) {
                logger.debug "Checking if file ${file} matches any exclusion patterns"
                fileIgnored = findFileInGlobExpressions(file, exclusions)
                logger.debug "File '${file}' is ${fileIgnored ? 'ignored' : 'included'}"
            }
            return fileFound && !fileIgnored
        }

        logger.info "${foundCoincidence ? 'Found' : 'Not found any'} coincidence"

        if (!foundCoincidence && abortPipeline) {
            logger.info 'Skip execution since no files have changed between the reference and the HEAD'
            pipeline.autoCancelled = true
            steps.currentBuild.description = 'Skipped execution'
            steps.currentBuild.result = 'SUCCESS'
        }
        return foundCoincidence
    }

    @Override
    List<Path> findFiles(String directory, String pattern) {
        String result = execute("find ${directory} -name '${pattern}'")
        checkAndThrowException(result)
        return result.tokenize('\n').collect { Paths.get(it) }
    }

    @Override
    Path findClosestFile(String directory, String pattern) {
        String result = execute("find ${directory} -depth -name '${pattern}' | head -n 1")
        checkAndThrowException(result)
        return result ? Paths.get(result.trim()) : null
    }

    private List<String> getChangedFileList() {
        // Get latest tag but if no tags are found then take the first commit
        String fromRef = (gitTool.getLatestTagFromCurrentHead()) ?: gitTool.getFirstCommitSha()
        if(fromRef.contains('El comando fall')) {
            steps.error(fromRef)
        }
        // Get the list of files that have changed between the reference and the HEAD
        return gitTool.getChangedFilesBetweenCommits(fromRef, 'HEAD')
    }

    private Boolean findFileInGlobExpressions(String filePath, List<String> expressions) {
        return expressions.any { globPattern ->
            boolean found = globMatch(globPattern, filePath)
            logger.debug "File '${filePath}' ${(found) ? 'matches' : 'does not match'} pattern ${globPattern}"
            return found
        }
    }

    private void checkAndThrowException(String result) {
        if(result.contains('El comando fall')) {
            steps.error(result)
        }
    }

    private void checkAndThrowException(int result, String msj) {
        if(result != 0) {
            steps.error("El comando fallo: ${msj}. Resultado: ${result}")
        }
    }

    @Override
    void configure(IPipelineContext context) {

    }

    String execute(String command) {
        return execute(command, [:])
    }

    @Override
    Integer executeWithStatus(String command, options) {
        return steps.sh(script: command.trim(), returnStatus: true)
    }

    @Override
    String execute(String command, Object options) {
        return steps.sh(script: """${command.trim()}  || echo "El comando fall, status=\$?" """.trim(), returnStdout: true).trim()
    }
}
</file>

<file path="src/es/giss/framework/core/utils/interfaces/IExpressionEvaluator.groovy">
package es.giss.framework.core.utils.interfaces

interface IExpressionEvaluator {

    def resolve(String expression, Map context)

    def evaluate(String groovyQuery, def context)
}
</file>

<file path="src/es/giss/framework/core/utils/ExpressionEvaluator.groovy">
package es.giss.framework.core.utils

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.utils.interfaces.IExpressionEvaluator

@PipelineComponent
class ExpressionEvaluator extends Steps implements IExpressionEvaluator {
    static final OPERATOR_PATTERN = /(it\.\w+\s*(==|!=|<=|>=|=~|>|<)\s*(.+))/
    static final EXISTENCE_PATTERN = /(it\.\w+)/
    static final LOGICAL_OPERATOR_PATTERN = /(\|\||&&)/

    @NonCPS
    def parse(String jsonPath) {
        def groovyQuery = 'data'
        def matcher = jsonPath =~ /(\w+|\[\?.*?\)\]|\[.*?\]|\*)/
        // Encuentra todas las palabras o cualquier cosa entre corchetes
        def parts = matcher.findAll().collect { it?.get(0) }

        parts.each { String part ->
            if (part.startsWith('$') || part == '*') {
                // Root element, do nothing as 'data' is already the root.
                // Wildcard, add '.*' to the Groovy query.
            } else if (part == '[*]') {
                // Wildcard, add '*' to the Groovy query.
                groovyQuery += '*'
            } else if (part.startsWith('[')) {
                // Handle slices, direct indexes, and filters.
                if (part ==~ /\[\?\(.*\)\]/) {
                    // Extract the filter condition, replace '@' with 'it'.
                    String condition = part
                            .replaceAll(/\[\?\(/, '')
                            .replaceAll(/\)\]/, '')
                            .replaceAll(/@/, 'it')
                            .replaceAll(/\$\['(.*?)'\]/, 'data.$1') // Handle references to other fields.

                    // Split the condition into parts by logical operators.
                    def conditions = condition.split(LOGICAL_OPERATOR_PATTERN)

                    // Check each part of the condition.
                    conditions.each { String cond ->
                        cond = cond.trim()
                        def operatorsMatcher = cond =~ OPERATOR_PATTERN
                        def existenceMatcher = cond =~ EXISTENCE_PATTERN
                        if (!operatorsMatcher.matches() && !existenceMatcher.matches()) {
                            throw new IllegalArgumentException("Invalid filter condition: '${cond}'. The condition should follow one of the allowed patterns: '==', '!=', '<', '<=', '>', '>=', '=~', or a field existence check.")
                        }
                    }
                    groovyQuery += ".findAll { ${condition} }"

                } else if (part ==~ /\[-?\d*,-?\d*\]|\[-?\d+\]/) {
                    // Handle array slice.
                    groovyQuery += part
                            .replaceAll(/:/, '..')
                            .replace('[..', '[0..')
                            .replace('..]', '..-1]')

                } else if (part ==~ /\[-?\d*:-?\d*\]|\[-?\d+\]/) {
                    // Handle array slice.
                    def tempPart = part

                    if (part ==~ /\[.*:\d+\]/) {
                        tempPart = part.replace(']', ' - 1]')
                    }
                    groovyQuery += tempPart
                            .replace(/:/, '..')
                            .replace('[..', '[0..')
                            .replace('..]', '..-1]')


                } else {
                    // Handle direct index.
                    groovyQuery += '.' + part.replaceAll(/['\'|\"|\[|\]]/, '')
                }
            } else {
                // Property access
                groovyQuery += ".${part}"
            }
        }
        if(groovyQuery.endsWith('first') || groovyQuery.endsWith('last')) {
            groovyQuery = "${groovyQuery}()"
        }
        return groovyQuery
    }

    @NonCPS
    def evaluate(String groovyQuery, def context) {
        Binding binding = new Binding()
        binding.setVariable('data', context)
        GroovyShell shell = new GroovyShell(binding)

        try {
            return shell.evaluate(groovyQuery)
        } catch (Exception e) {
            throw new RuntimeException("Failed to evaluate the query: ${e.message}")
        }
    }


    @Override
    def resolve(String expression, Map context) {
        try {
            if(expression.contains("find")){
                return evaluate("data.${expression}", context)
            }
            String query = parse(expression)
            return evaluate(query, context)
        } catch (Exception e) {
            return null
        }
    }
}
</file>

<file path="src/es/giss/framework/core/utils/MapUtils.groovy">
package es.giss.framework.core.utils

import com.cloudbees.groovy.cps.NonCPS

/**
 * Utility methods for maps
 */
class MapUtils {

    /**
     * Find the first key path that exists in the map or return null
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: [
     *      b: [
     *        c: 'value'
     *      ],
     *      d: 'other value'
     *    ]
     * ]
     * findFirstKeyPathOrNull(props, 'a.b.c', 'a.d') // returns 'value'
     * </code></pre>
     * </p
     *
     * @param map Map to search for the key path
     * @param keyPaths Key paths with dot notation to search for in the map in order of priority
     * @return The value of the first key path found or null
     */
    static Object findFirstKeyPathOrNull(Map<String, Serializable> map, String... keyPaths) {
        return keyPaths.collect { keyPath -> findDeep(map, keyPath) }.find { it != null }
    }

    /**
     * Find the key path if it exists in the map or return null
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: [
     *      b: [
     *        c: 'value'
     *      ],
     *      d: 'other value'
     *    ]
     * ]
     * findDeep(props, 'a.b.c') // returns 'value'
     * </code></pre>
     * </p>
     *
     * @param map Map to search for the key path
     * @param keyPath Key path to search for in the map with dot notation
     * @return The value of the key path or null
     */
    @NonCPS
    static Object findDeep(Map<String, Serializable> map, String keyPath) {
        try {
            def slice = keyPath.split('\\.')
            def key = slice[0]

            if (map.containsKey(key) && slice.size() == 1) {
                return map[key]
            }

            if (map.containsKey(key) && map[key] instanceof Map) {
                return findDeep(map[key] as Map, slice[1..-1].join('.'))
            }

            def matcher = (key =~ /\[(.*?)\]/)
            def filter = null

            if (matcher.find()) {
                filter = matcher.group(1)
                key = key.split('\\[')[0]
            }

            if (map.containsKey(key) && map[key] instanceof List) {
                if (filter?.contains(',')) {
                    def indices = filter.split(',').collect { it.toInteger() }
                    def results = indices.collect { map[key][it] }
                    return slice.size() > 1 ? results.collect { findDeep(it as Map, slice[1..-1].join('.')) } : results
                } else if (filter?.isNumber()) {
                    def result = map[key][filter.toInteger()]
                    return slice.size() > 1 ? findDeep(result as Map, slice[1..-1].join('.')) : result
                } else if (filter?.startsWith('@')) {
                    def attr = filter.substring(1).split('=')[0]
                    def value = filter.substring(1).split('=')[1].replaceAll('"', '')
                    return map[key].find { it[attr] == value }
                } else {
                    return map[key].find {
                        it instanceof Map && (filter ? it[filter.split('=')[0]] == filter.split('=')[1].replaceAll('"', '') : true)
                                ? (slice.size() > 1 ? findDeep(it as Map, slice[1..-1].join('.')) : it)
                                : null
                    }
                }
            }
        } catch (NullPointerException e) {
            return null
        }
    }


    /**
     * Find the key path if it exists in the map or return the default value
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: [
     *      b: [
     *        c: 'value'
     *      ],
     *      d: 'other value'
     *    ]
     * ]
     * findDeepOrDefault(props, 'a.m', 'default value') // returns 'default value'
     * </code></pre>
     * </p>
     *
     * @param map Map to search for the key path
     * @param keyPath Key path to search for in the map with dot notation
     * @param defaultValue Default value to return if the key path is not found
     * @return The value of the key path or the default value
     */
    static Object findDeepOrDefault(Map<String, Serializable> map, String keyPath, Object defaultValue) {
        return findDeep(map, keyPath) ?: defaultValue
    }

    /**
     * Delete all null entries from a map
     *
     * <p>
     * Example:
     * <pre><code>
     * def props = [
     *    a: 1234,
     *    b: null,
     *    c: [
     *      d: null,
     *    ]
     * ]
     * deleteNullEntries(props) // returns [a: 1234]
     * </code></pre>
     * </p>
     *
     * @param map Map to delete null entries from recursively
     * @return The map with all null entries removed
     */
    @NonCPS
    static Map deleteNullEntries(Map map) {
        return map
                ?.collectEntries { k, v -> [k, v instanceof Map ? deleteNullEntries(v) : v] }
                ?.findAll { k, v -> v || v == false } as Map
    }

    /**
     * Merge multiple maps recursively
     *
     * <p>
     * Example:
     * <pre><code>
     * def map1 = [
     *    a: 1234,
     *    b: [
     *      c: 5678,
     *    ]
     * ]
     * def map2 = [
     *    a: 4321,
     *    b: [
     *      d: 8765,
     *    ]
     * ]
     * merge(map1, map2) // returns [a: 4321, b: [c: 5678, d: 8765]]
     * </code></pre>
     * </p>
     *
     * @param maps Maps to merge
     * @return The merged map
     */
    static Map deepMerge(Map... maps) {
        Map result = [:]
        maps.each { map ->
            map.each { k, v ->
                if (result[k] instanceof Map && v instanceof Map) {
                    result[k] = deepMerge(result[k] as Map, v as Map)
                } else if (result[k] instanceof List && v instanceof List) {
                    result[k] = (result[k] as List) + (v as List)
                } else {
                    result[k] = v
                }
            }
        }
        return result
    }

    static Map deepMergeWithKeys(List<String> keys, List<Map> maps) {
        deepMergeWithKeys(keys, maps as Map[])
    }

    static Map deepMergeWithKeys(List<String> keys, Map... datas) {
        Map result = [:]
        datas.each { map ->
            if (map instanceof Map) {
                map.each { k, v ->
                    if (result[k] instanceof Map && v instanceof Map) {
                        boolean keysMatch = keys.any { key -> result[k][key] == v[key] }
                        if (keysMatch) {
                            result[k] = deepMergeWithKeys(keys, [result[k] as Map, v as Map])
                        } else {
                            result[k] = v
                        }
                    } else if (result[k] instanceof List && v instanceof List) {
                        result[k] = mergeLists(keys, result[k] as List, v as List)
                    } else {
                        result[k] = v
                    }
                }
            }
        }
        return result
    }


    static List mergeLists(List<String> keys, List dataOrigin, List dataOverride) {
        Map map = [:]
        dataOrigin.each { item ->
            if (item instanceof Map) {
                if (keys.any { item.containsKey(it)}) {
                    String key = keys.find{ item.containsKey(it) }
                    map[item[key]] = item
                } else {
                    map[item] = item
                }
            }
        }
        dataOverride.each { item ->
            if (item instanceof Map) {
                if (keys.any { item.containsKey(it) }) {
                    String key = keys.find { item.containsKey(it) }
                    if (map.containsKey(item[key])) {
                        map[item[key]] = deepMerge(map[item[key]] as Map, item as Map)
                    } else {
                        map[item[key]] = item
                    }
                } else {
                    map[item] = item
                }
            }
        }
        return map.values() as List
    }

    /**
     * Same as {@link #deepMerge(Map ...)} but with a list of maps
     *
     * @param maps Maps to merge
     * @return The merged map
     */
    @NonCPS
    static Map deepMerge(List<Map> maps) {
        deepMerge(*maps)
    }

}
</file>

<file path="src/es/giss/framework/core/utils/XmlUtils.groovy">
package es.giss.framework.core.utils

class XmlUtils {

    static Map xmlToMap(String xmlContent) {
        def root = new XmlSlurper().parseText(xmlContent)
        def map = [:]

        def recursiveMap
        recursiveMap = { node, parentMap ->
            node.children().each { child ->
                if (child.children().size() > 0) {
                    Map childMap = [:]
                    parentMap[child.name()] = childMap
                    if (child.attributes().size() > 0) {
                        childMap["@attributes"] = child.attributes()
                    }
                    recursiveMap(child, childMap)
                } else {
                    parentMap[child.name()] = child.text()
                }
            }
        }

        recursiveMap(root, map)
        return map
    }
}
</file>

<file path="src/es/giss/framework/core/vo/events/ArtifactCreatedEvent.groovy">
package es.giss.framework.core.vo.events

import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.vo.project.Artifact


class ArtifactCreatedEvent<A extends Artifact> extends PipelineEvent {
    A artifact

    @Override
    String toString() {
        return "ArtifactCreatedEvent[artifact=${artifact}]"
    }

}
</file>

<file path="src/es/giss/framework/core/vo/events/StageCompletedEvent.groovy">
package es.giss.framework.core.vo.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class StageCompletedEvent implements TelemetryModel {
    String stageName
    long duration = 0

    @Override
    Map<String, Object> toMap() {
        return [
            stageName: stageName,
            duration: duration
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/events/StageErrorEvent.groovy">
package es.giss.framework.core.vo.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class StageErrorEvent implements TelemetryModel {
    String stageName
    String message
    List<String> filteredStackTrace

    @Override
    String toString() {
        return "StageErrorEvent{stageName=${stageName}, message=${message}}"
    }

    @Override
    Map<String, Object> toMap() {
        return [
                stageName         : stageName,
                message           : message,
                filteredStackTrace: filteredStackTrace
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/events/StageStarted.groovy">
package es.giss.framework.core.vo.events


import es.giss.framework.core.events.interfaces.TelemetryModel

class StageStarted implements TelemetryModel {
    String stageName

    @Override
    String toString() {
        return "StageStartedEvent{stageName=${stageName}}"
    }

    @Override
    Map<String, Object> toMap() {
        return [
                stageName: stageName
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/observability/ObservabilityHub.groovy">
package es.giss.framework.core.vo.observability

import es.giss.framework.core.events.interfaces.TelemetryModel

class ObservabilityHub implements TelemetryModel {
    List<TelemetryModel> models = new ArrayList<>()

    @Override
    Map<String, Object> toMap() {
        return [
                models: models.collect { it.toMap() }
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/observability/TelemetryMap.groovy">
package es.giss.framework.core.vo.observability

import es.giss.framework.core.events.interfaces.TelemetryModel

class TelemetryMap extends HashMap<String, Object> implements TelemetryModel {
    @Override
    Map<String, Object> toMap() {
        return this
    }
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/AlternativesToolsDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import es.giss.framework.core.events.interfaces.PipelineModel

class AlternativesToolsDescriptor implements PipelineModel {
    String javaEngine = 'java17'

    @Override
    Map<String, Object> toMap() {
        return [
                javaEngine: javaEngine
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/AsdfToolsManagerDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import es.giss.framework.core.events.interfaces.PipelineModel

class AsdfToolsManagerDescriptor implements PipelineModel  {
    String defaultToolVersionsFileDir
    String defaultDataDir
    boolean forceClearCache = false
    ProxySettings proxySettings
    Map<String, String> plugins = [:]
    Map<String, String> tools = [:]

    @Override
    Map<String, Object> toMap() {
        return [
                defaultToolVersionsFileDir: defaultToolVersionsFileDir,
                defaultDataDir             : defaultDataDir,
                forceClearCache            : forceClearCache,
                proxySettings              : proxySettings.toMap(),
                plugins                    : plugins,
                tools                      : tools
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/CacheDescriptor.groovy">
package es.giss.framework.core.vo.pipeline

import es.giss.framework.core.events.interfaces.PipelineModel

class CacheDescriptor implements PipelineModel {
    String baseDir
    Set<String> cacheFolders
    String exportEnvVar
    boolean forceClearCache

    @Override
    Map<String, Object> toMap() {
        return [
                baseDir         : baseDir,
                cacheFolders    : cacheFolders,
                exportEnvVar    : exportEnvVar,
                forceClearCache : forceClearCache
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/PipelineDefinition.groovy">
package es.giss.framework.core.vo.pipeline

import es.giss.framework.core.events.interfaces.PipelineModel


class PipelineDefinition implements PipelineModel {
    PipelineSettings settings
    CacheDescriptor cache
    ToolsManagerDescriptor toolsManager

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion       : settings.apiVersion,
                skipStages       : settings.skipStages,
                debugMode        : settings.debugMode,
                devopsEnvironment: settings.devopsEnvironment,
                cache            : cache.toMap(),
                environmentVars  : settings.environmentVars,
                toolsManager     : toolsManager.toMap()
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/PipelineSettings.groovy">
package es.giss.framework.core.vo.pipeline

class PipelineSettings {
    String apiVersion = 'v1'
    Set<String> skipStages = []
    boolean debugMode = false
    String devopsEnvironment
    Map<String, String> environmentVars = [:]
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/ProxySettings.groovy">
package es.giss.framework.core.vo.pipeline

import es.giss.framework.core.events.interfaces.PipelineModel

class ProxySettings implements PipelineModel {
    String httpProxy = ''
    String httpsProxy = ''
    String noProxy = ''

    @Override
    Map<String, Object> toMap() {
        return [
                httpProxy : httpProxy,
                httpsProxy: httpsProxy,
                noProxy   : noProxy
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/pipeline/ToolsManagerDescriptor.groovy">
package es.giss.framework.core.vo.pipeline


class ToolsManagerDescriptor  {
    AlternativesToolsDescriptor alternatives
    AsdfToolsManagerDescriptor asdf

    Map<String, Object> toMap() {
        return [
                alternatives: alternatives.toMap(),
                asdf: asdf.toMap()
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/BuildStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.project.Metadata
import groovy.text.GStringTemplateEngine

class BuildStrategy implements ProjectActionStrategy {
    String id
    String toolId
    String name
    String buildCommand
    Metadata metadata = new Metadata()


    @Override
    String getCommand() {
        return new GStringTemplateEngine().createTemplate(buildCommand).make(metadata).toString()
    }



    @NonCPS
    @Override
    String toString() {
        return """
        BuildStrategy {
                id: ${id},
                name: ${name},
                buildCommand: ${buildCommand},               
                metadata: ${metadata}
            }"""
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                buildCommand: buildCommand,
                metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/DeployStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.project.Metadata

class DeployStrategy implements ProjectActionStrategy {
    String id
    String toolId
    String name
    String deployCommand
    Metadata metadata

    @Override
    String getCommand() {
        return deployCommand
    }

    @NonCPS
    @Override
    String toString() {
        return """
        DeployStrategy {
                id: ${id},
                name: ${name},
                deployCommand: ${deployCommand},               
                metadata: ${metadata}
            }"""
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                deployCommand: deployCommand,
                metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/ProjectActionStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.vo.project.Metadata


interface ProjectActionStrategy extends ProjectDescriptorModel {

    String getId()

    String getToolId()

    String getName()

    String getCommand()

    Metadata getMetadata()
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/ProjectActionStrategyManager.groovy">
package es.giss.framework.core.vo.project.strategies

import es.giss.framework.core.vo.project.Artifact

class ProjectActionStrategyManager {

    private Map<String, ProjectActionStrategy> strategies = [:]
    private Map<String, Artifact> artifacts = [:]


    void resolveBuildStrategies(Map currenTool) {
        currenTool.buildStrategies.each {
            if (it instanceof BuildStrategy) {
                registerStrategy(it)
            } else if (it instanceof Map) {
                registerStrategy(new BuildStrategy(
                        id: it.id,
                        name: it.name,
                        buildCommand: it.buildCommand,
                        metadata: it.metadata
                ))
            }
        }
    }

    void resolvePublishStrategies(Map currentTool) {
        currentTool.publishStrategies.each {
            if (it instanceof PublishStrategy) {
                registerStrategy(it)
            } else if (it instanceof Map) {
                registerStrategy(new PublishStrategy(
                        id: it.id,
                        name: it.name,
                        publishCommand: it.publishCommand,
                        metadata: it.metadata
                ))
            }
        }
    }

    void resolveTestStrategies(Map currentTool) {
        currentTool.testStrategies.each {
            if (it instanceof TestStrategy) {
                registerStrategy(it)
            } else if (it instanceof Map) {
                registerStrategy(new TestStrategy(
                        id: it.id,
                        name: it.name,
                        testCommand: it.testCommand,
                        metadata: it.metadata
                ))
            }
        }
    }

    void resolveDeployStrategies(Map currentTool) {
        currentTool.deployStrategies.each {
            if (it instanceof DeployStrategy) {
                registerStrategy(it)
            } else if (it instanceof Map) {
                registerStrategy(new DeployStrategy(
                        id: it.id,
                        name: it.name,
                        deployCommand: it.deployCommand,
                        metadata: it.metadata
                ))
            }
        }
    }

    void resolveRollBackStrategies(Map currentTool) {
        currentTool.rollBackStrategies.each {
            if (it instanceof RollbackStrategy) {
                registerStrategy(it)
            } else if (it instanceof Map) {
                registerStrategy(new RollbackStrategy(
                        id: it.id,
                        name: it.name,
                        rollBackCommand: it.rollBackCommand,
                        metadata: it.metadata
                ))
            }
        }
    }

    void resolveUnDeployStrategies(Map currentTool) {
        currentTool.unDeployStrategies.each {
            if (it instanceof UndeployStrategy) {
                registerStrategy(it)
            } else if (it instanceof Map) {
                registerStrategy(new UndeployStrategy(
                        id: it.id,
                        name: it.name,
                        unDeployCommand: it.unDeployCommand,
                        metadata: it.metadata
                ))
            }
        }
    }

    void ensureExistId(strategy) {
        if (!strategy?.id) {
            throw new Exception("No se ha definido un id en la configuracin de la estrategia de test")
        }
    }


    void registerStrategy(ProjectActionStrategy strategy) {
        ensureExistId(strategy)
        strategies.put(strategy.id, strategy)
    }

    void registerArtifact(String buildStrategyId, Artifact artifact) {
        artifacts.put(buildStrategyId, artifact)
    }

    Artifact getArtifact(String buildStrategyId) {
        return artifacts.get(buildStrategyId)
    }

    def <T extends ProjectActionStrategy> T getStrategyById(String id) {
        return strategies.get(id) as T
    }

    List<ProjectActionStrategy> getStrategies() {
        return strategies.values().toList()
    }

}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/PublishStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.vo.project.Metadata

class PublishStrategy implements ProjectActionStrategy {
    String id
    String toolId
    String name
    String publishCommand
    Metadata metadata = new Metadata()

    @Override
    String getCommand() {
        return publishCommand
    }

    @NonCPS
    @Override
    String toString() {
        return """
        PublishStrategy {
                id: ${id},
                name: ${name},
                publishCommand: ${publishCommand},               
                metadata: ${metadata}
            }"""
    }

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            publishCommand: publishCommand,
            metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/RollbackStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import es.giss.framework.core.vo.project.DeployTarget
import es.giss.framework.core.vo.project.Metadata

class RollbackStrategy implements ProjectActionStrategy {
    String id
    String toolId
    String name
    String rollbackCommand
    DeployTarget deployTarget
    Metadata metadata

    @Override
    String getCommand() {
        return rollbackCommand
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                rollbackCommand: rollbackCommand,
                metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/TestStrategy.groovy">
package es.giss.framework.core.vo.project.strategies

import es.giss.framework.core.vo.project.Metadata

class TestStrategy implements ProjectActionStrategy {
    String id
    String toolId
    String name
    String testCommand
    Metadata metadata

    @Override
    String getCommand() {
        return testCommand
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                rollbackCommand: testCommand,
                metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/strategies/UndeployStrategy.groovy">
package es.giss.framework.core.vo.project.strategies


import es.giss.framework.core.vo.project.Metadata

class UndeployStrategy implements ProjectActionStrategy {
    String id
    String toolId
    String name
    String undeployCommand
    Metadata metadata

    @Override
    String getCommand() {
        return undeployCommand
    }

    @Override
    Map<String, Object> toMap() {
        return [
                id             : id,
                name           : name,
                rollbackCommand: undeployCommand,
                metadata       : metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/Artifact.groovy">
package es.giss.framework.core.vo.project


import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class Artifact implements ProjectDescriptorModel {
    String id
    String name
    String version // Calculated
    String url // Calculated
    String localPath // Calculated
    String description
    String idRepository
    String type

    @Override
    Map<String, Object> toMap() {
        return null
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/ArtifactsRepository.groovy">
package es.giss.framework.core.vo.project

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ArtifactsRepository implements ProjectDescriptorModel {
    String id
    String name
    String url
    String type
    String credentialsId
    Metadata metadata = new Metadata()

    boolean validate() {
        return id && url && credentialsId
    }

    @NonCPS
    @Override
    String toString() {
        return "ArtifactsRepository(id: ${id}, name: ${name}, url: ${url}, type: ${type}, credentialsId: ${credentialsId}, metadata: ${metadata})"
    }

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            url: url,
            type: type,
            credentialsId: credentialsId,
            metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/DeployTarget.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class DeployTarget implements ProjectDescriptorModel {
    String id
    String name
    String description
    String type
    Metadata metadata

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            description: description,
            type: type,
            metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/Email.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class Email implements ProjectDescriptorModel {
    String name
    String email
    Set<String> notificationsInterested = []

    @Override
    Map<String, Object> toMap() {
        return [
                name                   : name,
                email                  : email,
                notificationsInterested: notificationsInterested
        ]
    }

    @Override
    String toString() {
        return "Email{" +
                "name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", notificationsInterested='" + notificationsInterested + '\'' +
                '}'
    }

    @Override
    boolean equals(Object o) {
        if (!(o instanceof Email)) return false
        Email emailObj = (Email) o

        return email != null ? email == emailObj.email : emailObj.email == null
    }

    @Override
    int hashCode() {
        return email != null ? email.hashCode() : 0
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/Metadata.groovy">
package es.giss.framework.core.vo.project

class Metadata extends HashMap<String, Object>{
}
</file>

<file path="src/es/giss/framework/core/vo/project/Notification.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class Notification implements ProjectDescriptorModel {
    Set<Email> emails

    @Override
    Map<String, Object> toMap() {
        return [
            emails: emails.collect { it.toMap() }
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/ProjectDescriptor.groovy">
package es.giss.framework.core.vo.project


import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectDescriptor implements ProjectDescriptorModel {
    ProjectSettings projectSettings
    List<SourceRepository> sourceRepositories
    Notification notifications
    ProjectSpec spec
    ProjectStatus status

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion           : projectSettings.apiVersion,
                name                 : projectSettings.name,
                description          : projectSettings.description,
                inceptionYear        : projectSettings.inceptionYear,
                developCenter        : projectSettings.developCenter,
                codeCapp             : projectSettings.codeCapp,
                elementoPromocionable: projectSettings.elementoPromocionable,
                version              : projectSettings.version,
                sourceRepositories   : sourceRepositories.collect { it.toMap() },
                notifications        : notifications.collect { it.toMap() },
                spec                 : spec.toMap(),
                status               : status.toMap()
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/ProjectSettings.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectSettings implements ProjectDescriptorModel {
    String apiVersion = 'v1'
    String name
    String description
    String inceptionYear
    String developCenter
    String codeCapp
    String elementoPromocionable
    String version

    @Override
    Map<String, Object> toMap() {
        return [
                apiVersion           : apiVersion,
                name                 : name,
                description          : description,
                inceptionYear        : inceptionYear,
                developCenter        : developCenter,
                codeCapp             : codeCapp,
                elementoPromocionable: elementoPromocionable,
                version              : version
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/ProjectStatus.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ProjectStatus implements ProjectDescriptorModel {

    // TODO: Considerar una estructura de datos similar a esta:
    //  buildStatus: new BuildStatus(),
    //  deployStatus: new DeployStatus()

    List<Artifact> artifacts

    @Override
    Map<String, Object> toMap() {
        return [
                artifacts: artifacts.collect { it.toMap() }
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/ProjectTool.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.vo.project.strategies.*

class ProjectTool implements ProjectDescriptorModel {
    String id
    String name
    String version
    boolean cache
    String toolConfigurationFile
    String artifactsRepositoryId
    List<ProjectActionStrategy> strategies


    @Override
    Map<String, Object> toMap() {
        return [
                id: id,
                name: name,
                version: version,
                cache: cache,
                toolConfigurationFile: toolConfigurationFile,
                artifactsRepositoryId: artifactsRepositoryId,
                buildStrategy: strategies.find { it instanceof BuildStrategy }?.toMap(),
                testStrategy: strategies.find { it instanceof TestStrategy }?.toMap(),
                publishStrategy: strategies.find { it instanceof PublishStrategy }?.toMap(),
                deployStrategy: strategies.find { it instanceof DeployStrategy }?.toMap(),
                undeployStrategy: strategies.find { it instanceof UndeployStrategy }?.toMap(),
                rollbackStrategy: strategies.find { it instanceof RollbackStrategy }?.toMap()
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/ScannerTool.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class ScannerTool implements ProjectDescriptorModel {
    String id
    String name
    String description
    String command
    Metadata metadata

    @Override
    Map<String, Object> toMap() {
        return [
            id: id,
            name: name,
            description: description,
            command: command,
            metadata: metadata
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/project/SourceRepository.groovy">
package es.giss.framework.core.vo.project

import es.giss.framework.core.events.interfaces.ProjectDescriptorModel

class SourceRepository implements ProjectDescriptorModel {
    String id
    String url
    String branch
    String email
    String userName
    String credentialsId

    Map toMap() {
        return [
            id: id,
            url: url,
            branch: branch,
            email: email,
            userName: userName,
            credentialsId: credentialsId
        ]
    }
}
</file>

<file path="src/es/giss/framework/core/vo/resources/http/FormDataCollection.groovy">
package es.giss.framework.core.vo.resources.http

import com.cloudbees.groovy.cps.NonCPS

import java.nio.file.Path

class FormDataCollection {
    Map<String, Path> files
    Map<String, Object> data

    @NonCPS
    @Override
    String toString() {
        List<String> postData = []
        data.each { key, value ->
            postData.add("${key}=${value}")
        }

        files.each { key, path ->
            postData.add("${key}@${path}")
        }
        return postData.join(' ')

    }
}
</file>

<file path="src/es/giss/framework/core/vo/resources/http/HttpResponse.groovy">
package es.giss.framework.core.vo.resources.http

import com.cloudbees.groovy.cps.NonCPS
import groovy.json.JsonSlurperClassic


class HttpResponse {
    Integer statusCode
    Map headers
    String body

    @NonCPS
    @Override
    String toString() {
        return "status_code: ${statusCode}, response: ${body}"
    }

    @NonCPS
    Object parseJsonBody() {
        return new JsonSlurperClassic().parseText(body as String)
    }

    Object parseJsonBody(steps) {
        return steps.readJSON(text: body as String)
    }
}
</file>

<file path="src/es/giss/framework/core/vo/resources/http/RequestOptions.groovy">
package es.giss.framework.core.vo.resources.http

class RequestOptions {
    Map<String, Serializable> headers
    String clientCertPath
    String clientKeyPath
    List<Integer> checkStatusCodes
    Boolean ignoreSslErrors = false
    Boolean followRedirects = true
    Boolean printCommand = null // null to use the default value in HTTPieTool
    Boolean logResponse = false
    Boolean mapJsonBody = false
    String saveResponseBodyToFile
    Integer timeout = 30
    FormDataCollection formDataCollection
}
</file>

<file path="src/es/giss/framework/core/vo/resources/ProjectDefinitionFile.groovy">
package es.giss.framework.core.vo.resources

class ProjectDefinitionFile {
    String name
    String version
    def dependencies
}
</file>

<file path="src/es/giss/framework/core/vo/WatchFiles.groovy">
package es.giss.framework.core.vo

class WatchFiles {
    List<String> inclusions
    List<String> exclusions
}
</file>

<file path="src/es/giss/framework/core/PipelineContext.groovy">
package es.giss.framework.core

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.dependencies.DependencyResolver
import es.giss.framework.core.cdi.dependencies.IDependencyResolver
import es.giss.framework.core.cdi.scanner.ClassesInPackageScanner
import es.giss.framework.core.cdi.scanner.fiters.AnnotatedClassResourceFilter
import es.giss.framework.core.events.ConfiguredPipelineEvent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.events.PipelineEvent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.events.interfaces.PipelineModel
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.interfaces.*
import es.giss.framework.core.logger.Logger
import es.giss.framework.core.storage.Store
import es.giss.framework.core.storage.mutations.ObservabilityHubMutation
import es.giss.framework.core.storage.mutations.PipelineMutation
import es.giss.framework.core.storage.mutations.ProjectDescriptorMutation
import es.giss.framework.core.tools.interfaces.IToolsManager
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.vo.observability.ObservabilityHub
import es.giss.framework.core.vo.pipeline.*
import es.giss.framework.core.vo.project.*

import java.nio.file.Path

class PipelineContext implements IPipelineContext {
    private static def regexOcNamespace = /^[\w:\\/]+-(([\w]+)-([\w]+)-([\w]+)).[\w.]+/
    public static final List<String> DEFAULT_SCAN_PACKAGES = ['es.giss.framework']
    private ClassesInPackageScanner scanner
    private IDependencyResolver dependencyResolver

    private List<String> skipStages = new ArrayList()
    private Script steps
    private Boolean autoCancelled
    private Boolean isDebuggable
    private Map<Class<? extends PipelineModel>, Store> storeMap = [:]

    private ILogger logger
    private IWorkspaceTool workspaceTool

    PipelineContext(Script steps) {
        this.steps = steps
        this.scanner = new ClassesInPackageScanner()
        this.scanner.setResourceFilter(new AnnotatedClassResourceFilter(PipelineComponent))

        this.dependencyResolver = new DependencyResolver()
        this.skipStages = new ArrayList()
        logger = new Logger(steps)
    }

    @NonCPS
    @Override
    void registerComponentsFromPackages(List<String> packageNames = DEFAULT_SCAN_PACKAGES) {
        packageNames.each { packageName ->
            Set<Class<?>> componentClass = scanner.findDefaultImplementers(packageName, PipelineComponent)
            registerAll(componentClass, packageName)
        }

        dependencyResolver.registerCoreComponent(Script.class, steps)
        dependencyResolver.registerCoreComponent(IPipelineContext.class, this)
        dependencyResolver.initialize()
    }

    @NonCPS
    private void registerAll(Set<Class<?>> componentClass, String packageName) {
        componentClass.each { serviceClass ->
            def interfaces = filterInstances(serviceClass, packageName)

            if (interfaces.size() == 0) {
                registerPipelineComponent(serviceClass, serviceClass)
            }

            interfaces.each { interfaceClass ->
                registerPipelineComponent(interfaceClass, serviceClass)
            }
        }
    }

    @NonCPS
    private void registerPipelineComponent(Class<?> type, Class<?> serviceClass) {
        dependencyResolver.register(type, serviceClass)
    }

    @NonCPS
    private static List<Class<?>> filterInstances(Class<?> serviceClass, String packageName) {
        return serviceClass.interfaces.findAll { interfaceIt ->
            interfaceIt.name.startsWith(packageName) || DEFAULT_SCAN_PACKAGES.any {
                pkg -> interfaceIt.name.startsWith(pkg)
            }
        }
    }


    @NonCPS
    @Override
    def <T> T getComponent(Class<T> type, String name) {
        dependencyResolver.getInstance(type, name)
    }

    @NonCPS
    @Override
    def <T> T getComponent(Class<T> type) {
        return dependencyResolver.getInstance(type)
    }


    @Override
    void configureServicesByPriority() {
        IToolsManager toolsManager = getComponent(IToolsManager.class)
        initializePipelineDefaultStore()
        initializeProjectDescriptorStore()
        initializeTelemetryStore()
        this.configure()
        toolsManager.configure(this)
        def map = groupInstancesByPriority()
        [
                ConfigurationPriority.HIGHEST,
                ConfigurationPriority.HIGH,
                ConfigurationPriority.MEDIUM,
                ConfigurationPriority.LOW,
                ConfigurationPriority.LOWEST

        ].each { priority ->
            map.get(priority).each { instance ->
                if (instance instanceof Configurable && !(instance instanceof IToolsManager)) {
                    (instance as Configurable).configure(this)
                }
            }
        }

    }

    @Override
    void setAutoCancelled(Boolean autoCancel) {
        autoCancelled = autoCancel
    }

    @Override
    Boolean isAutoCancelled() {
        return autoCancelled
    }

    @Override
    void setDebugMode(Boolean debugMode) {
        this.isDebuggable = debugMode
    }

    @Override
    Boolean isDebugMode() {
        return isDebuggable
    }

    @Override
    List<String> getSkipStages() {
        return skipStages
    }

    @Override
    void addSkipStage(String stage) {
        skipStages.add(stage)
    }

    @Override
    void injectEnvironmentVariables(Map<String, String> envVars) {
        def envs = steps.env
        envVars.each { k, v -> envs[k] = v }
    }

    @NonCPS
    @Override
    Map groupInstancesByPriority() {
        def finalSortedInstances = [
                (ConfigurationPriority.HIGHEST): [],
                (ConfigurationPriority.HIGH)   : [],
                (ConfigurationPriority.MEDIUM) : [],
                (ConfigurationPriority.LOW)    : [],
                (ConfigurationPriority.LOWEST) : []
        ]

        dependencyResolver.getInstances().each { key, value ->
            def priority = key.priority
            finalSortedInstances.get(priority).add(value)
        }
        return finalSortedInstances
    }

    @NonCPS
    int getSizedInstances() {
        return dependencyResolver.getSizedInstances()
    }

    @NonCPS
    @Override
    void dispatch(PipelineEvent event) {
        try {
            if(!event.payload) {
                steps.error("Payload is required in event ${event}")
            }
            switch (event.payload.getClass()) {
                case PipelineModel:
                    Store<PipelineDefinition> store = getStore(PipelineDefinition.class)
                    store.dispatch(event)
                    break
                case ProjectDescriptorModel:
                    Store<ProjectDescriptor> store = getStore(ProjectDescriptor.class)
                    store.dispatch(event)
                    break
                case TelemetryModel:
                    Store<ObservabilityHub> store = getStore(ObservabilityHub.class)
                    store.dispatch(event)
                    break
                default:
                    logger.warn("Store not found for ${event.payload?.getClass()?.getSimpleName()} in dependency resolver")
            }
        } catch (Exception e) {
            logger.warn("Error dispatching event ${event} with payload ${event.payload}. Error: ${e.getMessage()}")
        }

    }


    @Override
    void registerConfigAdaptersFromPackages(List<String> packageNames = DEFAULT_SCAN_PACKAGES) {
        packageNames.each { packageName ->
            Set<Class<IConfigAdapter>> componentClass = scanner.findImplementers(packageName, IConfigAdapter.class)
            IConfigClient configClient = getComponent(IConfigClient.class)

            componentClass.collect { adapterClass ->
                PipelineComponent annotation = adapterClass.getAnnotation(PipelineComponent)
                String name = annotation?.name()
                IConfigAdapter componet = getComponent(IConfigAdapter.class, name)
                if (componet == null) {
                    steps.error("Config Adapter not found for ${adapterClass?.getSimpleName()} in dependency resolver")
                }
                componet
            }.each { adapter ->
                configClient.addAdapter(adapter)
            }
        }
    }

    String resolveCacheDirectory(String cacheBaseDir) {
        String controllerName = resolveControllerName()
        if (controllerName) {
            Path.of(cacheBaseDir, resolveControllerName(), 'dependencies', splitJobPathInItems().join('/')) as String
        } else {
            Path.of(cacheBaseDir, 'dependencies', splitJobPathInItems().join('/')) as String
        }
    }

    private List<String> splitJobPathInItems() {
        String resolveName = steps.env.PIPELINE_NAME as String ?: steps.env.JOB_NAME as String
        def jobPathChunks = resolveName.tokenize('/')
        return isMultiBranchPipeline() ? jobPathChunks.dropRight(1) : jobPathChunks
    }

    String resolveControllerDomain() {
        String url = getControllerUrlBase()
        URI.create(url).getHost()
    }

    Boolean isMultiBranchPipeline() {
        def isMultiBranch = Boolean.FALSE
        try {
            // In a multibranch pipeline every build runs in a individual job definition, so we need to access to
            // its parent job to check if it's a multibranch pipeline
            isMultiBranch = steps.env?.BRANCH_NAME ? true : false
        } catch (ignored) {
            logger.warn("Error checking if it's a multibranch pipeline: ${ignored}")
        }
        return isMultiBranch
    }


    String resolveControllerName() {
        String url = getControllerUrlBase()
        logger.debug("Controller URL: ${url}")
        URI uri = new URI(url)
        String host = uri.getHost()
        return host
    }

    private String getControllerUrlBase() {
        return steps.env?.CONTROLLER_URL_BASE as String ?: steps.env.JENKINS_URL as String
    }

    private void clearCacheIfConfigured(Boolean forceClearCache, String cacheDir) {
        if (forceClearCache) {
            steps.sh "rm -fr ${cacheDir} || true"
            logger.debug("Cache directory ${cacheDir} has been removed")
        }
    }

    void createCacheFolders(List cacheFolders, String cacheDir) {
        def paths = cacheFolders.collect { Path.of(cacheDir, it).toString() } as List<String>
        if (paths) {
            workspaceTool.createDirectoriesIfNotExist(paths)
        }
    }

    void setEnvironmentWithVarsExpanded(String cacheDirExportEnvVar, Map<String, String> envVars, String cacheDir) {
        steps.env.setProperty(cacheDirExportEnvVar, cacheDir)
        def environment = steps.env.getEnvironment()
        Map<String, String> finalEnvVars = [:]
        envVars.each { k, v -> finalEnvVars.put(k, environment.expand(v as String)) }
        logger.debug("Environment variables to inject: ${finalEnvVars}")
        if (finalEnvVars) {
            injectEnvironmentVariables(finalEnvVars)
        }
    }

    String getEnvironment() {
        String devopsEnvironment = steps.env.DEVOPS_ENVIRONMENT
        if (devopsEnvironment) {
            return devopsEnvironment
        }
        String controllerDomain = resolveControllerDomain()
        def match = controllerDomain =~ regexOcNamespace
        if (match.matches() && match[0].size() > 2) {
            return match[0][2].substring(1).toUpperCase()
        } else {
            logger.warn("No environment found in controller domain")
            return ''
        }
    }

    String getAppNamespace() {
        String controllerDomain = resolveControllerDomain()
        def match = controllerDomain =~ regexOcNamespace
        if (match.matches() && match[0].size() > 4) {
            String appNamespace = match[0][4]
            return appNamespace
        } else {
            logger.warn("No app namespace found in controller domain")
            return ''
        }
    }

    @Override
    Store<? extends PipelineModel> getStore(Class<? extends PipelineModel> modelClass) {
        Store store = storeMap[modelClass] as Store<? extends PipelineModel>
        if (store == null) {
            steps.error("Store not found for ${modelClass?.getSimpleName()} in dependency resolver")
        }
        return store
    }

    @Override
    void addStore(Class<? extends PipelineModel> modelClass, Store<? extends PipelineModel> store) {
        storeMap.put(modelClass, store)
    }

    void initializePipelineDefaultStore(PipelineModel... models) {
        addStore(PipelineDefinition.class, new Store<PipelineDefinition>(
                new PipelineDefinition(
                        settings: new PipelineSettings(
                                devopsEnvironment: '',
                        ),
                        cache: new CacheDescriptor(
                                baseDir: resolveCacheDirectory('/opt/cache'),
                                cacheFolders: [],
                                exportEnvVar: 'CACHE_ROOT_DIR',
                                forceClearCache: false
                        ),
                        toolsManager: new ToolsManagerDescriptor(
                                alternatives: new AlternativesToolsDescriptor(),
                                asdf: new AsdfToolsManagerDescriptor(
                                        defaultDataDir: '/opt/cache/tools/.asdf-data',
                                        defaultToolVersionsFileDir: '/var/lib/jenkins',
                                        forceClearCache: false,
                                        proxySettings: new ProxySettings(
                                                httpsProxy: 'http://proxy-sa.seg-social.es:8080',
                                                httpProxy: 'http://proxy-sa.seg-social.es:8080',
                                                noProxy: 'localhost'
                                        ),
                                        plugins: [:],
                                        tools: [:]
                                )
                        )

                )
        ))
        Store<PipelineDefinition> store = getStore(PipelineDefinition.class)
        store.addMutation(ConfiguredPipelineEvent.class,new PipelineMutation())
        models.each { model ->
            store.dispatch(new ConfiguredPipelineEvent(description: "Initial PipelineDescriptor configuration", payload: model))
        }

    }

    void initializeProjectDescriptorStore(ProjectDescriptorModel... models) {
        addStore(ProjectDescriptor.class, new Store<ProjectDescriptor>(
                new ProjectDescriptor(
                        projectSettings: new ProjectSettings(
                                name: '',
                                description: '',
                                inceptionYear: '',
                                developCenter: '',
                                codeCapp: '',
                                elementoPromocionable: '',
                                version: ''
                        ),
                        sourceRepositories: [],
                        notifications: new Notification(
                                emails: []
                        ),
                        spec: new ProjectSpec(
                                tools: [],
                                artifactsRepositories: [],
                                deployTargets: [],
                                scannerTools: []
                        ),
                        status: new ProjectStatus(
                                artifacts: [],
                        )
                )
        ))
        Store<ProjectDescriptor> store = getStore(ProjectDescriptor.class)
        store.addMutation(ConfiguredProjectDescriptorEvent.class,new ProjectDescriptorMutation())
        models.each { model ->
            store.dispatch(new ConfiguredProjectDescriptorEvent(description: "Initial ProjectDescriptor configuration", payload: model))
        }
    }

    void initializeTelemetryStore(TelemetryModel... models) {
        addStore(ObservabilityHub.class, new Store<ObservabilityHub>(
                new ObservabilityHub(
                        models: models as List<TelemetryModel> ?: []
                )
        ))
        Store<ObservabilityHub> store = getStore(ObservabilityHub.class)
        store.addMutation(TelemetryEvent.class,new ObservabilityHubMutation())

    }

    @NonCPS
    Map modelDataToMap() {
        Map data = [:]
        storeMap.each { k, v ->
            data.put(k.getSimpleName(), v.getState().toMap())
        }
        return data
    }

    void configure() {
        workspaceTool = getComponent(IWorkspaceTool.class)
        Store<PipelineDefinition> store = getStore(PipelineDefinition.class)
        isDebuggable = store.select { PipelineDefinition it -> it.settings.debugMode }
        skipStages = store.select { PipelineDefinition it -> it.settings.skipStages }
        Map environMentVars = store.select { PipelineDefinition it -> it.settings.environmentVars }


        String cacheBaseDir = store.select { PipelineDefinition it -> it.cache.baseDir }
        List cacheFolders = store.select { PipelineDefinition it -> it.cache.cacheFolders }
        String cacheDirExportEnvVar = store.select { PipelineDefinition it -> it.cache.exportEnvVar }

        Boolean forceClearCache = store.select { PipelineDefinition it -> it.cache.forceClearCache }

        String jobCacheDir = resolveCacheDirectory(cacheBaseDir)

        clearCacheIfConfigured(forceClearCache, jobCacheDir)
        createCacheFolders(cacheFolders, jobCacheDir)
        setEnvironmentWithVarsExpanded(cacheDirExportEnvVar, environMentVars, jobCacheDir)
        logger.info "Cache root directory is configured at ${jobCacheDir}"
    }

}
</file>

<file path="src/es/giss/framework/core/Stage.groovy">
package es.giss.framework.core


import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.interfaces.IStage
import es.giss.framework.core.vo.events.StageCompletedEvent
import es.giss.framework.core.vo.events.StageErrorEvent
import es.giss.framework.core.vo.events.StageStarted

abstract class Stage extends Steps implements IStage {


    @Override
    def stage(String name, Closure body) {
        logger.info("Iniciando Stage: $name".toString())
        body?.delegate = steps

        steps.stage(name) {
            logger.info("Iniciando Stage2: $name")
            if (!evaluateIfSkipStage(name)) {

                TelemetryEvent stageStartedEvent = new TelemetryEvent(payload: new StageStarted(stageName: name))
                pipeline.dispatch(stageStartedEvent)
                def result = null
                try {
                    logger.info "Execute Stage with name: '$name'"
                    if(body == null) {
                        logger.warn "Stage '$name' is empty"
                    }
                    result = body()
                } catch (Exception ex) {
                    List<String> lines = handleException(name, ex)
                    steps.currentBuild.result = 'FAILURE'
                    TelemetryEvent stageErrorEvent = new TelemetryEvent(payload:  new StageErrorEvent(stageName: name, message: ex.getMessage(), filteredStackTrace: lines))
                    pipeline.dispatch(stageErrorEvent)
                    logger.executeWhenDebug {

                    }
//                    throw ex
                    steps.error ex.getMessage()
                }
                long currentTimeMillis = System.currentTimeMillis()
                long duration = currentTimeMillis - stageStartedEvent.timeMillis
                TelemetryEvent stageCompletedEvent = new TelemetryEvent(payload: new StageCompletedEvent(stageName: name, duration: duration))
                pipeline.dispatch(stageCompletedEvent)
                logger.info "Finalize Stage: '$name' with duration: ${duration / 1000} seconds"
                return result
            }
        }
    }

    protected boolean evaluateIfSkipStage(String name) {
        Boolean skipped = false
        if (pipeline?.skipStages?.contains(name)) {
            logger.warn "Stage '$name' is marked to be skipped (pipeline.skipStages=${pipeline?.skipStages?.join(',')})"
            skipped = true
        }
        logger.debug "Stage '$name' not skipped"
        return skipped
    }

    List<String> handleException(String name, Exception ex) {
        List lines = ["Error in Stage $name", ex.toString(), ex.getMessage()]
        lines.add('----------------------------------------')
        lines.addAll(filterStackTrace(ex).join("\n"))
        logger.logPrettyError(lines)
        return lines
    }

    List<String> filterStackTrace(Exception ex) {
        return ex.getStackTrace().findAll { stackTraceElement ->
            PipelineContext.DEFAULT_SCAN_PACKAGES.any { pattern -> stackTraceElement.toString().contains(pattern) }
        }
    }

}
</file>

<file path="src/es/giss/framework/core/Steps.groovy">
package es.giss.framework.core

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.interfaces.ISteps

abstract class Steps implements ISteps {

    @Inject
    protected Script steps
    @Inject
    protected ILogger logger
    @Inject
    protected IPipelineContext pipeline

    void ensure(boolean condition, String errorMessage) {
        if (!condition) {
            this.steps.error(errorMessage)
        }
    }

    void ensureNotNull(def object, String errorMessage) {
        this.ensure(object != null, errorMessage)
    }


    void ensureNotEmpty(List list, String errorMessage) {
        this.ensureNotNull(list, errorMessage)
        this.ensure(list.size() > 0, errorMessage)
    }
}
</file>

<file path="test/groovy/es/giss/framework/core/config/ConfigAdapterHelmTool.groovy">
package es.giss.framework.core.config

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.BuildStrategy

@PipelineComponent(name = 'ica1', priority = ConfigurationPriority.LOWEST)
class ConfigAdapterHelmTool implements IConfigAdapter {
    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        BuildStrategy first =  new BuildStrategy(
                id: 'id1',
                toolId: 'defaultHelm',
                buildCommand: 'package',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        BuildStrategy second =  new BuildStrategy(
                id: 'id2',
                toolId: 'defaultHelm',
                buildCommand: 'package ',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        ProjectTool tool = new ProjectTool(
                id: 'defaultHelm',
                name: 'helm',
                version: '3.6.3.low',
                cache: true
        )

        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload: tool))
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload:first))
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload:second))

    }
}
</file>

<file path="test/groovy/es/giss/framework/core/config/ConfigAdapterMaventTool.groovy">
package es.giss.framework.core.config

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.BuildStrategy

@PipelineComponent(name = 'icaJenkinsfile', priority = ConfigurationPriority.LOW)
class ConfigAdapterMaventTool implements IConfigAdapter {

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        BuildStrategy first =  new BuildStrategy(
                id: 'id1',
                toolId: 'defaultMaven',
                buildCommand: 'package',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        BuildStrategy second =  new BuildStrategy(
                id: 'id2',
                toolId: 'defaultMaven',
                buildCommand: 'package ',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1',
                        prop2: 'Valor 2',
                        prop3: 'Valor 3',
                ]
        )
        ProjectTool tool = new ProjectTool(
                id: 'defaultMaven',
                name: 'maven',
                version: '3.6.3.low',
                cache: true
        )
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload: tool))
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload:first))
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload:second))

    }
}
</file>

<file path="test/groovy/es/giss/framework/core/config/ConfigAdapterMaventToolOther.groovy">
package es.giss.framework.core.config

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.project.ProjectTool
import es.giss.framework.core.vo.project.strategies.BuildStrategy

@PipelineComponent(name = 'mavenToolOther', priority = ConfigurationPriority.LOW)
class ConfigAdapterMaventToolOther implements IConfigAdapter {

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        BuildStrategy first =  new BuildStrategy(
                id: 'defaultMaven',
                toolId: 'defaultMaven',
                buildCommand: 'install',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1.1',
                ]
        )
        BuildStrategy second =  new BuildStrategy(
                id: 'id2',
                toolId: 'defaultMaven',
                buildCommand: 'install',
                name: 'default1',
                metadata: [
                        prop1: 'Valor 1.1',
                ]
        )
        ProjectTool tool = new ProjectTool(
                id: 'defaultMaven',
                name: 'maven',
                version: '3.8',
                cache: true
        )
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload: tool))
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload:first))
        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload:second))

    }
}
</file>

<file path="test/groovy/es/giss/framework/core/config/ConfigAdapterToolsManager.groovy">
package es.giss.framework.core.config

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredPipelineEvent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.pipeline.AsdfToolsManagerDescriptor
import es.giss.framework.core.vo.pipeline.ProxySettings

@PipelineComponent(name = 'AsdfToolsConfig', priority = ConfigurationPriority.LOW)
class ConfigAdapterToolsManager implements IConfigAdapter {

    @Override
    void resolveConfiguration(IPipelineContext pipeline) {
        AsdfToolsManagerDescriptor first = new AsdfToolsManagerDescriptor(
                defaultToolVersionsFileDir: '/tmp',
                forceClearCache: true,
                proxySettings: new ProxySettings(
                        httpProxy: 'http://proxy.com',
                        httpsProxy: 'https://proxy.com',
                        noProxy: 'localhost'
                ),
                plugins: [
                        maven: 'https://asdf.com/maven',
                ],
                tools: [
                        maven: '3.6.3',
                        helm  : '3.0'
                ]
        )
        AsdfToolsManagerDescriptor second = new AsdfToolsManagerDescriptor(
                plugins: [
                        helm: 'https://asdf.com/helm',
                        nodejs: 'https://asdf.com/nodejs',
                ],
                tools: [
                       nodejs: '14.17.0',
                ]
        )

        pipeline.dispatch(new ConfiguredPipelineEvent(payload: first))
        pipeline.dispatch(new ConfiguredPipelineEvent(payload: second))

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/config/adapters/ExampleConfigAdapter.groovy">
package fixtures.core.cdi.config.adapters

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent(name = "ExampleConfigAdapter")
class ExampleConfigAdapter implements IConfigAdapter {

    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/config/adapters/TestConfigAdapter.groovy">
package fixtures.core.cdi.config.adapters

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class TestConfigAdapter implements IConfigAdapter {


    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/config/notAnnotated/NotAnnotatedConfigAdapter.groovy">
package fixtures.core.cdi.config.notAnnotated

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext


class NotAnnotatedConfigAdapter implements IConfigAdapter {



    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/config/notQualified/ExampleConfigAdapter.groovy">
package fixtures.core.cdi.config.notQualified

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class ExampleConfigAdapter implements IConfigAdapter {


    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/config/notQualified/TestConfigAdapter.groovy">
package fixtures.core.cdi.config.notQualified

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent
class TestConfigAdapter implements IConfigAdapter {


    @Override
    void resolveConfiguration(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/interfaces/IAnimalCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface IAnimalCD {

    void breath()

    void eat()

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/interfaces/ICarCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface ICarCD extends IVehicleCD {

    void honk()

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/interfaces/ICompanyCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface ICompanyCD {

    void startWork(IHumanCD human)

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/interfaces/IHumanCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface IHumanCD extends IAnimalCD {

    void speak()

    void work()

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/interfaces/IVehicleCD.groovy">
package fixtures.core.cdi.cyclicdependencies.interfaces

interface IVehicleCD {

    void startEngine()

    void move()

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/AnimalCarCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.cyclicdependencies.interfaces.IAnimalCD
import fixtures.core.cdi.cyclicdependencies.interfaces.ICarCD
import es.giss.framework.core.interfaces.IConfigClient


@PipelineComponent
class AnimalCarCD extends Steps implements ICarCD {

    IAnimalCD animal

    AnimalCarCD(IAnimalCD animal) {
        this.animal = animal
    }

    @Override
    void honk() {
        steps.echo('Honking the animal car...')
    }

    @Override
    void startEngine() {
        steps.echo("Starting the animal car's engine...")
    }

    @Override
    void move() {
        steps.echo('Moving the animal car...')
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/CarCompanyCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.cyclicdependencies.interfaces.ICarCD
import fixtures.core.cdi.cyclicdependencies.interfaces.ICompanyCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IVehicleCD


@PipelineComponent(name = 'carCompany')
class CarCompanyCD implements ICompanyCD, IVehicleCD {

    ICarCD car

    CarCompanyCD(ICarCD car) {
        this.car = car
    }

    @Override
    void startWork(IHumanCD human) {
        human.work()
        car.startEngine()
        car.move()
    }

    @Override
    void startEngine() {
        print('Starting engine...')
    }

    @Override
    void move() {
        print('Moving...')
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/DuckCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.cyclicdependencies.interfaces.IAnimalCD


@PipelineComponent(priority = ConfigurationPriority.HIGH)
class DuckCD implements IAnimalCD {

    @Override
    void breath() {
        print('DuckCD breathing...')
    }

    @Override
    void eat() {
        print('DuckCD eating...')
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/GissCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.ICompanyCD


@PipelineComponent(name = 'gissCompany')
class GissCD implements ICompanyCD {

    IHumanCD driver

    GissCD(@Qualifier('trucker') IHumanCD driver) {
        this.driver = driver
    }

    @Override
    void startWork(IHumanCD human) {
        print('Hiring a new employee for GissCD...')
        human.work()
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/TaxiDriverCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IVehicleCD


@PipelineComponent(name = 'cabby')
class TaxiDriverCD implements IHumanCD {

    IVehicleCD vehicle

    TaxiDriverCD(@Qualifier('carCompany') IVehicleCD vehicle) {
        this.vehicle = vehicle
    }

    @Override
    void breath() {
        println 'I am a taxi driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a taxi driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a taxi driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/cyclicdependencies/TruckDriverCD.groovy">
package fixtures.core.cdi.cyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.cyclicdependencies.interfaces.IHumanCD
import fixtures.core.cdi.cyclicdependencies.interfaces.ICompanyCD
import fixtures.core.cdi.cyclicdependencies.interfaces.IVehicleCD


@PipelineComponent(name = 'trucker')
class TruckDriverCD implements IHumanCD {

    IVehicleCD vehicle
    ICompanyCD company

    TruckDriverCD(@Qualifier('carCompany') IVehicleCD vehicle, @Qualifier(value = 'gissCompany') ICompanyCD company) {
        this.vehicle = vehicle
        this.company = company
    }

    @Override
    void breath() {
        println 'I am a truck driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a truck driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a truck driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/interfaces/IBook.groovy">
package fixtures.core.cdi.interfaces

interface IBook {

    int countLines()

}
</file>

<file path="test/groovy/fixtures/core/cdi/interfaces/IDummy.groovy">
package fixtures.core.cdi.interfaces

interface IDummy {

    void doSomething()

}
</file>

<file path="test/groovy/fixtures/core/cdi/interfaces/IGreeting.groovy">
package fixtures.core.cdi.interfaces

interface IGreeting {

    void sayHello(String name)

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/interfaces/IExampleA.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleA {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/interfaces/IExampleB.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleB {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/interfaces/IExampleC.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleC {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/interfaces/IExampleE.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleE {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/interfaces/IExampleH.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleH {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/interfaces/IExampleZ.groovy">
package fixtures.core.cdi.legacy.interfaces

interface IExampleZ {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/ExampleA.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.legacy.interfaces.IExampleE
import fixtures.core.cdi.legacy.interfaces.IExampleZ
import fixtures.core.cdi.legacy.interfaces.IExampleC
import fixtures.core.cdi.legacy.interfaces.IExampleA
import fixtures.core.cdi.legacy.interfaces.IExampleB

@PipelineComponent(name = 'ejemploA')
class ExampleA implements  IExampleZ, IExampleA {

    IExampleB exampleB
    IExampleC exampleC
    IExampleE exampleE

    ExampleA(IExampleB exampleB, @Qualifier(value = 'ejemploC') IExampleC exampleC, @Qualifier(value = 'ejemploE') IExampleE exampleE) {
        this.exampleB = exampleB
        this.exampleC = exampleC
        this.exampleE = exampleE
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/ExampleB.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleC
import fixtures.core.cdi.legacy.interfaces.IExampleB


@PipelineComponent()
class ExampleB implements IExampleB {

    IExampleC exampleD

    ExampleB(IExampleC exampleD) {
        this.exampleD = exampleD
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/ExampleC.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleC


@PipelineComponent(priority = ConfigurationPriority.HIGH, name = 'ejemploC')
class ExampleC implements IExampleC {

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/ExampleD.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigClient
import fixtures.core.cdi.legacy.interfaces.IExampleC
import fixtures.core.cdi.legacy.interfaces.IExampleH

@PipelineComponent
class ExampleD extends Steps implements IExampleC {

    IExampleH exampleH

    ExampleD(IExampleH exampleH) {
        this.exampleH = exampleH
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/ExampleE.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleC
import fixtures.core.cdi.legacy.interfaces.IExampleE


@PipelineComponent(name = 'ejemploE')
class ExampleE implements IExampleE {

    IExampleC exampleD

    ExampleE(IExampleC exampleD) {
        this.exampleD = exampleD
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/legacy/ExampleH.groovy">
package fixtures.core.cdi.legacy

import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.legacy.interfaces.IExampleH

@PipelineComponent
class ExampleH implements IExampleH {

    ExampleH() {
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/interfaces/IAnimal.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface IAnimal {

    void breath()

    void eat()

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/interfaces/ICar.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface ICar extends IVehicle {

    void honk()

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/interfaces/ICompany.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface ICompany {

    void startWork(IHuman human)

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/interfaces/IHuman.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

interface IHuman extends IAnimal {

    void speak()

    void work()

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/interfaces/IVehicle.groovy">
package fixtures.core.cdi.nocyclicdependencies.interfaces

import es.giss.framework.core.interfaces.Configurable

interface IVehicle extends Configurable {

    void startEngine()

    void move()

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/AnimalCar.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.nocyclicdependencies.interfaces.IAnimal
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICar

@PipelineComponent
class AnimalCar extends Steps implements ICar {

    IAnimal animal

    AnimalCar(IAnimal animal) {
        this.animal = animal
    }

    @Override
    void honk() {
        steps.echo('Honking the animal car...')
    }

    @Override
    void startEngine() {
        steps.echo("Starting the animal car's engine...")
    }

    @Override
    void move() {
        steps.echo('Moving the animal car...')
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/CarCompany.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICar
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICompany
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman
import fixtures.core.cdi.nocyclicdependencies.interfaces.IVehicle

@PipelineComponent(name = 'carCompany')
class CarCompany implements ICompany, IVehicle {

    ICar car

    CarCompany(ICar car) {
        this.car = car
    }

    @Override
    void startWork(IHuman human) {
        human.work()
        car.startEngine()
        car.move()
    }

    @Override
    void startEngine() {
        print('Starting engine...')
    }

    @Override
    void move() {
        print('Moving...')
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/Duck.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.nocyclicdependencies.interfaces.IAnimal

@PipelineComponent(priority = ConfigurationPriority.HIGH)
class Duck implements IAnimal {

    @Override
    void breath() {
        print('Duck breathing...')
    }

    @Override
    void eat() {
        print('Duck eating...')
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/Giss.groovy">
package fixtures.core.cdi.nocyclicdependencies


import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.cdi.annotations.Qualifier
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICompany
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman

@PipelineComponent(name = 'gissCompany')
class Giss implements ICompany {

    IHuman driver

    Giss(@Qualifier('trucker') IHuman driver) {
        this.driver = driver
    }

    @Override
    void startWork(IHuman human) {
        print('Hiring a new employee for Giss...')
        human.work()
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/TaxiDriver.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.annotations.Qualifier
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman
import fixtures.core.cdi.nocyclicdependencies.interfaces.IVehicle


@PipelineComponent(name = 'cabby')
class TaxiDriver implements IHuman {

    IVehicle vehicle

    TaxiDriver(@Qualifier('carCompany') IVehicle vehicle) {
        this.vehicle = vehicle
    }

    @Override
    void breath() {
        println 'I am a taxi driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a taxi driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a taxi driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/nocyclicdependencies/TruckDriver.groovy">
package fixtures.core.cdi.nocyclicdependencies

import es.giss.framework.core.cdi.annotations.Qualifier
import es.giss.framework.core.cdi.annotations.PipelineComponent
import fixtures.core.cdi.nocyclicdependencies.interfaces.IHuman
import fixtures.core.cdi.nocyclicdependencies.interfaces.IVehicle
import fixtures.core.cdi.nocyclicdependencies.interfaces.ICompany


@PipelineComponent(name = 'trucker')
class TruckDriver implements IHuman {

    IVehicle vehicle
    ICompany company

    TruckDriver(@Qualifier('carCompany') IVehicle vehicle, @Qualifier(value = 'carCompany') ICompany company) {
        this.vehicle = vehicle
        this.company = company
    }

    @Override
    void breath() {
        println 'I am a truck driver and I am breathing'
    }

    @Override
    void eat() {
        println 'I am a truck driver and I am eating'
    }

    @Override
    void speak() {
        println 'I am a truck driver'
    }

    @Override
    void work() {
        vehicle.startEngine()
        vehicle.move()
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/withdiprovider/BookAnnotated.groovy">
package fixtures.core.cdi.withdiprovider

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.interfaces.IBook

@PipelineComponent
class BookAnnotated extends Steps implements IBook, Configurable {

    @Override
    int countLines() {
        return 30
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/withdiprovider/DummyNotAnnotated.groovy">
package fixtures.core.cdi.withdiprovider


import es.giss.framework.core.Steps
import es.giss.framework.core.interfaces.IConfigClient
import fixtures.core.cdi.interfaces.IDummy

class DummyNotAnnotated extends Steps implements IDummy {

    void doSomething() {
        println 'Doing something'
    }

}
</file>

<file path="test/groovy/fixtures/core/cdi/withdiprovider/GreetingNotAnnotated.groovy">
package fixtures.core.cdi.withdiprovider

import es.giss.framework.core.Steps
import es.giss.framework.core.interfaces.Configurable
import es.giss.framework.core.interfaces.IPipelineContext
import fixtures.core.cdi.interfaces.IDummy
import fixtures.core.cdi.interfaces.IGreeting

class GreetingNotAnnotated extends Steps implements IGreeting, Configurable {

    IDummy dummy

    @Override
    void sayHello(String name) {
        print("Hello, ${name}!")
        dummy.doSomething()
    }

    @Override
    void configure(IPipelineContext context) {

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/AnnotatedClass.groovy">
package fixtures.core.cdi

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.ILogger
import fixtures.core.cdi.interfaces.IGreeting

@PipelineComponent
class AnnotatedClass implements IGreeting {
    @Inject
    ILogger logger

    @Inject
    Script script

    @Override
    void sayHello(String name) {
        print("Hello, ${name}!")

    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/AnnotatedClassWithoutPipelineComponent.groovy">
package fixtures.core.cdi

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.interfaces.ILogger
import fixtures.core.cdi.interfaces.IGreeting

class AnnotatedClassWithoutPipelineComponent implements IGreeting {

    ILogger logger

    @Override
    void sayHello(String name) {
        print("Hello, ${name}!")
    }
}
</file>

<file path="test/groovy/fixtures/core/cdi/AnnotatedClassWithQualifier.groovy">
package fixtures.core.cdi

import es.giss.framework.core.cdi.annotations.Inject
import es.giss.framework.core.cdi.annotations.Qualifier
import es.giss.framework.core.interfaces.ILogger

class AnnotatedClassWithQualifier {
    @Inject
    @Qualifier('special')
    ILogger logger

    @Inject
    Script script
}
</file>

<file path="test/groovy/fixtures/core/TestStage.groovy">
package fixtures.core

import es.giss.framework.core.Stage
import es.giss.framework.core.interfaces.IConfigClient

class TestStage extends Stage {


    def testStage(Closure body) {
        super.stage('TestStage', body)
    }

}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/credentials/Credentials.groovy">
package es.giss.framework.fixtures.mocks.credentials

interface Credentials {
    String getId()
}

class UsernamePasswordCredentials implements Credentials {
    String id
    String username
    String password

    UsernamePasswordCredentials(String id, String username, String password) {
        this.id = id
        this.username = username
        this.password = password
    }

    String getId() {
        return id
    }

    String getUsername() {
        return username
    }

    String getPassword() {
        return password
    }
}

class StringCredentials implements Credentials {
    String id
    String secret

    StringCredentials(String id, String secret) {
        this.id = id
        this.secret = secret
    }

    String getId() {
        return id
    }

    String getSecret() {
        return secret
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/credentials/ProviderCredentialsMock.groovy">
package es.giss.framework.fixtures.mocks.credentials

import java.util.concurrent.ConcurrentHashMap

class ProviderCredentialsMock {
    Map<String, Credentials> credentialsConfig

    ProviderCredentialsMock() {
        this.credentialsConfig = new ConcurrentHashMap()
    }

    Credentials getCredentials(String id) {
        return credentialsConfig[id]
    }

    void setCredentials(Map<String, Credentials> credentialsConfig) {
        credentialsConfig.each { id, credentials ->
            this.credentialsConfig[id] = credentials
        }
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/AssertFailException.groovy">
package es.giss.framework.fixtures.mocks


class AssertFailException extends Exception {
    AssertFailException(String message) {
        super(formatMessage(message))
    }

    static String formatMessage(String message) {
        Integer maxLength = message.split("\n").max { it.length() }.length()
        def padding = "-" * (maxLength - 2)
        return "\n${padding} \n${message} \n${padding}".toString()
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/HttpClientMock.groovy">
package es.giss.framework.fixtures.mocks

import es.giss.framework.core.interfaces.IConfigClient
import es.giss.framework.core.vo.resources.http.FormDataCollection
import es.giss.framework.core.vo.resources.http.HttpResponse
import es.giss.framework.core.vo.resources.http.RequestOptions
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import java.nio.charset.Charset
import java.nio.file.Paths

//class HttpClientMock implements IHttpClient {

//    String resourceBasePath = 'http-responses'
//    ResourceMockRegistry resourceMockRegistry = new ResourceMockRegistry()
//
//    File getResourceFile(String url, String method) {
//        ResourceIdentifier id = ResourceIdentifier.fromUrl(url, method)
//        ResponseMock response = resourceMockRegistry.get(id)
//
//        String pathResource = Paths.get(resourceBasePath, response.path()) as String
//
//        URI uriResource = getClass().getClassLoader().getResource(pathResource)?.toURI()
//        if (uriResource) {
//            return new File(uriResource)
//        }
//        return null
//    }
//
//    void addResponseInCallIteration(String method, String path, String fileName, int iteration) {
//        resourceMockRegistry.addResponseInCallIteration(method, path, fileName, iteration)
//    }
//
//    void changeDefaultResponse(String method, String path, String fileName) {
//        resourceMockRegistry.addResponseInCallIteration(method, path, fileName, 0)
//    }
//
//    @Override
//    void initialize(Map configuration) {
//
//    }
//
//    @Override
//    void parse(Map configuration) {
//    }
//
//    @Override
//    HttpResponse get(String url) {
//        File resourceFile = getResourceFile(url, "get")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    private HttpResponse resolveHttpResponse( File resourceFile) {
//        if(resourceFile !=null && resourceFile.exists()) {
//            def responseContent = new JsonSlurper().parseText(resourceFile.text)
//            String body = JsonOutput.toJson(responseContent.body)
//            if(!body || body == "null") {
//                print("""
//                    Body is empty in Mock file ${resourceFile.absolutePath}
//                    Wrapper response to:
//                        {
//                          "statusCode" : 200,
//                          "headers" : {},
//                          "body" : {}
//                        }
//                """)
//            }
//            return new HttpResponse(statusCode: responseContent.statusCode as Integer, body: body, headers: responseContent.headers)
//        } else {
//            return new HttpResponse(statusCode: 404, body: """{"error": "Not found file in path ${resourceFile.absolutePath}"}""", headers: [:])
//        }
//
//    }
//
//    @Override
//    HttpResponse get(String url, Map options) {
//        return get(url)
//    }
//
//    @Override
//    HttpResponse post(String url, Object payload) {
//        File resourceFile = getResourceFile(url, "post")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    @Override
//    HttpResponse post(String url, Object payload, Map options) {
//        return post(url, payload)
//    }
//
//    @Override
//    HttpResponse post(String url, FormDataCollection formDataCollection, Map options) {
//        return post(url, [:])
//    }
//
//    @Override
//    HttpResponse postFile(String url, String filePath) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse postFile(String url, String filePath, Map options) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse put(String url, Object payload) {
//        File resourceFile = getResourceFile(url, "put")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    @Override
//    HttpResponse put(String url, Object payload, Map options) {
//        return put(url, payload)
//    }
//
//    @Override
//    HttpResponse putFile(String url, String filePath) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse putFile(String url, String filePath, Map options) {
//        throw new UnsupportedOperationException("Not implemented")
//    }
//
//    @Override
//    HttpResponse delete(String url) {
//        File resourceFile = getResourceFile(url, "delete")
//        return resolveHttpResponse(resourceFile)
//
//
//
//    }
//
//    @Override
//    HttpResponse patch(String url, Object payload) {
//        File resourceFile = getResourceFile(url, "patch")
//        return resolveHttpResponse(resourceFile)
//    }
//
//    @Override
//    HttpResponse delete(String url, Map options) {
//        return delete(url)
//    }
//
////    @Override
////    String buildUrl(String baseUrl, String path, Map<String, Serializable> queryParams) {
////        def uriBuilder = new URIBuilder(baseUrl)
////        def pathSegments = decodePathSegments(path.tokenize('/'))
////        def fullPathSegments = uriBuilder.isPathEmpty()
////                ? pathSegments
////                : decodePathSegments(uriBuilder.getPath().tokenize('/')) + pathSegments
////        uriBuilder.setPathSegments(fullPathSegments)
////        queryParams.each { param, value -> uriBuilder.setParameter(param, value as String) }
////        return uriBuilder.build().toString()
////    }
//
//    private static List<String> decodePathSegments(List<String> pathSegments) {
//        pathSegments.collect { URLDecoder.decode(it, Charset.defaultCharset()) }
//    }
//
//    @Override
//    HttpResponse withBasicAuthUsernamePassword(String usernamePasswordCredentialsId, Closure body) {
//        body.delegate = this
//        return body()
//    }
//
//    @Override
//    HttpResponse withBasicAuthString(String stringCredentialsId, Closure body) {
//        body.delegate = this
//        return body()
//    }
//
//    @Override
//    HttpResponse<String> get(URI url) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> get(URI url, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> post(URI url, Map payload) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> post(URI url, Map payload, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> postFile(URI url, String filePath) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> postFile(URI url, String filePath, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> put(URI url, Map payload) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> put(URI url, Map payload, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> putFile(URI url, String filePath) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> putFile(URI url, String filePath, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> delete(URI url) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> patch(URI url, Map payload) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> delete(URI url, RequestOptions options) {
//        return null
//    }
//
//    @Override
//    URI buildUrl(String baseUrl, String path, Map<String, Serializable> queryParams) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> withBasicAuthUsernamePassword(String usernamePasswordCredentialsId, RequestOptions body) {
//        return null
//    }
//
//    @Override
//    HttpResponse<String> withBasicAuthString(String stringCredentialsId, RequestOptions body) {
//        return null
//    }
//
//    @Override
//    Object mapJsonString(String jsonString) {
//        return new JsonSlurper().parseText(jsonString)
//    }
//
//    @Override
//    void configure(IConfigClient config) {
//
//    }
//
//    @Override
//    String execute(String taskName, List<String> options) {
//        return null
//    }
//}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/HttpResponseMock.groovy">
package es.giss.framework.fixtures.mocks

class ResourceCallCounter extends HashMap<ResourceIdentifier, Integer> {

    Integer get(ResourceIdentifier resourceIdentifier) {
        return super.get(resourceIdentifier) ?: 0
    }

    Integer increment(ResourceIdentifier resourceIdentifier) {
        Integer counter = get(resourceIdentifier)
        counter++
        put(resourceIdentifier, counter)
        return counter
    }
}

class ResourceMockRegistry extends HashMap<ResourceIdentifier, ResponseMock>  {

    ResourceCallCounter resourceCallCounter = new ResourceCallCounter()

    ResponseMock get(ResourceIdentifier resourceIdentifier) {
        ResponseMock responseMock = super.get(resourceIdentifier)
        if( responseMock?.isIteration(resourceCallCounter)) {
            resourceCallCounter.increment(resourceIdentifier)
            return responseMock
        } else {
            resourceCallCounter.increment(resourceIdentifier)
            return new ResponseMock(id: resourceIdentifier, iteration: 0, fileName: "${resourceIdentifier.method}-${resourceIdentifier.resourceName}")
        }
    }

    void addResponseInCallIteration(String method, String path, String fileName, int iteration) {
        ResourceIdentifier id = ResourceIdentifier.fromPath(path, method)
        ResponseMock responseMock = new ResponseMock(id: id, iteration: iteration, fileName: fileName)
        put(id, responseMock)
    }

}


class ResourceIdentifier {
    final String path
    final String method

    ResourceIdentifier(String path, String method) {
        this.path = path
        this.method = method
    }

    String getResourceName() {
        int lastSlashIndex = path.lastIndexOf("/")
        return path.substring(lastSlashIndex + 1)
    }

    static ResourceIdentifier fromUrl(String url, String method) {
        String urlWithoutDomain = url.replaceFirst("https?://[^/]+", "")
        String urlPath = urlWithoutDomain.replaceFirst("\\?.*", "")
        return new ResourceIdentifier(urlPath, method)
    }

    static ResourceIdentifier fromPath(String path, String method) {
        return new ResourceIdentifier(path, method)
    }

    @Override
    String toString() {
        return "ResourceIdentifier [path=${path}, method=${method}]"
    }


    @Override
    int hashCode() {
        return Objects.hash(path, method);
    }

    @Override
    boolean equals(Object obj) {
        if (!(obj instanceof ResourceIdentifier))
            return false
        ResourceIdentifier other = (ResourceIdentifier) obj
        return Objects.equals(path, other.path) && Objects.equals(method, other.method)
    }
}


class ResponseMock {
    ResourceIdentifier id
    int iteration
    String fileName

    Boolean isIteration(ResourceCallCounter resourceCallCounter) {
        return iteration == resourceCallCounter.get(id)
    }

    String path() {
        String fileNameWithExtension = this.fileName.endsWith(".json") ? this.fileName : "${this.fileName}.json"
        return "${id.path}/${fileNameWithExtension}".toString()
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/MethodInvocation.groovy">
package es.giss.framework.fixtures.mocks


abstract class MethodInvocation<T> {

    abstract Boolean verifyArgs(T expectedArgs)



    Boolean checkArgsAreEqual(expectedArg, actualArg) {
        def expected = expectedArg
        def actual = actualArg instanceof GString || actualArg instanceof String? actualArg.toString() : actualArg
        if (expectedArg instanceof Map) {
            expected = expectedArg.value
        }
        if(expectedArg instanceof Closure<Boolean>) {
            return expectedArg.call(actual)
        }
        return expected == actual
    }

    static void ensure(boolean condition, String message) {
        if (!condition) {
            throw new AssertFailException(message)
        }
    }

    @Override
    def String toString() {
        return "MethodInvocation{${this.getClass().getSimpleName()}"
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/MethodInvocationRecorder.groovy">
package es.giss.framework.fixtures.mocks

class MethodInvocationRecorder {

    Map<String, List<MethodInvocation>> methodCalls = [:]

    Boolean containsKey(String methodName) {
        return methodCalls.containsKey(methodName)
    }

    def methodMissing(String methodName, args) {
        // Convertir args a una lista si no lo es
        def argumentsResolved = getArgs(args)

        MethodInvocation expectedMethodInvocation = argumentsResolved instanceof Map
                ? new NamedArgsMethodInvocation(methodName, argumentsResolved, null)
                : new PositionalArgsMethodInvocation(methodName, argumentsResolved, null)

        return new Object() {
            def getAt(int pos) {
                def methodMock = verifyInvocation(methodName, pos)
                return methodMock.equals(expectedMethodInvocation)
            }
        }

    }

    def getArgs(args) {
        def argsList= args.toList()
        if (argsList[0] instanceof Map) {
            return argsList[0]
        }
        return argsList
    }

    private MethodInvocation verifyInvocation(String methodName, int pos = 0) {
        def calls = methodCalls[methodName] ?: []
        def result = calls.getAt(pos)
        MethodInvocation.ensure(result != null,
                "Step ${methodName} was not called ${pos} times")
        return result

    }

    void createList(String methodName) {
        methodCalls[methodName] = []
    }

    void addMock(String methodName, MethodInvocation methodInvocation) {
        List<MethodInvocation> invocations = methodCalls[methodName]
        invocations.add(methodInvocation)
    }

    def PositionalArgsMethodInvocation get(String methodName) {
        return methodCalls[methodName]
    }

    @Override
    public String toString() {
        return "MethodInvocationRecorder{" +
                "methodCalls=" + methodCalls +
                '}';
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/NamedArgsMethodInvocation.groovy">
package es.giss.framework.fixtures.mocks

import org.spockframework.lang.SpreadWildcard

class NamedArgsMethodInvocation extends MethodInvocation<Map<String, Object>> {
    Map<String, Object> namedArgs
    private String methodName
    Object output

    NamedArgsMethodInvocation(String methodName, Map<String, Object> args, Object output) {
        this.methodName = methodName
        this.output = output
        this.namedArgs = args
    }

    @Override
    Boolean verifyArgs(Map<String, Object> expectedNamedArgs) {
        ensure(expectedNamedArgs.size() <= namedArgs.size(),
        """
        Number of arguments are not the same, Actual: ${namedArgs.size()}, Expected: ${expectedNamedArgs.size()}
          Actual: ${namedArgs}
          Expected: ${expectedNamedArgs}
        """)

        expectedNamedArgs.each { String key, value ->
            // Ignora el argumento si es '_'
            if (!(containsSpreadWildcard(value))) {
                def actualValue = namedArgs[key]
                ensure(checkArgsAreEqual(value ,actualValue),
                        """Argument with name '${key}' is not the expected,
                                    Expected: >${value}<
                                    Actual:   >${actualValue}<
                    """)
            }
        }
        return this
    }

    @Override
    boolean equals(Object o) {
        ensure(o instanceof NamedArgsMethodInvocation,
                """You are passing positional arguments and you are expected to use named arguments.
                    Redefine method invocation 'steps.${this.methodName}' with the correct arguments.
                    For example:
                    steps.${this.methodName}(${this.namedArgs.collect { key, value -> "${key} : expectedValue" }.join(", ") })
                  """)
        
        NamedArgsMethodInvocation that = (NamedArgsMethodInvocation) o
        return Objects.equals(methodName, that.methodName) &&  verifyArgs(that.namedArgs)
    }


    Boolean containsSpreadWildcard(argument) {
        if (argument instanceof Map.Entry) {
            return argument.value instanceof SpreadWildcard
        }
        if(argument instanceof List) {
            return argument.any { it instanceof SpreadWildcard }
        }
        return argument instanceof SpreadWildcard
    }

}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/PositionalArgsMethodInvocation.groovy">
package es.giss.framework.fixtures.mocks

import org.spockframework.lang.SpreadWildcard
import org.spockframework.lang.Wildcard

class PositionalArgsMethodInvocation extends MethodInvocation<List> {
    List<Object> args
    private String methodName
    Object output

    PositionalArgsMethodInvocation(String methodName, List<Object> args, Object output) {
        this.methodName = methodName
        this.output = output
        this.args = args
    }


    Boolean rightShift(Closure body) {
        body.delegate = this
        body() == this.output
    }


    @Override
    Boolean verifyArgs(List list) {
        ensure(list.size() <= args.size(),
                """
        Number of arguments are not the same, Actual: ${args.size()}, Expected: ${list.size()}
          Actual: ${args}
          Expected: ${list}                
        """)

        for (int i = 0; i < list.size(); i++) {
            // Ignora el argumento si es '_'
            if (!(containsSpreadWildcard(list[i]))) {
                ensure(checkArgsAreEqual(list[i], args[i]),
                        """Argument at index ${i} is not the expected, 
                           Expected: >${list[i]}< 
                             Actual: >${args[i]}<
                        """)
            }
        }
        return this
    }

    @Override
    boolean equals(Object o) {
        if (!(o instanceof PositionalArgsMethodInvocation)) return false

        PositionalArgsMethodInvocation that = (PositionalArgsMethodInvocation) o
        return Objects.equals(methodName, that.methodName) &&  verifyArgs(that.args)
    }



    Boolean containsSpreadWildcard(argument) {
        if (argument instanceof Wildcard) {
            return argument.any { it instanceof SpreadWildcard }
        }
        return false
    }

    @Override
    String toString() {
        return "MethodMock{methodName='${methodName}', args=${args}, output=${output}}"
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/StepsMock.groovy">
package es.giss.framework.fixtures.mocks


import groovy.io.FileType
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import org.yaml.snakeyaml.Yaml

import java.nio.file.FileSystems
import java.nio.file.Path
import java.nio.file.Paths
import java.util.concurrent.ConcurrentHashMap

//@CompileStatic
class StepsMock extends Script {

    Map<String, Object> dynamicProps
    Map<String, Integer> invocationCounts
    private MethodInvocationRecorder recorder = new MethodInvocationRecorder()
//    ProviderCredentialsMock credentialsProvider

    MethodInvocationRecorder validate() {
        return recorder
    }

    StepsMock() {
        dynamicProps = [
                env                  : [
                        JENKINS_URL: 'https://jenkins-gint-ps-dvo.apps.giss.int.portal.ss',
                        JOB_NAME   : 'fdar/ot_fdarback_main/develop',
                        WORKSPACE  : '.',
                ],
                params               : [:],
                currentBuild         : [:],
                timeout              : this.&defaultMethodClosure,
                configFileProvider   : this.&defaultMethodClosure,
                ansiColor            : this.&defaultMethodClosure,
                container            : this.&defaultMethodClosure,
                dir                  : this.&dirMock,
                readYaml             : this.&readYamlMock,
                readJSON             : this.&readJsonMock,
                readFile             : this.&readFileMock,
                readProperties       : this.&readPropertiesMock,
                fileExists           : this.&fileExistsMock,
                withCredentials      : this.&defaultMethodClosure,
                withEnv              : this.&defaultMethodClosure,
                withSonarQubeEnv     : this.&defaultMethodClosure,
                node                 : this.&defaultMethodClosure,
                stage                : this.&defaultMethodClosure,
                retry                : this.&retryMock,
                libraryResource      : this.&libraryResourceMock,
                archiveArtifacts     : {},
                configFile           : {},
                waitUntil            : this.&waitUntilMock,
                writeFile            : {},
                writeJSON            : this.&writeJSONMock,
                writeYaml            : this.&writeYAMLMock,
                writeMavenPom        : {},
                usernamePassword     : this.&usernamePasswordMock,
                usernameColonPassword: this.&usernameColonPasswordMock,
                string               : this.&tokenCredentialMock,
                token                : this.&tokenCredentialMock,
                unstash              : {},
                publishHTML          : {},
                parallel             : this.&parallelMock,
                emailext             : {},
                sleep                : {},
                string               : {},
                file                 : {},
                sh                   : { args -> if (args?.returnStatus) { return 0 } else { return '' } },
                echo                 : { System.out.println(it.toString()) }, // groovylint-disable-line SystemOutPrint
                error                : { String message -> throw new TestException(message) },
                catchError           : this.&defaultMethodClosure,

        ]

        invocationCounts = new ConcurrentHashMap()
//        credentialsProvider = new ProviderCredentialsMock()

    }

    def usernamePasswordMock(Map args) {
        String usernameVariable = args.usernameVariable
        String passwordVariable = args.passwordVariable
        this.env[usernameVariable] = 'usernameMock'
        this.env[passwordVariable] = 'passwordMock'
    }

    def usernameColonPasswordMock(Map args) {
        String variable = args.variable
        this.env[variable] = 'userMock:passwordMock'
    }

    def tokenCredentialMock(Map args) {
        String variable = args.variable
        this.env[variable] = 'secretToken'
    }

    def withCredentialsMock(Map args, Closure body) {
        def credentialsId = args.credentialsId
        def credentials = credentialsProvider.getCredentials(credentialsId)
        dynamicProps.env['CREDENTIALS'] = credentials
        body.delegate = this
        return body()
    }


    def defaultMethodClosure(ignored, Closure body) {
        body.delegate = this
        return body()
    }

    def catchErrorMock(ignored, messageIgnored, Closure body) {
        return defaultMethodClosure(ignored, body)
    }

    def timeoutMock(_, closure) {
        closure.delegate = this
        return closure()
    }


    /**
     * Simulate a real invocation for the jenkins retry step
     * @param times number of times to retry
     * @param body closure to be executed
     * @return the output of the closure
     * @throws TestException if the closure fails after the number of retries
     */
    def retryMock(int times, body) {
        def retries = 0
        while (retries < times) {
            try {
                return body()
            } catch (Exception e) {
                retries++
            }
        }
        throw new TestException("Retry failed after ${times} attempts")
    }

    /**
     * Simulate a real invocation for the jenkins libraryResource step
     * @param args jenkins libraryResource step arguments
     * @return the content of the file (or script) in the library
     */
    String libraryResourceMock(args) {
        assert (args instanceof Map && args.resource != null) || args instanceof String
        return '#!/bin/bash\necho "mocked script content"'
    }

    def dirMock(String path, Closure block) {
        def currentPwd = dynamicProps.env?.PWD
        def currentDir = currentPwd ?: '.'
        dynamicProps.env['PWD'] = Paths.get(currentDir).toAbsolutePath().resolve(path).toString()
        def result = block()
        if (currentPwd) {
            dynamicProps.env.PWD = currentPwd
        } else {
            (dynamicProps.env as Map).remove('PWD')
        }
        return result
    }

    def parallelMock(Map args) {
        args.findAll { k, v -> k != 'failFast' }.each { k, v -> v() }
    }

    def readYamlMock(Map args, baseDir = '') {
        if (args?.file?.contains('build')) {
            args.file = args.file.replace('build/', '')
        }
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        if (content?.contains('---')) {
            def result = new Yaml().loadAll(content).toList()
            result.size() == 1 ? result[0] : result
        } else {
            return new Yaml().load(content)
        }
    }

    def readJsonMock(Map args, baseDir = '') {
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        return new JsonSlurper().parseText(content ?: '')
    }

    def readPropertiesMock(Map args, baseDir = '') {
        String content = args.text ?: this.getResourceContent(Paths.get(baseDir as String, args.file as String) as String)
        Properties properties = new Properties()
        if (content == null) {
            throw new TestException("File not found in resources: ${args.file} for Mock readPropertiesMock")
        }
        properties.load(new StringReader(content))
        Map<String, String> map = new HashMap<String, String>();
        properties.each { k, v -> map[k] = v }
        return map
    }

    def findFilesMock(Map args, baseDir = 'topics') {
        Path parentPath = Paths.get(getClass().getClassLoader().getResource(baseDir as String).toURI()).resolve('../').normalize()

        List<File> files = []
        parentPath.toFile().eachFileRecurse(FileType.FILES) {
            def relativePath = parentPath.relativize(it.toPath())
            if (matchesGlobExpression(args.glob as String, relativePath)) {
                files.add(relativePath.toFile())
            }
        }
        return files
    }

    private Boolean matchesGlobExpression(String globPattern, Path path) {
        return FileSystems
                .getDefault()
                .getPathMatcher("glob:${globPattern}")
                .matches(path)
    }

    def readFileMock(Map args, String baseDir = '') {
        return this.getResourceContent(Paths.get(baseDir, args.file as String) as String)
    }

    def writeJSONMock(Map args) {
        if (args.returnText) {
            JsonBuilder builder = new JsonBuilder()
            builder(args.json)
            builder.toString()
        }
    }

    def waitUntilMock(Closure body) {
        for (int i = 0; i < 20; i++) {
            if (body.call()) {
                return
            }
        }
        throw new TestException('Wait until did not return true after 20 retries')
    }

    def writeYAMLMock(Map args) {
        if (args.returnText) {
            return new Yaml().load(args.data as String ?: args.datas as String)
        }
    }

    def fileExistsMock(Map args, String baseDir = '') {
        if (args?.file?.contains('build')) {
            args.file = args.file.replace('build/', '')
        }
        Path path = Paths.get(baseDir, args.file as String)
        println("Resolve fileExistsMock in path: ${path.toAbsolutePath()}")
        return getClass().getClassLoader().getResource(path.toString()) != null ? Boolean.TRUE : Boolean.FALSE
    }


    Object sleep(long arg) {
        // To simulate steps.sleep(time) in a pipeline
        methodMissing('sleep', [arg])
    }

    def getAllDynamicProps() {
        return dynamicProps
    }

    @Override
    def getProperty(String propName) {
        return dynamicProps[propName]
    }

    @Override
    void setProperty(String propName, val) {
        dynamicProps[propName] = val
    }

    @Override
    Object run() {
        return null
    }

    def methodMissing(String methodName, args) {
        // Incrementa el contador de invocaciones del mtodo
        incrementInvocationCount(methodName)

        def prop = dynamicProps[methodName]
        if (prop instanceof Closure) {
            def result = prop(*args)
            recordMethodInvocation(methodName, args, result)
            return result
        }
        throw new TestException("\u001B[1;31m************ Method Missing with name $methodName and args $args **************\u001B[0m")
    }

    private void incrementInvocationCount(String methodName) {
        // Si el mtodo no ha sido invocado antes, inicializa su contador a 0
        if (!invocationCounts.containsKey(methodName)) {
            invocationCounts[methodName] = 0
        }
        // Incrementa el contador de invocaciones del mtodo
        invocationCounts[methodName] = invocationCounts[methodName] + 1
    }

    private void recordMethodInvocation(String methodName, args, result) {
        // Si el mtodo no ha sido registrado antes, crea una nueva lista para l
        if (!this.recorder.containsKey(methodName)) {
            this.recorder.createList(methodName)
        }
        def argumentsResolved = recorder.getArgs(args)

        // Crea una nueva instancia de MethodInvocation dependiendo del tipo de argumentos
        MethodInvocation methodInvocation = argumentsResolved instanceof Map
                ? new NamedArgsMethodInvocation(methodName, argumentsResolved, result)
                : new PositionalArgsMethodInvocation(methodName, argumentsResolved, result)
        // Registra la invocacin del mtodo
        this.recorder.addMock(methodName, methodInvocation)
    }

    String getResourceContent(String file) {
        return getClass().getClassLoader().getResource(file.replaceAll('\\\\', '/'))?.text
    }


}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/TestContext.groovy">
package es.giss.framework.fixtures.mocks

import es.giss.framework.core.config.ConfigClient
import es.giss.framework.core.PipelineContext
import es.giss.framework.core.cdi.dependencies.DependencyResolver
import es.giss.framework.core.events.ConfiguredPipelineEvent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.events.TelemetryEvent
import es.giss.framework.core.events.interfaces.PipelineModel
import es.giss.framework.core.events.interfaces.ProjectDescriptorModel
import es.giss.framework.core.events.interfaces.TelemetryModel
import es.giss.framework.core.interfaces.IConfigClient
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.Logger
import es.giss.framework.core.utils.ExpressionEvaluator
import es.giss.framework.core.vo.project.ProjectDescriptor
import spock.lang.Specification

class TestContext  extends Specification {

    protected StepsMock steps
    protected ILogger loggerSpy
    protected IConfigClient configClient
    protected DependencyResolver resolver
    protected IPipelineContext pipeline
    protected ExpressionEvaluator evaluator


    def setup() {
        steps = new StepsMock()
        loggerSpy = Spy(new Logger(steps))

        resolver = new DependencyResolver()
        pipeline = new PipelineContext(steps)
        pipeline.logger = loggerSpy
        resolver.registerCoreComponent(Script.class, steps)
        resolver.registerCoreComponent(ILogger.class, loggerSpy)
        resolver.registerCoreComponent(IPipelineContext.class, pipeline)


    }

    protected IPipelineContext configureTest(List<PipelineModel> pipelineModels = []) {
        this.evaluator = new ExpressionEvaluator()
        configClient = new ConfigClient()
        pipeline.initializePipelineDefaultStore()
        pipeline.initializeProjectDescriptorStore()
        pipeline.initializeTelemetryStore()
        if(pipelineModels) {
            pipelineModels.each { model ->
                switch (model) {
                    case ProjectDescriptorModel:
                        pipeline.dispatch(new ConfiguredProjectDescriptorEvent(payload: model))
                        break
                   case TelemetryModel:
                        pipeline.dispatch(new TelemetryEvent(payload: model))
                        break
                    case PipelineModel:
                        pipeline.dispatch(new ConfiguredPipelineEvent(payload: model))
                }
            }
        }
        injectFields(configClient)
        return pipeline
    }

    def <T> T injectFields(T instance) {
        resolver.injectDependenciesByFields(instance)
        return instance
    }
}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/mocks/TestException.groovy">
package es.giss.framework.fixtures.mocks

class TestException extends RuntimeException {

    TestException(String message) {
        super(message)
    }

}
</file>

<file path="testFixtures/groovy/es/giss/framework/fixtures/support/MapUtils.groovy">
package es.giss.framework.fixtures.support

class MapUtils {

    static Map deleteKey(Map config, String keyPath) {
        def path = keyPath.tokenize('.')
        def childKey = path.last()
        path.dropRight(1).inject(config) { acum, p -> acum[p] }.remove(childKey)
        return config
    }

    static Map deleteKeys(Map config, String... keyPaths) {
        def result = config
        keyPaths.each { result = deleteKey(result, it) }
        return result
    }

    static Map overrideKeyWith(Map config, String keyPath, Object value) {
        def path = keyPath.tokenize('.')
        def childKey = path.last()
        path.dropRight(1).inject(config) { acum, p -> acum[p] }.put(childKey, value)
        return config
    }

    static Boolean containsSubMap(Map map, Map subMap) {
        return map.subMap(subMap.keySet()) == subMap
    }

}
</file>

<file path="vars/cdi.groovy">
import static es.giss.framework.core.cdi.ContextSinglenton.createPipelineContext

void initialize(Script steps) {
    createPipelineContext(steps)

}
</file>

<file path="vars/config.groovy">
import es.giss.framework.core.interfaces.IConfigClient
import es.giss.framework.core.vo.project.ProjectDescriptor

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

void load(Map<String, Object> config) {
    IConfigClient configClient = getContext().getComponent(IConfigClient.class)
    configClient.configureEntities()
}

void refresh() {
    IConfigClient configClient = getContext().getComponent(IConfigClient.class)
    configClient.refresh()
}
</file>

<file path="vars/gitlab.groovy">
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.tools.restClients.GitLabTool
import es.giss.framework.core.tools.restClients.interfaces.IGitLabTool

import static es.giss.framework.core.cdi.ContextSinglenton.getContext
import static es.giss.framework.core.interfaces.ILogger.*


IGitLabTool gitLab(steps) {
    ILogger logger = getContext().getComponent(ILogger.class)
    return new GitLabTool(steps, logger)
}


def getRawFile(steps) {
    def gitLabTool = gitLab(steps)
//    https://gitlab.pro.portal.ss/dvo/helm-charts/dvo_helm-charts_ms-java
    def result = gitLabTool.baseUrl('https://gitlab.pro.portal.ss')
            .credentialsId('defaultGitlabToken')
            .ignoreSsl(true)
            .getRawFile('dvo/helm-charts/dvo_helm-charts_ms-java', 'master', 'Chart.yaml')

    echo "RawFile: ${result}"

}

def getProjectId(steps) {
    def gitLabTool = gitLab(steps)
//    https://gitlab.pro.portal.ss/dvo/helm-charts/dvo_helm-charts_ms-java
    def result = gitLabTool.baseUrl('https://gitlab.pro.portal.ss')
            .credentialsId('defaultGitlabToken')
            .ignoreSsl(true)
            .getProjectId('dvo/helm-charts/dvo_helm-charts_ms-java')

    echo "Project ID: ${result}"

}
</file>

<file path="vars/gitTool.groovy">
import es.giss.framework.core.tools.interfaces.IGitTool

import static es.giss.framework.core.cdi.ContextSinglenton.getContext

void cloneInAgent() {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    gitTool.cloneInAgent()
}

void cloneInAgent(String url,
           String reference,
           String credentialsId = '',
           String cloneDir = '.',
           Boolean shallowClone = false) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    gitTool.cloneInAgent(url, reference, credentialsId, cloneDir, shallowClone)
}

Boolean createTag(String tag) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.createTag(tag)
}

Boolean tagExists(String tag) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.tagExists(tag)
}

Boolean branchExists(String branchName) {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.branchExists(branchName)
}

Boolean currentHeadIsTagged() {
    IGitTool gitTool = getContext().getComponent(IGitTool.class)
    return gitTool.currentHeadIsTagged()
}
</file>

<file path="vars/jsonPath.groovy">
def getValue(Map<String, Object> data, String jsonPath) {
    def parts = jsonPath.split('\\.')
    def current = data

    for (int i = 0; i < parts.size(); i++) {
        def part = parts[i]

        if (part.startsWith('[') && part.endsWith(']')) {
            def condition = part[1..-2]
            if (condition.startsWith('?')) {
                def lambda = condition[2..-2]
                def result = current.findAll { item ->
                    def itemValue = getValue(item, lambda)
                    return itemValue
                }
                current = result
            } else {
                def index = condition.toInteger()
                current = current[index]
            }
        } else if (part.startsWith('\'') && part.endsWith('\'')) {
            def key = part[1..-2]
            current = current[key]
        } else {
            current = current[part]
        }

        if (current == null) {
            return null
        }
    }

    return current
}


Map<String, Object> bookstoreMap = [
        bookstore: [
                [
                        book: [
                                category: 'cooking',
                                title: [
                                        lang: 'en',
                                        value: 'Everyday Italian'
                                ],
                                author: 'Giada De Laurentiis',
                                year: 2005,
                                price: 30.00
                        ]
                ],
                [
                        book: [
                                category: 'children',
                                title: [
                                        lang: 'en',
                                        value: 'Harry Potter'
                                ],
                                author: 'J K. Rowling',
                                year: 2005,
                                price: 29.99
                        ]
                ],
                [
                        book: [
                                category: 'web',
                                title: [
                                        lang: 'en',
                                        value: 'XQuery Kick Start'
                                ],
                                author: [
                                        'James McGovern',
                                        'Per Bothner',
                                        'Kurt Cagle',
                                        'James Linn',
                                        'Vaidyanathan Nagarajan'
                                ],
                                year: 2003,
                                price: 49.99
                        ]
                ],
                [
                        book: [
                                category: 'web',
                                title: [
                                        lang: 'en',
                                        value: 'Learning XML'
                                ],
                                author: 'Erik T. Ray',
                                year: 2003,
                                price: 39.95
                        ]
                ]
        ]
]
// Ejemplos de uso
println getValue(bookstoreMap, 'bookstore[?(@.book.category == \'web\')].book.title.value')
// [XQuery Kick Start, Learning XML]

println getValue(bookstoreMap, 'bookstore[?(@.book.price < 40)].book.author')
// [Giada De Laurentiis, J K. Rowling, Erik T. Ray]

println getValue(bookstoreMap, 'bookstore[?(@.book.year >= 2005)].book.title.value')
// [Everyday Italian, Harry Potter]

println getValue(bookstoreMap, 'bookstore[?(@.book.author.size() > 1)].book.category')
// [web]
</file>

<file path="vars/loggerTool.groovy">
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.logger.LogLevel

import static es.giss.framework.core.cdi.ContextSinglenton.getContext


void logLevel(String level) {
    ILogger logger = getContext().getComponent(ILogger.class)
    LogLevel logLevel = LogLevel.valueOf(level)
    logger.setLogLevel(logLevel)
}

void debug(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.debug(message)
}

void info(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.info(message)
}

void warn(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.warn(message)
}

void error(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.error(message)
}

void fatal(String message) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.fatal(message)
}

void executeWhenDebug(Closure body) {
    ILogger logger = getContext().getComponent(ILogger.class)
    logger.executeWhenDebug(body)
}

def <T> void printPrettyLog(String level, T obj) {
    ILogger logger = getContext().getComponent(ILogger.class)
    LogLevel logLevel = LogLevel.valueOf(level)
    logger.printPrettyLog(logLevel, obj)
}
</file>

<file path="vars/restClient.groovy">
import es.giss.framework.core.tools.ProxyHost
import es.giss.framework.core.tools.restClients.RestClient
import es.giss.framework.core.tools.restClients.interfaces.IRestClient

IRestClient create(Script steps) {
    return new RestClient(steps)

}


void pruebaConGet() {
    def restClient = create(this)
    ProxyHost proxy = new ProxyHost(
            protocol: 'http',
            host: 'proxy-sa.seg-social.es',
            port: 8080,
            proxyUser: '99guaxxx',
            proxyPassword: 'xxxxx'

    )
    def response = restClient.url('https://api.github.com/users/rubentxu')
            .debugMode(false)
            .get()
            .header('Content-Type', 'application/json')
            .proxy(proxy)
            .execute()
    echo "Response status code: ${response.statusCode} \n Response body: ${response.body}"
    echo "Response body parsed: ${response.parseJsonBody()}"
}

void pruebaConGet2() {
    def restClient = create(this)
    def response = restClient.url('http://backend-gpro-co-dvo.apps.giss.pro.portal.ss/jobs/getDevopsConfigByJenkinsType?environment=INT&jenkinsType=ALL')
            .debugMode(true)
            .get()
            .header('Content-Type', 'application/json')
//            .proxy('http://proxy-sa.seg-social.es', 8080)
            .execute()
    echo "Response status code: ${response.statusCode} \n Response body: ${response.body}"
}

void pruebaConCredenciales() {
    def restClient = create(this)
    def response = restClient.url('https://jsonplaceholder.typicode.com/posts')
            .get()
            .header('Content-Type', 'application/json')
            .proxy('http://proxy-sa.seg-social.es', 8080)
            .withAuthBasic('my-credentials-id', 'UsernamePasswordMultiBinding')
            .execute()
    echo response.toString()
}

void pruebaConPost() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts')
    restClient.post()
    restClient.header('Content-Type', 'application/json')
    restClient.body('{"title": "foo", "body": "bar", "userId": 1}')
    def response = restClient.execute()
    echo response.toString()
}

void pruebaConPut() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.put()
    restClient.header('Content-Type', 'application/json')
    restClient.body('{"id": 1, "title": "foo", "body": "bar", "userId": 1}')
    def response = restClient.execute()
    echo response.toString()
}

void pruebaConDelete() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.delete()
    def response = restClient.execute()
    echo response.toString()
}

void pruebaConDebugMode() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.get()
    restClient.debugMode(true)
    def response = restClient.execute()
    echo response.toString()
}


void pruebaConBody() {
    def restClient = create(this)
    restClient.url('https://jsonplaceholder.typicode.com/posts/1')
    restClient.get()
    restClient.body('{"id": 1, "title": "foo", "body": "bar", "userId": 1}')
    def response = restClient.execute()
    echo response.toString()
}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/ArtifactsRepositoryDefaultConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.configuration.config.vo.IdentifiersEnum
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.project.ArtifactsRepository
import es.giss.framework.core.vo.project.ArtifactsRepositoryType
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.project.ProjectSettings
import es.giss.framework.core.vo.release.ReleaseDescriptor
import es.giss.framework.core.vo.release.SemanticVersion

@PipelineComponent(name = 'ArtifactsRepositoryDefaultConfigAdapter', priority = ConfigurationPriority.LOW)
class ArtifactsRepositoryDefaultConfigAdapter extends Steps implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return "ReleaseConfigAdapter"
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        Store<ProjectDescriptor> projectStore = context.getStore(ProjectDescriptor)
        Store<PipelineDefinition> pipelineStore = context.getStore(PipelineDefinition)
        Store<ReleaseDescriptor> releaseStore = context.getStore(ReleaseDescriptor)

        SemanticVersion version = releaseStore.select { ReleaseDescriptor descriptor -> descriptor.spec.version }
        ProjectSettings projectSettings = getProjectSettings(projectStore)
        String nexusUrl = getPipelineEnvVar(pipelineStore, "NEXUS_URL")
        String credentialsId = getPipelineEnvVar(pipelineStore, "NEXUS_CREDENTIALSID")

        logger.debug('ArtifactsRepositoryDefaultConfigAdapter.configureVersionObserver', "Configurando repositorio GISS DEPLOY")
        ArtifactsRepository updateMetadata = new ArtifactsRepository(
                id: IdentifiersEnum.GISS_DEPLOY_REPOSITORY.toString(),
                name: IdentifiersEnum.GISS_DEPLOY_REPOSITORY.toString(),
                url: nexusUrl,
                type: ArtifactsRepositoryType.DEPLOY,
                credentialsId: credentialsId,
                metadata: [
                        pathRepoDeploy: "${projectSettings.codeCapp}/${projectSettings.promotableItem}/${projectSettings.suffix}/${version.featureVersion}/${version.nonStatusVersion}".toString()
                ],

        )
        context.updateDataModels(updateMetadata)
        logger.printPrettyLog(LogLevel.DEBUG, 'ArtifactsRepositoryDefaultConfigAdapter',
                pipeline.getStore(ProjectDescriptor).select { ProjectDescriptor descriptor -> descriptor.spec.artifactsRepositories.collect { it.toMap()} })
    }

    private ProjectSettings getProjectSettings(Store<ProjectDescriptor> projectStore) {
        return projectStore.select { ProjectDescriptor descriptor -> descriptor.spec.settings }
    }

    private String getPipelineEnvVar(Store<PipelineDefinition> pipelineStore, String key) {
        return pipelineStore.select { PipelineDefinition definition -> definition.spec.environmentVars.find { it.key == key }?.value }
    }


}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/BackendConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.backend_devops.config.BackendRestClient
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.pipeline.PipelineSpec
import es.giss.framework.core.vo.resources.http.HttpResponse

@PipelineComponent(name = 'BackendConfigAdapter', priority = ConfigurationPriority.LOWEST)
class BackendConfigAdapter extends Steps implements IConfigAdapter {

    @NonCPS
    @Override
    String dependsOn() {
        return 'DefaultProjectConfigAdapter'
    }

    void resolveConfiguration(IPipelineContext context) {
        String environment = pipeline.getEnvironment()
        BackendRestClient backend = new BackendRestClient(steps)
        HttpResponse jenkinsTypeResponse = backend.getDevopsConfigByJenkinsType(environment, getJenkinsType())
        def configByJenkinsType = jenkinsTypeResponse.parseJsonBody() as Map
        def calculatedConfig = populateConfig(configByJenkinsType, environment) as Map<String, String>

        PipelineSpec specs = new PipelineSpec(
                environmentVars: calculatedConfig
        )

        logger.printPrettyLog(LogLevel.DEBUG, '[BackendConfigAdapter.resolveConfiguration] pipeline Environments -->', specs.environmentVars)



        context.updateDataModels(specs)

        logger.printPrettyLog(LogLevel.DEBUG, '[BackendConfigAdapter.resolveConfiguration] pipeline Environments model updated -->',
                pipeline.getStore(PipelineDefinition).select { it.spec.environmentVars })

    }


    private def getJenkinsType() {
        def jenkinsType = steps.env.JENKINS_TYPE
        if (jenkinsType == null || jenkinsType.isEmpty()) {
            logger.warn("No encuentro JENKINS_TYPE, calculo por particula final del namespace")
            jenkinsType = pipeline.getAppNamespace()
        }
        return jenkinsType
    }

    private Map<String, String> populateConfig(Map json, String environment) {
        def calculatedConfig = [:] as Map<String, String>
        json.values.each { calculatedConfig.put(it.name, it.value.toString()) }
        json.valuesDeployEnv[environment].each { calculatedConfig.put(it.name, it.value) }
        return calculatedConfig
    }

}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/DefaultProjectConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.configuration.config.vo.IdentifiersEnum
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.vo.pipeline.*
import es.giss.framework.core.vo.project.ProjectSettings
import es.giss.framework.core.vo.project.SourceRepository

@PipelineComponent(name = 'DefaultProjectConfigAdapter', priority = ConfigurationPriority.LOWEST)
class DefaultProjectConfigAdapter extends Steps implements IConfigAdapter {

    private IGitTool gitTool

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    DefaultProjectConfigAdapter(IGitTool gitTool) {
        this.gitTool = gitTool
    }

    String getEnvironmentFromUrl(String url) {
        def matcher = url =~ /.*\.(\w+)\.portal\.ss/
        if (matcher.matches()) {
            return matcher[0][1]
        } else {
            logger.warn("La URL ${url} no sigue la nomenclatura esperada.")
            return null
        }
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        SourceRepository sourceRepository = getDefaultSourceRepository()
        sourceRepository.id = IdentifiersEnum.DEFAULT_JOB_SOURCE_REPOSITORY.toString()
        if (!sourceRepository) {
            steps.error('No se estableci el repositorio fuente por defecto')
        }
        logger.debug('DefaultProjectDescriptorConfigAdapter.resolveConfiguration', "sourceRepository --> ${sourceRepository.toMap()}")
        Map<String, String> repositoryInfo = extractRepositoryInfo(sourceRepository.url)
        String devopsEnvironment = getDevOpsEnvironment()

        ProjectSettings projectSettings = createProjectSettings(repositoryInfo)
        logger.debug('DefaultProjectDescriptorConfigAdapter.resolveConfiguration', "projectSettings --> ${projectSettings.toMap()}")
        PipelineDefinition pipelineDefinition = createPipelineDefinition(devopsEnvironment)
        JobStatus jobStatus = createJobStatus()
        logger.debug('DefaultProjectDescriptorConfigAdapter.resolveConfiguration', "pipelineDefinition --> ${pipelineDefinition.toMap()}")

        context.updateDataModels(sourceRepository, projectSettings, pipelineDefinition, jobStatus)

    }

    private SourceRepository getDefaultSourceRepository() {
        return gitTool.getDefaultSourceRepository()
    }

    private Map<String, String> extractRepositoryInfo(String repositoryUrl) {
        String repositoryName = repositoryUrl.split('/').last().replace('.git', '')

        def matcher = repositoryName =~ /^([a-zA-Z0-9]+)_(([a-zA-Z0-9]{4})([a-zA-Z0-9]{4}))_([a-zA-Z0-9-]+)/

        String name = repositoryName
        String centro = ''
        String promotableItem = ''
        String capp = ''
        String suffix = ''

        if (matcher.matches()) {
            centro = matcher[0][1]
            promotableItem = matcher[0][2]
            capp = matcher[0][3]
            suffix = matcher[0][5]
        } else {
            logger.warn('DefaultProjectConfigAdapter', "El nombre del repositorio ${repositoryName} no sigue la nomenclatura esperada")
        }

        return [
                "name"          : name,
                "centro"        : centro,
                "promotableItem": promotableItem,
                "capp"          : capp,
                "suffix"        : suffix
        ]
    }

    private String getDevOpsEnvironment() {
        String devopsEnvironment = steps.env.DEVOPS_ENVIRONMENT
        if (devopsEnvironment == null) {
            String controllerName = pipeline.resolveControllerName()
            devopsEnvironment = getEnvironmentFromUrl(controllerName)
        }
        return devopsEnvironment
    }

    private ProjectSettings createProjectSettings(Map<String, String> repositoryInfo) {
        return new ProjectSettings(
                name: repositoryInfo.name,
                developCenter: repositoryInfo.centro,
                codeCapp: repositoryInfo.capp,
                promotableItem: repositoryInfo.promotableItem,
                suffix: repositoryInfo.suffix,
        )
    }

    private PipelineDefinition createPipelineDefinition(String devopsEnvironment) {
        String agentUserHome = steps.sh(script: 'echo $HOME', returnStdout: true).trim() ?: '/home/jenkins'
        logger.info('DefaultProjectConfigAdapter.createPipelineDefinition', "agentUserHome --> ${agentUserHome}")
        Map paramsMap = [:]
        steps.params.each { key, value ->
            paramsMap[key] = value
        }
        return new PipelineDefinition(
                spec: new PipelineSpec(
                        settings: new PipelineSettings(
                                devopsEnvironment: devopsEnvironment,
                                parameters: paramsMap
                        ),
                        environmentVars: [
                                'HOME': agentUserHome
                        ],
                        toolsManager: new ToolsManagerDescriptor(
                                asdf: new AsdfToolsManagerDescriptor(
                                        defaultToolVersionsFileDir: agentUserHome
                                ),
                                customScript: new CustomScriptManagerDescriptor(
                                        defaultToolVersionsFileDir: agentUserHome
                                )
                        )
                ),
        )
    }

    private JobStatus createJobStatus() {
        String commitMessage = gitTool.getCommitMessage()
        String commitId = gitTool.getCommitId()
        String remoteUrl = gitTool.getGitRemoteUrl()
        String branch = gitTool.getGitBranch()
        String commitEmail = gitTool.getCommitEmail()
        String buildUserId = pipeline.getCurrentPipelineUserId() ?: steps.env.BUILD_USER_ID
        String buildUserName = pipeline.getCurrentPipelineUserName()
        String workspace = steps.env.WORKSPACE
        return new JobStatus(
                gitRemoteUrl: remoteUrl,
                gitBranch: branch,
                commitId: commitId,
                commitMessage: commitMessage,
                commitEmail: commitEmail,
                buildUserId: buildUserId,
                buildUserName: buildUserName,
                workspace: workspace
        )
    }
}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/EmailsXmlConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.vo.project.Email
import es.giss.framework.core.vo.project.Notification
import es.giss.framework.core.vo.project.ProjectDescriptor

@PipelineComponent(name = 'EmailsXmlConfigAdapter', priority = ConfigurationPriority.LOWEST)
class EmailsXmlConfigAdapter extends Steps implements IConfigAdapter {

    List<String> FILES = ["emails.xml", "emails_nexus.xml"]
    private static String PIPE_PATH = "./pipes"

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        if(steps.fileExists(file: "$PIPE_PATH/emails.xml") && steps.fileExists(file: "$PIPE_PATH/emails_nexus.xml")) {
            Set<Email> emailSet = new HashSet<>()
            FILES.each {
                processEmailsXmlFile(it,emailSet)
            }

            Notification notification = new Notification(emails: emailSet)

            context.updateDataModels(notification)
            logger.printPrettyLog(LogLevel.DEBUG,'UpdatedNotification',
                    pipeline.getStore(ProjectDescriptor).select { ProjectDescriptor descriptor -> descriptor.spec.notifications.toMap()})
        } else {
            logger.warn("Files emails.xml and emails_nexus.xml do not exists.")
        }

    }

    private Set<Email> processEmailsXmlFile(String fileName, Set<Email> emailSet) {

        def file = ""
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${fileName}")
        if (exists) {
            file = steps.readFile(file: "${PIPE_PATH}/${fileName}")
        }
        def xml = new XmlSlurper().parseText(file)
        if (exists) {
            logger.debug("Loading configuration from file ${fileName}.")
        } else {
            logger.warn("File ${fileName} does not exists.")
        }



        if (!xml.isEmpty()) {
            xml.account.each { accountNode ->
                String email = accountNode.email.text().isEmpty() ? "" : accountNode.email.text()
                String name = accountNode.name.text().isEmpty() ? "" : accountNode.name.text()
                String conseguirTodasNotificaciones = setNewNotification(email, getNotificationType(fileName), emailSet)

                List<String> notificationsInterested = conseguirTodasNotificaciones.split(",")

                Email elemento = new Email()

                elemento.email = email
                elemento.name = name
                elemento.notificationsInterested = notificationsInterested
                emailSet.add(elemento)
                addOrUpdateEmail(elemento, emailSet)

            }
        }
        return emailSet
    }

    private String setNewNotification(String email, String interestNotification, Set<Email> emailSet) {
        String newNotifications = interestNotification
        emailSet.each {
            if (it.email == email) {
                String oldNotifications = it.notificationsInterested.join(",")
                newNotifications = "${oldNotifications},${interestNotification}"
            }
        }
        return newNotifications
    }

    private static String getNotificationType(String file) {
        String notificationType
        switch (file) {
            case "emails.xml":
                notificationType = "jenkins"
                break
            case "emails_nexus.xml":
                notificationType = "nexus"
                break
            default:
                notificationType = ""
                break
        }
        return notificationType
    }

    private void addOrUpdateEmail(Email newEmail, Set<Email> emailSet) {
        // Busca el objeto Email existente en el conjunto
        Email existingEmail = emailSet.find { it.email == newEmail.email }

        // Si el objeto Email existe, lo elimina del conjunto
        if (existingEmail != null) {
            emailSet.remove(existingEmail)
        }

        // Agrega el nuevo objeto Email al conjunto
        emailSet.add(newEmail)
    }

}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/JenkinsFileConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.vo.pipeline.AsdfToolsManagerDescriptor
import es.giss.framework.core.vo.pipeline.PipelineSpec
import groovy.json.JsonSlurper

@PipelineComponent(name = 'JenkinsFileConfigAdapter', priority = ConfigurationPriority.LOWEST)
class JenkinsFileConfigAdapter extends Steps implements IConfigAdapter {

    private static String FILE = "Jenkinsfile"
    private static String PIPE_PATH = "./pipes"

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        def jenkinsfileContent = ""
        def JKFType = ["FwDevOps", "FwAutoAgent"]
        Map mapa = [:]
        jenkinsfileContent = loadFile(FILE)
        if(jenkinsfileContent.isEmpty()) {
            logger.warn('JenkinsFileConfigAdapter.resolveConfiguration', "File ${PIPE_PATH}/${FILE} does not exists.")
            return
        }
        jenkinsfileContent = jenkinsfileContent.replaceAll(/@Library.*_/, "")
        Binding binding = new Binding()
        def fwType = ""
        JKFType.each { ele ->
            if (jenkinsfileContent.contains(ele)) {
                fwType = ele
                binding.setProperty(ele, { a="defecto", b -> mapa = b?: [:] })
            }
        }

        evaluateScript(binding, jenkinsfileContent)
        Map envVars = mapa?.collectEntries { String key, String value ->
            [(key.trim()): value.trim()]
        }

        def toolsbuild = [:]

        if (fwType.contains("FwAutoAgent")) {
            def sw = mapa?.get("SOFTWARE_AUTOAGENT")
            def jsonSlurper = new JsonSlurper()
            def jsonList = jsonSlurper.parseText(sw)
            jsonList.each { item ->
                if (item.stage == 'build') {
                    item.software.each { software ->
                        def nombre = software.nombre
                        def version = software.version
                        toolsbuild << ["${nombre}": version]
                    }
                }
            }
        }

        def spec = new PipelineSpec(environmentVars: envVars)
        def toolsManager = new AsdfToolsManagerDescriptor(tools: toolsbuild)

        pipeline.updateDataModels(spec, toolsManager)
    }

    @NonCPS
    private def evaluateScript(Binding binding, String JenkinsfileContent) {
        GroovyShell shell = new GroovyShell(binding)
        return shell.evaluate(JenkinsfileContent)
    }

    private String loadFile(String filePath) {

        def file = ""
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${filePath}")
        if (exists) {
            logger.debug("[JenkinsFileConfigAdapter] Loading configuration from file ${filePath}.")
            file = steps.readFile(file: "${PIPE_PATH}/${filePath}")
        }
        return file
    }
}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/LocalPipelineYamlConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext

@PipelineComponent(name = 'LocalPipelineYamlConfigAdapter', priority = ConfigurationPriority.LOW)
class LocalPipelineYamlConfigAdapter extends Steps implements IConfigAdapter {

    private static String FILE = "pipeline.yaml"

    @NonCPS
    @Override
    String dependsOn() {
        return 'PipelineYamlConfigAdapter'
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {

        try {

            if (steps.fileExists(file: FILE)) {
                String contentFile = steps.readFile(file: FILE)


                if (!contentFile.trim()) {
                    logger.warn("Error getting file pipeline.yaml from pipelines repository. Content is null or empty.")
                    return
                }
                def data = steps.readYaml(text: contentFile, encoding: 'UTF-8')

                context.updateDataModelsFromMap(data)
            } else {
                logger.debug("Local File pipeline.yaml does not exist in the repository")
                return
            }


        } catch (Exception e) {
            logger.warn("Error getting Local file pipeline.yaml. Error: ${e.getMessage()}")

        }

    }


}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/PipelineYamlConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IWorkspaceTool
import es.giss.framework.core.tools.restClients.GitLabTool
import es.giss.framework.core.tools.restClients.interfaces.IGitLabTool
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.release.ReleaseDescriptor

@PipelineComponent(name = 'PipelineYamlConfigAdapter', priority = ConfigurationPriority.LOW)
class PipelineYamlConfigAdapter extends Steps implements IConfigAdapter {

    private static String DIRECTORY_DEV_PIPELINES = "/var/lib/jenkins/repositories/local/pipelines/jenkinsfiles"
    private static String FILE = "pipeline.yaml"
    private static String PIPELINES_DIRECTORY = "pipelines"
    IGitLabTool gitLabTool
    static final String JEKINSFILE_PATH_REPOSITORY = 'ot/fdar/ot_fdarfrwk_pipelines'
    IWorkspaceTool workspaceTool
    private String JENKINSFILE_BRANCH_REPOSITORY = 'master'

    PipelineYamlConfigAdapter(IWorkspaceTool workspaceTool) {
        this.workspaceTool = workspaceTool
    }


    @NonCPS
    private IGitLabTool getGitLabTool() {
        if (!gitLabTool) {
            gitLabTool = new GitLabTool(steps, logger)
        }
        return gitLabTool
    }

    @NonCPS
    @Override
    String dependsOn() {
        return ''
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        try {
            if (context.isDevelopmentMode()) {
                String resourcePath = getResourcePath(context)
                resourcePath = "${DIRECTORY_DEV_PIPELINES}/${resourcePath}"
                logger.debug("Getting file pipeline.yaml from pipelines in Development Mode ${resourcePath}")
                if (!workspaceTool.fileExists(resourcePath)) {
                    logger.warn("Error getting file pipeline.yaml from pipelines in Development Mode. File does not exist.")
                    return
                }
                String contentFile = workspaceTool.readFile(resourcePath)

                if (!contentFile.trim()) {
                    logger.warn("Error getting file pipeline.yaml from pipelines repository. Content is null or empty.")
                    return
                }
                def data = steps.readYaml(text: contentFile, encoding: 'UTF-8')


                context.updateDataModelsFromMap(data)
                logger.printPrettyLog(LogLevel.DEBUG, "PipelineYamlConfigAdapter.resolveConfiguration, Develop Mode data -->",
                        [pipeline.getStore(ProjectDescriptor).select { it.toMap() }, pipeline.getStore(PipelineDefinition).select { it.toMap() },
                         pipeline.getStore(ReleaseDescriptor).select { it.toMap() }])

            } else {
                String jenkinfileRepository = steps.env.JEKINSFILE_PATH_REPOSITORY ?: JEKINSFILE_PATH_REPOSITORY
                String repoBranch = steps.env.JENKINSFILE_BRANCH_REPOSITORY ?: JENKINSFILE_BRANCH_REPOSITORY
                def resourcePath = getResourcePath(context)
                logger.debug("Getting file pipeline.yaml from pipelines repository ${resourcePath}")


                String contentFile = gitLabTool.getRawFile(jenkinfileRepository, repoBranch, resourcePath.toString())


                if (!contentFile.trim()) {
                    logger.warn("Error getting file pipeline.yaml from pipelines repository. Content is null or empty.")
                    return
                }
                def data = steps.readYaml(text: contentFile, encoding: 'UTF-8')
                logger.printPrettyLog(LogLevel.DEBUG, "PipelineYamlConfigAdapter.resolveConfiguration, data -->", data)
                context.updateDataModelsFromMap(data)
            }

        } catch (Exception e) {
            logger.warn("Error getting file pipeline.yaml from pipelines repository. Error: ${e.getMessage()}")

        }

    }


    String getResourcePath(IPipelineContext context) {
        Store pipelineStore = context.getStore(PipelineDefinition)
        String gitUrl = pipelineStore.select { PipelineDefinition descriptor -> descriptor.spec.environmentVars.GIT_URL }
        String gitCredentialId = pipelineStore.select { PipelineDefinition descriptor -> descriptor.spec.environmentVars.GIT_CREDENTIALSID_GITLAB_FULL }

        logger.debug('PipelineYamlConfigAdapter.getResourcePath', "gitUrl --> ${gitUrl}")
        if (!gitUrl) {
            steps.error('No se estableci la URL del repositorio git en Variable de Entorno "GIT_URL"')
        }

        // Configuramos gitLabTool
        gitLabTool = getGitLabTool()
                .baseUrl(gitUrl)
                .ignoreSsl(true)
                .credentialsId(gitCredentialId)

        Store projectStore = context.getStore(ProjectDescriptor)

        String projectId = projectStore.select { ProjectDescriptor descriptor -> descriptor?.spec.sourceRepositories?.first()?.projectIdOrPathFromUrl() }
        logger.debug("Getting ProjectId from SourceRepository ${projectId}")


        if (!projectId) {
            logger.warn("Error getting ProjectId from SourceRepository. ProjectId is null or empty.")
            return
        }

        List<String> labels = gitLabTool.getProjectLabels(projectId)
        logger.printPrettyLog(LogLevel.DEBUG, "Getting labels from ProjectId ${projectId}", labels)

        String projectType = labels.find { it.toLowerCase().contains('tech_') }.replace('tech_', '')

        logger.debug("Getting ProjectType from ProjectId ${projectType}")

        String resourcePath = "${PIPELINES_DIRECTORY}/${projectType}/${FILE}"
        logger.debug("Getting resourcePath from ProjectId ${resourcePath}")
        return resourcePath
    }
}
</file>

<file path="bin/main/es/giss/framework/configuration/config/adapters/ReleaseConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.backend_devops.config.BackendRestClient
import es.giss.framework.configuration.config.vo.IdentifiersEnum
import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.ISemanticRelease
import es.giss.framework.core.tools.restClients.CredentialType
import es.giss.framework.core.tools.restClients.RestClient
import es.giss.framework.core.utils.ArtifactsHelmXmlReader
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.project.Metadata
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.project.ProjectSettings
import es.giss.framework.core.vo.project.StructuredResourceMetadata
import es.giss.framework.core.vo.release.DeployEnvironment
import es.giss.framework.core.vo.release.GitlabUser
import es.giss.framework.core.vo.release.MergeRequest
import es.giss.framework.core.vo.release.ReleaseConfig
import es.giss.framework.core.vo.release.ReleaseDescriptor
import es.giss.framework.core.vo.release.ReleaseSpec
import es.giss.framework.core.vo.release.ApprovalRule
import es.giss.framework.core.vo.resources.http.HttpResponse

@PipelineComponent(name = 'ReleaseConfigAdapter', priority = ConfigurationPriority.LOW)
class ReleaseConfigAdapter extends Steps implements IConfigAdapter {

    private ISemanticRelease releaseController

    ReleaseConfigAdapter(ISemanticRelease releaseController) {
        this.releaseController = releaseController
    }

    @NonCPS
    @Override
    String dependsOn() {
        return 'LocalPipelineYamlConfigAdapter'
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        List<Map> buildConfigs = resolveReleaseConfig()
        if (buildConfigs.isEmpty() || buildConfigs?.get(0)?.isEmpty()) {
            logger.warn("Error getting Release Config from Artifacts Helm XML")
            return
        }
        logger.printPrettyLog(LogLevel.DEBUG, 'ReleaseConfigAdapter.resolveConfiguration, Inititial Release Config -->', buildConfigs)
        Set<String> techNames = buildConfigs.collect { it.runtimeTech }.toSet() as Set<String>

        logger.printPrettyLog(LogLevel.DEBUG, 'ReleaseConfigAdapter.resolveConfiguration, Tech Names -->', techNames)

        Map backendHelmInfo = getBackendHelmInfo(techNames)
        ProjectSettings projectSettings = pipeline.getStore(ProjectDescriptor).select { ProjectDescriptor descriptor ->
            descriptor.spec.settings
        }

        List<ReleaseConfig> releaseConfigsFinal = mergeData(buildConfigs, backendHelmInfo)

        ReleaseDescriptor releaseDescriptor = new ReleaseDescriptor(
                metadata: new StructuredResourceMetadata(
                        name: releaseConfigsFinal?.get(0)?.releaseName ?: projectSettings.promotableItem,
                ),
                spec: new ReleaseSpec(
                        releaseConfigs: releaseConfigsFinal
                )
        )

        pipeline.updateDataModels(releaseDescriptor)
        logger.printPrettyLog(LogLevel.DEBUG, 'ReleaseConfigAdapter.resolveConfiguration, Final Release Descriptor -->',
                pipeline.getStore(ReleaseDescriptor).select { it.spec.toMap() })
        releaseController.analyzeCommits()
        getApprovalRules()
        getMergeRequestData()

        logger.printPrettyLog(LogLevel.DEBUG, 'ReleaseConfigAdapter.resolveConfiguration, Final Release Descriptor 2-->',
                pipeline.getStore(ReleaseDescriptor).select { it.spec.toMap() })

    }




    List<Map> resolveReleaseConfig() {
        Store<ReleaseDescriptor> store = pipeline.getStore(ReleaseDescriptor)
        ArtifactsHelmXmlReader artifactsHelmXmlReader = new ArtifactsHelmXmlReader(steps, logger)
        List<Map> helmConfig = artifactsHelmXmlReader.getHelmConfig()
        if (helmConfig?.get(0)?.isEmpty()) {
            logger.warn("Error getting Helm Config from Artifacts Helm XML")
            return store.select { ReleaseDescriptor descriptor ->
                return descriptor.spec?.releaseConfigs?.collect { it.toMap() } ?: []
            }
        }
        return helmConfig
    }

    List<ReleaseConfig> mergeData(List<Map> datosHelm, Map respuestaAPI) {
        ProjectSettings projectSettings = pipeline.getStore(ProjectDescriptor).select { ProjectDescriptor descriptor ->
            descriptor.spec.settings
        }

        List<ReleaseConfig> resultado = []
        def baseImages = respuestaAPI.baseImages
        logger.printPrettyLog(LogLevel.DEBUG, 'ReleaseConfigAdapter.mergeData, baseImages  -->', baseImages)

        datosHelm.eachWithIndex { data, index ->
            def baseImage = baseImages.find { it.type == data.runtimeTech }
            def rtHelmChart = respuestaAPI.rtHelmCharts.find { it.runTimeTech == data.runtimeTech }
            // Crear un nuevo mapa combinando la informacin
            String id = index == 0 ? IdentifiersEnum.DEFAULT_RELEASE_CONFIG.toString() : "${IdentifiersEnum.DEFAULT_RELEASE_CONFIG.toString()}_${index}"
            ReleaseConfig datoCombinado = new ReleaseConfig(id: id)
            datoCombinado.putAll([
                    configPath        : data.configPath ?: 'src/main',
                    chartVersion      : data.chartVersion,
                    nexusFile         : data.nexusFile ?: '',
                    baseImageName     : baseImage?.name,
                    chartName         : rtHelmChart?.chartName,
                    helmChartPath     : rtHelmChart?.helmChartPath,
                    ocNamespaceSuffix : data?.ocNamespaceSuffix ?: "${projectSettings.developCenter}-${projectSettings.codeCapp.substring(0, 4)}".toString(),
                    runtimeTech       : data?.runtimeTech ?: '',
                    runtimeTechVersion: data?.runtimeTechVersion ?: '',
                    runtimeTechTag    : data?.runtimeTechTag ?: '',
                    releaseName       : data?.releaseName ?: projectSettings.promotableItem,
            ])
            resultado.add(datoCombinado)
        }
        return resultado
    }

    Map getBackendHelmInfo(Set<String> techNames) {
        BackendRestClient backendRestClient = new BackendRestClient(steps)
        HttpResponse resultHelmInfo = backendRestClient.helmInfoBaseImagesChart(techNames)
        resultHelmInfo.parseJsonBody() as Map
    }

    void getApprovalRules() {
        BackendRestClient backendRestClient = new BackendRestClient(steps)
        ProjectSettings projectSettings = pipeline.getStore(ProjectDescriptor).select { ProjectDescriptor descriptor ->
            descriptor.spec.settings
        }
        ReleaseSpec spec = pipeline.getStore(ReleaseDescriptor).select { it.spec }
        def entorno = spec.releasePromotion.toEnvironment
        String version = spec.version.toString().split('-')[0]
        String promotableItem = projectSettings.promotableItem
        logger.debug("ReleaseConfigAdapter.getApprovalRules()", "Se recupera approvalRules en entorno ${entorno}, version ${version} y aplicacion ${promotableItem}")
        if (entorno == DeployEnvironment.PREPRODUCTION) {
            HttpResponse response = backendRestClient.getResultPreexplotacion(version, promotableItem)
            Map responseMap = response.parseJsonBody() as Map
            responseMap.put('tags', ["PRE"])
            ApprovalRule approvalRule = new ApprovalRule(
                    name: 'haraResponse',
                    metadata: new Metadata(responseMap),
            )
            logger.debug('ReleaseConfigAdapter.getApprovalRules()', "getApprovalRules(version: ${version}, application: ${promotableItem}) = approvalRule: ${approvalRule}")
            ReleaseSpec releaseSpec = new ReleaseSpec(
                    approvalRules: [approvalRule]
            )
            pipeline.updateDataModels(releaseSpec)
        }
    }

    void getMergeRequestData() {
        ReleaseSpec spec = pipeline.getStore(ReleaseDescriptor).select { it.spec }
        if (spec.releasePromotion.toEnvironment == DeployEnvironment.PRODUCTION){
            Map environments = pipeline.getStore(PipelineDefinition).select { PipelineDefinition pipelineDefinition ->
                pipelineDefinition.spec.environmentVars
            }
            ProjectSettings projectSettings = pipeline.getStore(ProjectDescriptor).select { ProjectDescriptor descriptor ->
                descriptor.spec.settings
            }

            String urlIdProjectQuery = "${environments.get('GIT_URL')}/api/v4/projects/?search=${projectSettings.name}"
            HttpResponse idProjectQuery = new RestClient(steps)
                    .url(urlIdProjectQuery)
                    .withAuthBearer(environments.get('GIT_CREDENTIALSID_GITLAB_FULL'), CredentialType.USERNAME_PASSWORD)
                    .debugMode(true)
                    .get()
                    .execute()
            def jsonIdProjectQuery = idProjectQuery.parseJsonBody()

            String urlMergerQuery = "${environments.get('GIT_URL')}/api/v4/projects/${jsonIdProjectQuery[0].id}/merge_requests"
            HttpResponse mergerQuery = new RestClient(steps)
                    .url(urlMergerQuery)
                    .withAuthBearer(environments.get('GIT_CREDENTIALSID_GITLAB_FULL'), CredentialType.USERNAME_PASSWORD)
                    .debugMode(true)
                    .get()
                    .execute()
            if (mergerQuery.statusCode != 200){
                logger.error('ReleaseConfigAdapter.getMergeRequestData','Error al consultar datos sobre sobre los merge-request del proyecto')
            }
            def jsonMergerQuery = mergerQuery.parseJsonBody()
            def mostRecentMasterMerge = jsonMergerQuery.findAll { it.state == 'merged' && it.target_branch == 'master' }.max { it.merged_at }
            if (!mostRecentMasterMerge){
                logger.error('ReleaseConfigAdapter.getMergeRequestData','No hay ningn merge a master')
            }

            GitlabUser mergeUser = new GitlabUser(id: mostRecentMasterMerge.merge_user.id, name: mostRecentMasterMerge.merge_user.name, gu: mostRecentMasterMerge.merge_user.username)
            GitlabUser mergedBy = new GitlabUser(id: mostRecentMasterMerge.merged_by.id, name: mostRecentMasterMerge.merged_by.name, gu: mostRecentMasterMerge.merged_by.username)
            logger.info('ReleaseConfigAdapter.getMergeRequestData',"Datos del merger: ${mergedBy}")

            String urlApproverQuery = "${environments.get('GIT_URL')}/api/v4/projects/${jsonIdProjectQuery[0].id}/merge_requests/${mostRecentMasterMerge.iid}/approvals"
            HttpResponse approverQuery = new RestClient(steps)
                    .url(urlApproverQuery)
                    .withAuthBearer(environments.get('GIT_CREDENTIALSID_GITLAB_FULL'), CredentialType.USERNAME_PASSWORD)
                    .debugMode(true)
                    .get()
                    .execute()
            if (approverQuery.statusCode != 200){
                logger.error('ReleaseConfigAdapter.getMergeRequestData','Error al consultar datos sobre el approver')
            }
            def jsonApproverQuery = approverQuery.parseJsonBody()

            List<GitlabUser> approvedBy = []
            jsonApproverQuery.approved_by.each{
                approvedBy.add(new GitlabUser(
                        id: it.user.id,
                        name: it.user.name,
                        gu: it.user.username
                ))
            }
            logger.info('ReleaseConfigAdapter.getMergeRequestData',"Datos del approver: ${approvedBy}")

            String description =mostRecentMasterMerge.description
            def cleanedDescription = description
                    .replaceAll(/[]/,"")
                    .replaceAll('@','a')
                    .replaceAll('#','H')
                    .replaceAll('\\$', 'S')
                    .replaceAll('','gn')
                    .replaceAll(/[^\w]/, ' ')

            MergeRequest mergeRequestResult = new MergeRequest(
                    enabled : true,
                    iid : mostRecentMasterMerge.iid,
                    sourceBranch : mostRecentMasterMerge.source_branch,
                    targetBranch : mostRecentMasterMerge.target_branch,
                    mergeUser : mergeUser,
                    approvedBy : approvedBy,
                    mergedBy : mergedBy,
                    mergeCommitSha : mostRecentMasterMerge.merge_commit_sha,
                    description : cleanedDescription,
                    date : mostRecentMasterMerge.merged_at,
                    state: mostRecentMasterMerge.state,
            )

            pipeline.updateDataModels(mergeRequestResult)
        }
    }

}
</file>

<file path="bin/main/es/giss/framework/configuration/config/provider/ArtifactsHelmXmlReader.groovy">
package es.giss.framework.configuration.config.provider

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.logger.LogLevel

class ArtifactsHelmXmlReader {

    private final static String file = "artifacts_helm.xml"

    protected Script steps
    protected ILogger logger

    ArtifactsHelmXmlReader(Script steps, ILogger logger) {
        this.steps = steps
        this.logger = logger
    }

    List<Map> getHelmConfig() {
        String helmXmlContent = loadFile(file)
        if (!helmXmlContent) {
            return [:]
        }
        List<Map> configMap = parseArtifactsHelm(helmXmlContent)
        logger.printPrettyLog(LogLevel.DEBUG, 'Helm Config Map:', configMap)
        return configMap
    }

    private String loadFile(String filePath) {
        String PIPE_PATH = "${steps.env.WORKSPACE}/pipes"
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${filePath}")
        if (exists) {
            def fileContent = steps.readFile(file: "${PIPE_PATH}/${filePath}")
            logger.debug("Loading configuration from file ${PIPE_PATH}/${filePath}.")
            return fileContent
        } else {
            logger.warn("File ${filePath} does not exists.")
        }
        return ''
    }
//
    @NonCPS
    private List<Map<String, Object>> parseArtifactsHelm(String xmlContent) {
        def artifacts = new XmlSlurper().parseText(xmlContent)

        def deployDefaultXml = artifacts?.helm?.deploy_default
        Map deployDefault = [
                ocNamespaceSuffix : deployDefaultXml?.@oc_namespace_suffix.text() ?: '--',
                runtimeTech       : deployDefaultXml?.@runtime_tech.text() ?: '--',
                runtimeTechVersion: deployDefaultXml?.@runtime_tech_version.text() ?: '--',
                runtimeTechTag    : deployDefaultXml.@runtime_tech_tag.text() ?: '--',
                chartVersion      : deployDefaultXml.@chart_version.text() ?: '--',
                configPath        : deployDefaultXml.@path_config.text() ?: 'src/main'
        ]


        return artifacts.helm.deploy.collect { it ->
            String artifactId = it.@artifact.text()
            def deployArtifact = artifacts.artifact.find { it.@name == artifactId }
            return [
                    releaseName       : it.@nombre_release.text(),
                    artifactId        : artifactId,
                    configPath        : it.@path_config.text() ?: deployDefault.configPath,
                    ocNamespaceSuffix : it.@oc_namespace_suffix.text() ?: deployDefault.ocNamespaceSuffix,
                    runtimeTech       : it.@runtime_tech.text() ?: deployDefault.runtimeTech,
                    runtimeTechVersion: it.@runtime_tech_version.text() ?: deployDefault.runtimeTechVersion,
                    runtimeTechTag    : it.@runtime_tech_tag.text() ?: deployDefault.runtimeTechTag,
                    chartVersion      : it.@chart_version.text() ?: deployDefault.chartVersion,
                    nexusFile         : deployArtifact?.nexus_file?.text() ?: ''
            ]
        }

    }


}
</file>

<file path="bin/main/es/giss/framework/configuration/config/vo/IdentifiersEnum.groovy">
package es.giss.framework.configuration.config.vo

import com.cloudbees.groovy.cps.NonCPS

enum IdentifiersEnum {

    // api connect
    DEFAULT_APIC_TOOL('defaultApiTool'),
    DEFAULT_APIC_MANAGEMENT_BUILD('defaultApiManagementBuild'),
    DEFAULT_APIC_MANAGEMENT_DEPLOY('defaultApiManagementDeploy'),
    DEFAULT_APIC_MANAGEMENT_PUBLISH('defaultApiManagementPublish'),


    // Artifacts repositories identifiers
    DEFAULT_ARTIFACTS_REPOSITORY('defaultNexusRepository'),
    DEFAULT_ARTIFACTS_REPOSITORY_CREDENTIALS('defaultNexusCredentials'),
    GISS_DEPLOY_REPOSITORY('gissDeployRepository'),
    // Container identifiers
    DEFAULT_CONTAINER_TOOL('defaultContainerTool'),

    // Maven identifiers
    DEFAULT_MAVEN_TOOL('defaultMavenTool'),
    DEFAULT_MAVEN_BUILD('defaultMavenBuild'),
    DEFAULT_MAVEN_TEST('defaultMavenTest'),
    DEFAULT_MAVEN_PUBLISH('defaultMavenPublish'),

    // Helm identifiers
    DEFAULT_HELM_TOOL('defaultHelmTool'),
    DEFAULT_HELM_BUILD_STRATEGY('defaultHelmBuild'),
    DEFAULT_HELM_PUBLISH_STRATEGY('defaultHelmPublish'),
    DEFAULT_HELM_DEPLOY_STRATEGY('defaultHelmDeploy'),
    DEFAULT_HELM_TEST_STRATEGY('defaultHelmTest'),
    DEFAULT_HELM_CHARTS_SOURCE_REPOSITORY('defaultHelmChartsSourceRepository'),
    CSI_HELM_BUILD_STRATEGY('csiHelmBuild'),
    CSI_HELM_DEPLOY_STRATEGY('csiHelmDeploy'),
    CSI_HELM_CHARTS_SOURCE_REPOSITORY('csiHelmChartsSourceRepository'),

    //XL identifiers
    DEFAULT_XL_TOOL('defaultXlTool'),

    //PROSA identifiers
    DEFAULT_PROSA_TOOL('defaultProsaTool'),


    // Openshift identifiers
    DEFAULT_OPENSHIFT_SERVER('defaultOpenshifServer'),
    DEFAULT_OPENSHIFT_BUILD('defaultOpenshiftBuild'),

    // Apic identifiers
    DEFAULT_APIC_SERVER('defaultApicServer'),

    DEFAULT_JOB_SOURCE_REPOSITORY('defaultJobSourceRepository'),

    // Release identifiers
    DEFAULT_RELEASE_CONFIG('defaultReleaseConfig'),

    // Policies identifiers
    DEFAULT_POLICIES_REPOSITORY('defaultPoliciesRepository'),

    // ScannerTools
    DEFAULT_KIUWAN_TOOL('defaultKiuwanTool'),
    DEFAULT_UTF8_TOOL('defaultUtf8Tool'),

    // Gradle identifiers
    DEFAULT_GRADLE_TOOL('defaultGradleTool'),
    DEFAULT_GRADLE_BUILD('defaultGradleBuild'),
    DEFAULT_GRADLE_TEST('defaultGradleTest'),
    DEFAULT_GRADLE_PUBLISH('defaultGradlePublish'),

    final String id

    IdentifiersEnum(String id) {
        this.id = id
    }

    @NonCPS
    @Override
    String toString() {
        return id
    }
}
</file>

<file path="bin/test/naua/pipeline.yaml">
kind: ProjectDescriptor
apiVersion: project.giss.es/v1
spec:
  projectType: Naua
  tools:
    - id: defaultMavenTool
      name: maven
      version: 3.6.3
      cache: true
      toolConfigurationFilePath: pom.xml
      artifactsRepositoryId: defaultNexusRepository
      buildStrategies:
        - id: defaultMavenBuild
          name: Build con Maven
          buildCommand: -B clean package -DskipTests
          metadata: {}
      publishStrategies:
        - id: defaultMavenPublish
          name: Subida a repositorio con Maven
          publishCommand: deploy -DskipTests -DaltDeploymentRepository=nexus::default::${urlRepoDeploy}
          metadata: {}
      testStrategies:
        - id: defaultMavenTest
          name: Test con Maven
          testCommand: clean test
          metadata:
            testType: unit
            testFramework: junit

    - id: defaultHelmTool
      name: helm
      version: 3.12.1
      cache: true
      artifactsRepositoryId: defaultNexusRepository
      toolConfigurationFilePath: chart.yaml

  artifactsRepositories:
    - id: defaultNexusRepository
      name: defaultNexusRepository
      url: https://nexus-gpro-co-dvo.apps.giss.pro.portal.ss/repository/${developCenter}__group_maven/
      credentialsId: oc-gs-jenkins-nexus-int-auth
      metadata:
        repositoryType: maven

---

kind: PipelineDefinition
apiVersion: pipeline.giss.es/v1
spec:
  cache:
    baseDir: /opt/cache/
    cacheFolders:
      - helm/v3/cache
      - helm/v3/config
      - helm/v3/data
      - maven
    exportEnvVar: CACHE_BASE_DIR
    forceClearCache: false
  environmentVars:
    M2_HOME: ${CACHE_BASE_DIR}/maven/
    MAVEN_OPTS: -Djavax.net.ssl.trustStore=/etc/ssl/certs/java/cacerts -Djavax.net.ssl.trustStorePassword=changeit -Dmaven.repo.local=${CACHE_BASE_DIR}/maven/
    HELM_CACHE_HOME: ${CACHE_BASE_DIR}/helm/v3/cache
    HELM_CONFIG_HOME: ${CACHE_BASE_DIR}/helm/v3/config
    HELM_DATA_HOME: ${CACHE_BASE_DIR}/helm/v3/data
    HELM_HOME: ${CACHE_BASE_DIR}/helm/v2
    JAVA_OPTS: -Djavax.net.ssl.trustStore=/etc/ssl/certs/java/cacerts -Djavax.net.ssl.trustStorePassword=changeit
    JENKINS_JAVA_OPTIONS: -Dhttps.protocols=TLSv1.2
  toolsManager:
    alternatives:
      javaEngine: adoptopenjdk-11.0.13+8
    asdf:
      plugins:
        maven: https://github.com/halcyon/asdf-maven.git
        helm:  https://github.com/Antiarchitect/asdf-helm.git
      tools:
        maven: 3.6.3
        helm: 3.12.1
        graalvm: 22.3.0-java11
    graalVmTools:
      javaEngine: 22.3.0-java11
      plugins:
        - native-image
        - python
        - npm

---

kind: ReleaseDescriptor
apiVersion: release.giss.es/v1
metadata:
  name: back-main
  namespace: gint-ot-fdar
spec:
  releaseConfigs:
    - id: defaultReleaseConfig
      runtimeTech: java
      runtimeTechVersion: '21'
      runtimeTechTag: ''
      configPath: "src/main"
      ocNamespaceSuffix: ot-fdar # Si no se especifica se toma el valor extrayendolo del nombre del repositorio
      chartVersion: "1.19.0"
      chartName: ot-fdarback_main
      baseImageName: openjdk
</file>

<file path="src/es/giss/framework/configuration/config/adapters/BackendConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredPipelineEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.restClients.RestClient
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.pipeline.PipelineSettings


@PipelineComponent(name = 'BackendConfigAdapter', priority = ConfigurationPriority.LOWEST)
class BackendConfigAdapter extends Steps implements IConfigAdapter {

    void resolveConfiguration(IPipelineContext context) {

        String environment = pipeline.getEnvironment()
        String urlBackend = steps.env.BACKEND_HOST
        Map params = buildParams(environment)
        String url = buildBackendQueryWithParams(urlBackend, "jobs/getDevopsConfigByJenkinsType", params)
        Map configByJenkinsType = fetchDevopsConfigByJenkinsType(url)
        Map calculatedConfig = populateConfig(configByJenkinsType, environment)

        Store<PipelineDefinition> store = context.getStore(PipelineDefinition)
        PipelineSettings settings = new PipelineSettings(
                environmentVars: calculatedConfig
        )
        ConfiguredPipelineEvent event = new ConfiguredPipelineEvent(description: "Configuracin de pipeline resuelta por BackendConfigAdapter", payload: settings)
        store.dispatch(event)
    }

    private def buildParams(String environment) {
        return [
                "environment": environment,
                "jenkinsType": getJenkinsType()
        ]
    }

    private def getJenkinsType() {
        def jenkinsType = steps.env.JENKINS_TYPE
        if (jenkinsType == null || jenkinsType.isEmpty()) {
            logger.warn("No encuentro JENKINS_TYPE, calculo por particula final del namespace")
            jenkinsType = pipeline.getAppNamespace()
        }
        return jenkinsType
    }

    private def buildBackendQueryWithParams(String baseUrl, String endpoint, Map params) {
        def query = params.collect { k, v -> "${URLEncoder.encode(k.toString(), "UTF-8")}=${URLEncoder.encode(v.toString(), "UTF-8")}" }.join('&')
        return "${baseUrl}/${endpoint}?${query}"
    }

    private def fetchDevopsConfigByJenkinsType(String url) {
        def restClient = new RestClient(steps)
        def response = restClient.url(url)
                .get()
                .execute()
        return response.parseJsonBody()
    }

    private Map<String, Object> populateConfig(Map json, String environment) {
        def calculatedConfig = json.values.collectEntries { [it.name, it.value] }
        calculatedConfig.putAll(json.valuesDeployEnv[environment.toUpperCase()].collectEntries { [it.name, it.value] })
        return calculatedConfig
    }


}
</file>

<file path="src/es/giss/framework/configuration/config/adapters/DefaultProjectDescriptorConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredPipelineEvent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.storage.Store
import es.giss.framework.core.tools.interfaces.IGitTool
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.pipeline.PipelineSettings
import es.giss.framework.core.vo.project.ProjectDescriptor
import es.giss.framework.core.vo.project.ProjectSettings
import es.giss.framework.core.vo.project.SourceRepository

@PipelineComponent(name = 'DefaultProjectDescriptorConfigAdapter', priority = ConfigurationPriority.LOWEST)
class DefaultProjectDescriptorConfigAdapter extends Steps implements IConfigAdapter {

    private IGitTool gitTool

    DefaultProjectDescriptorConfigAdapter(IGitTool gitTool) {
        this.gitTool = gitTool
    }

    String getEnvironmentFromUrl(String url) {
        def matcher = url =~ /.*\.(\w+)\.portal\.ss/
        if (matcher.matches()) {
            return matcher[0][1]
        } else {
            logger.warn("La URL ${url} no sigue la nomenclatura esperada.")
            return null
        }
    }

    @Override
    void resolveConfiguration(IPipelineContext context) {
        SourceRepository sourceRepository = getDefaultSourceRepository()
        String tag = getLatestTagFromCurrentHead()
        Map<String, String> repositoryInfo = extractRepositoryInfo(sourceRepository.url)
        String devopsEnvironment = getDevOpsEnvironment()

        configureProjectDescriptor(context, sourceRepository, tag, repositoryInfo)
        configurePipelineDescriptor(context, devopsEnvironment)
    }

    private SourceRepository getDefaultSourceRepository() {
        return gitTool.getDefaultSourceRepository()
    }

    private String getLatestTagFromCurrentHead() {
        return gitTool.getLatestTagFromCurrentHead()
    }

    private Map<String, String> extractRepositoryInfo(String repositoryUrl) {
        String repositoryName = repositoryUrl.split('/').last().replace('.git', '')
        def matcherV1 = repositoryName =~ /(\w{2})_(_?)(\w{4})(\w[^_]+)_(_?)(\w+)/
        def matcherV2 = repositoryName =~ /([a-zA-Z0-9]+)_(_?)([a-zA-Z0-9]+)_(_?)([a-zA-Z0-9-]+)/

        String centro = ''
        String capp = ''
        String elementoPromocionable = ''
        String sufijo = ''

        if (matcherV1.matches()) {
            centro = matcherV1[0][1]
            capp = matcherV1[0][3]
            elementoPromocionable = matcherV1[0][4]
            sufijo = matcherV1[0][6]
        } else if (matcherV2.matches()) {
            centro = matcherV2[0][1]
            capp = matcherV2[0][3]
            elementoPromocionable = matcherV2[0][3]
            sufijo = matcherV2[0][6]
        } else {
            logger.warn("El nombre del repositorio ${repositoryName} no sigue la nomenclatura esperada.")
        }

        return [
                "centro": centro,
                "capp": capp,
                "elementoPromocionable": elementoPromocionable,
                "sufijo": sufijo
        ]
    }

    private String getDevOpsEnvironment() {
        String devopsEnvironment = steps.env.DEVOPS_ENVIRONMENT
        if (devopsEnvironment == null) {
            String controllerName = pipeline.resolveControllerName()
            devopsEnvironment = getEnvironmentFromUrl(controllerName)
        }
        return devopsEnvironment
    }

    private void configureProjectDescriptor(IPipelineContext context, SourceRepository sourceRepository, String tag, Map<String, String> repositoryInfo) {
        Store<ProjectDescriptor> projectStore = context.getStore(ProjectDescriptor)

        ConfiguredProjectDescriptorEvent configSourceRepositoryEvent = new ConfiguredProjectDescriptorEvent(payload: sourceRepository)
        projectStore.dispatch(configSourceRepositoryEvent)

        ProjectSettings projectSettings = new ProjectSettings(
                version: tag,
                developCenter: repositoryInfo["centro"],
                codeCapp: repositoryInfo["capp"],
                elementoPromocionable: repositoryInfo["elementoPromocionable"],
        )
        ConfiguredProjectDescriptorEvent configProjectSettingsEvent = new ConfiguredProjectDescriptorEvent(payload: projectSettings)
        projectStore.dispatch(configProjectSettingsEvent)
    }

    private void configurePipelineDescriptor(IPipelineContext context, String devopsEnvironment) {
        Store<PipelineDefinition> pipelineStore = context.getStore(PipelineDefinition)
        PipelineSettings pipelineSettings = new PipelineSettings(
                devopsEnvironment: devopsEnvironment
        )
        ConfiguredPipelineEvent configPipelineSettingsEvent = new ConfiguredPipelineEvent(payload: pipelineSettings)
        pipelineStore.dispatch(configPipelineSettingsEvent)
    }
}
</file>

<file path="src/es/giss/framework/configuration/config/adapters/EmailsXmlConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredProjectDescriptorEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.logger.LogLevel
import es.giss.framework.core.storage.Store
import es.giss.framework.core.vo.project.Email
import es.giss.framework.core.vo.project.Notification
import es.giss.framework.core.vo.project.ProjectDescriptor

@PipelineComponent(name = 'EmailsXmlConfigAdapter', priority = ConfigurationPriority.LOWEST)
class EmailsXmlConfigAdapter extends Steps implements IConfigAdapter {

    List<String> FILES = ["emails.xml", "emails_nexus.xml"]


    @Override
    void resolveConfiguration(IPipelineContext context) {
        List<Email> emailList = []

        FILES.each {
            emailList.addAll(processEmailsXmlFile(it))
        }

        Notification notification = new Notification(emails: emailList)

        logger.printPrettyLog(LogLevel.DEBUG, "Notifications in ${FILES.join(',')} loaded", notification.toMap())

        Store<ProjectDescriptor> store = context.getStore(ProjectDescriptor.class)

        ConfiguredProjectDescriptorEvent event = new ConfiguredProjectDescriptorEvent(
                description: "Configuracin resuelta por Jenkinsfile de repositorio",
                payload: notification
        )
        store.dispatch(event)

    }

    private Set<Email> processEmailsXmlFile(String fileName) {
        String PIPE_PATH = "${steps.env.WORKSPACE}/pipes"
        def file = ""
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${fileName}")
        if (exists) {
            file = steps.readFile(file: "${PIPE_PATH}/${fileName}")
        }
        def xml = new XmlSlurper().parseText(file)
        if (exists) {
            logger.debug("Loading configuration from file ${fileName}.")
        } else {
            logger.warn("File ${fileName} does not exists.")
        }

        Set<Email> emailSet = new HashSet<>()

        if (!xml.isEmpty()) {
            xml.account.each { accountNode ->
                String email = accountNode.email.text().isEmpty() ? "" : accountNode.email.text()
                String name = accountNode.name.text().isEmpty() ? "" : accountNode.name.text()
                String conseguirTodasNotificaciones = setNewNotification(email, getNotificationType(fileName), emailSet)

                List<String> notificationsInterested = conseguirTodasNotificaciones.split(",")

                Email elemento = new Email()

                elemento.email = email
                elemento.name = name
                elemento.notificationsInterested = notificationsInterested
                emailSet.add(elemento)
                addOrUpdateEmail(elemento, emailSet)

            }
        }
        return emailSet
    }

    private String setNewNotification(String email, String interestNotification, Set<Email> emailSet) {
        String newNotifications = interestNotification
        emailSet.each {
            if (it.email == email) {
                String oldNotifications = it.notificationsInterested.join(",")
                newNotifications = "${oldNotifications},${interestNotification}"
            }
        }
        return newNotifications
    }

    private static String getNotificationType(String file) {
        String notificationType
        switch (file) {
            case "emails.xml":
                notificationType = "jenkins"
                break
            case "emails_nexus.xml":
                notificationType = "nexus"
                break
            default:
                notificationType = ""
                break
        }
        return notificationType
    }

    private void addOrUpdateEmail(Email newEmail, Set<Email> emailSet) {
        // Busca el objeto Email existente en el conjunto
        Email existingEmail = emailSet.find { it.email == newEmail.email }

        // Si el objeto Email existe, lo elimina del conjunto
        if (existingEmail != null) {
            emailSet.remove(existingEmail)
        }

        // Agrega el nuevo objeto Email al conjunto
        emailSet.add(newEmail)
    }

}
</file>

<file path="src/es/giss/framework/configuration/config/adapters/JenkinsFileConfigAdapter.groovy">
package es.giss.framework.configuration.config.adapters

import es.giss.framework.core.Steps
import es.giss.framework.core.cdi.ConfigurationPriority
import es.giss.framework.core.cdi.annotations.PipelineComponent
import es.giss.framework.core.events.ConfiguredPipelineEvent
import es.giss.framework.core.interfaces.IConfigAdapter
import es.giss.framework.core.interfaces.IPipelineContext
import es.giss.framework.core.storage.Store
import es.giss.framework.core.vo.pipeline.AsdfToolsManagerDescriptor
import es.giss.framework.core.vo.pipeline.PipelineDefinition
import es.giss.framework.core.vo.pipeline.PipelineSettings
import groovy.json.JsonSlurper

@PipelineComponent(name = 'JenkinsFileConfigAdapter', priority = ConfigurationPriority.LOWEST)
class JenkinsFileConfigAdapter extends Steps implements IConfigAdapter {

    private static String FILE = "Jenkinsfile"

    @Override
    void resolveConfiguration(IPipelineContext context) {
        def jenkinsfileContent = ""
        def JKFType = ["FwDevOps", "FwAutoAgent"]
        Map mapa = [:]
        jenkinsfileContent = loadFile(FILE)
        jenkinsfileContent = jenkinsfileContent.replaceAll(/@Library.*_/, "")
        Binding binding = new Binding()
        def fwType = ""
        JKFType.each { ele ->
            if (jenkinsfileContent.contains(ele)) {
                fwType = ele
                binding.setProperty(ele, { a="defecto", b -> mapa = b })
            }
        }

        evaluateScript(binding, jenkinsfileContent)
        Map envVars = mapa.collectEntries { String key, String value ->
            [(key.trim()): value.trim()]
        }

        def toolsbuild = [:]

        if (fwType.contains("FwAutoAgent")) {
            def sw = mapa.get("SOFTWARE_AUTOAGENT")
            def jsonSlurper = new JsonSlurper()
            def jsonList = jsonSlurper.parseText(sw)
            jsonList.each { item ->
                if (item.stage == 'build') {
                    item.software.each { software ->
                        def nombre = software.nombre
                        def version = software.version
                        toolsbuild << ["${nombre}": version]
                    }
                }
            }
        }

        Store<PipelineDefinition> store = context.getStore(PipelineDefinition)
        PipelineSettings settings = new PipelineSettings(
                environmentVars: envVars,
        )
        ConfiguredPipelineEvent event = new ConfiguredPipelineEvent(
                description: "Configuracin resuelta por Jenkinsfile de repositorio",
                payload: settings)
        store.dispatch(event)

        AsdfToolsManagerDescriptor toolsManager = new AsdfToolsManagerDescriptor(
                tools: toolsbuild
        )

        ConfiguredPipelineEvent eventTools = new ConfiguredPipelineEvent(
                description: "Configuracin de herramientas resuelta por Jenkinsfile de repositorio",
                payload: toolsManager
        )
        store.dispatch(eventTools)
    }

    private def evaluateScript(Binding binding, String JenkinsfileContent) {
        GroovyShell shell = new GroovyShell(binding)
        shell.evaluate(JenkinsfileContent)
    }

    private String loadFile(String filePath) {
        String PIPE_PATH = "${steps.env.WORKSPACE}/pipes"
        def file = ""
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${filePath}")
        if (exists) {
            logger.debug("[JenkinsFileConfigAdapter] Loading configuration from file ${filePath}.")
            file = steps.readFile(file: "${PIPE_PATH}/${filePath}")
        } else {
            logger.warn("[JenkinsFileConfigAdapter] File ${filePath} does not exists.")
        }
        return file
    }
}
</file>

<file path="src/es/giss/framework/configuration/config/provider/ArtifactsHelmXmlReader.groovy">
package es.giss.framework.configuration.config.provider

import com.cloudbees.groovy.cps.NonCPS
import es.giss.framework.core.interfaces.ILogger
import es.giss.framework.core.logger.LogLevel

class ArtifactsHelmXmlReader {

    private final static String file = "artifacts_helm.xml"

    protected Script steps
    protected ILogger logger

    ArtifactsHelmXmlReader(Script steps, ILogger logger) {
        this.steps = steps
        this.logger = logger
    }

    List<Map> getHelmConfig() {
        String helmXmlContent = loadFile(file)
        if (!helmXmlContent) {
            return [:]
        }
        List<Map> configMap = parseArtifactsHelm(helmXmlContent)
        logger.printPrettyLog(LogLevel.DEBUG, 'Helm Config Map:', configMap)
        return configMap
    }

    private String loadFile(String filePath) {
        String PIPE_PATH = "${steps.env.WORKSPACE}/pipes"
        boolean exists = steps.fileExists(file: "${PIPE_PATH}/${filePath}")
        if (exists) {
            def fileContent = steps.readFile(file: "${PIPE_PATH}/${filePath}")
            logger.debug("Loading configuration from file ${PIPE_PATH}/${filePath}.")
            return fileContent
        } else {
            logger.warn("File ${filePath} does not exists.")
        }
        return ''
    }
//
    @NonCPS
    private List<Map<String, Object>> parseArtifactsHelm(String xmlContent) {
        def artifacts = new XmlSlurper().parseText(xmlContent)

        def deployDefaultXml = artifacts?.helm?.deploy_default
        Map deployDefault = [
                ocNamespaceSuffix : deployDefaultXml?.@oc_namespace_suffix.text() ?: '--',
                runtimeTech       : deployDefaultXml?.@runtime_tech.text() ?: '--',
                runtimeTechVersion: deployDefaultXml?.@runtime_tech_version.text() ?: '--',
                runtimeTechTag    : deployDefaultXml.@runtime_tech_tag.text() ?: '--',
                chartVersion      : deployDefaultXml.@chart_version.text() ?: '--',
                configPath        : deployDefaultXml.@path_config.text() ?: 'src/main'
        ]


        return artifacts.helm.deploy.collect { it ->
            String artifactId = it.@artifact.text()
            def deployArtifact = artifacts.artifact.find { it.@name == artifactId }
            return [
                    releaseName       : it.@nombre_release.text(),
                    artifactId        : artifactId,
                    configPath        : it.@path_config.text() ?: deployDefault.configPath,
                    ocNamespaceSuffix : it.@oc_namespace_suffix.text() ?: deployDefault.ocNamespaceSuffix,
                    runtimeTech       : it.@runtime_tech.text() ?: deployDefault.runtimeTech,
                    runtimeTechVersion: it.@runtime_tech_version.text() ?: deployDefault.runtimeTechVersion,
                    runtimeTechTag    : it.@runtime_tech_tag.text() ?: deployDefault.runtimeTechTag,
                    chartVersion      : it.@chart_version.text() ?: deployDefault.chartVersion,
                    nexusFile         : deployArtifact?.nexus_file?.text() ?: ''
            ]
        }

    }


}
</file>

<file path="src/es/giss/framework/configuration/config/BackendRestClient.groovy">
package es.giss.framework.configuration.config


import es.giss.framework.core.tools.restClients.RestClient
import es.giss.framework.core.vo.resources.http.HttpResponse

class BackendRestClient {

    String baseUrl
    Script steps

    BackendRestClient(Script steps) {
        this.baseUrl = steps.env.BACKEND_HOST
        this.steps = steps
    }

    HttpResponse helmInfoBaseImagesChart(Set<String> techNames) {

        String url = "${this.baseUrl}jobs/helmInfoBaseImagesCharts?"
        techNames.each { v ->
            url = url.concat("types=${v}&")
        }

        return new RestClient(steps)
                .url(url)
                .get()
                .execute()

    }
}
</file>

</files>
