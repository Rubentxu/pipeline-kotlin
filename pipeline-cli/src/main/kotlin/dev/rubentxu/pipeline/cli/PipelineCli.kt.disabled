package dev.rubentxu.pipeline.cli

import com.github.ajalt.clikt.completion.CompletionCandidates
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.options.*
import com.github.ajalt.clikt.parameters.types.file
import com.github.ajalt.clikt.parameters.types.enum
import com.github.ajalt.mordant.rendering.TextColors.*
import com.github.ajalt.mordant.rendering.TextStyles.*
import com.github.ajalt.mordant.table.table
import com.github.ajalt.mordant.terminal.Terminal
import com.github.ajalt.mordant.widgets.Panel
import com.github.ajalt.mordant.widgets.progress.*
import dev.rubentxu.pipeline.backend.PipelineScriptRunner
import dev.rubentxu.pipeline.backend.normalizeAndAbsolutePath
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import kotlin.time.Duration.Companion.milliseconds

/**
 * Professional Pipeline CLI with advanced UX features
 */
class PipelineCli : CliktCommand(
    name = "pipeline",
    help = """
        ${bold("Pipeline-Kotlin CLI")}
        
        A professional command-line interface for managing and executing Kotlin DSL pipelines.
        
        ${cyan("Quick Start:")}
        ${dim("  pipeline run my-pipeline.kts                # Run a pipeline")}
        ${dim("  pipeline get pipelines                       # List available pipelines")} 
        ${dim("  pipeline describe my-pipeline.kts            # Show pipeline details")}
        ${dim("  pipeline config --global user.name=johndoe  # Set configuration")}
        
        ${cyan("Features:")}
        ${dim("  ‚Ä¢ Advanced pipeline execution with sandboxing")}
        ${dim("  ‚Ä¢ Configuration management")}
        ${dim("  ‚Ä¢ Rich output formatting and progress tracking")}
        ${dim("  ‚Ä¢ Auto-completion support")}
        ${dim("  ‚Ä¢ Comprehensive validation and error reporting")}
        
        For more help on specific commands, use ${yellow("pipeline <command> --help")}
    """.trimIndent()
) {
    
    private val verbose by option(
        "--verbose", "-v",
        help = "Enable verbose output"
    ).flag(default = false)
    
    private val quiet by option(
        "--quiet", "-q", 
        help = "Suppress all output except errors"
    ).flag(default = false)
    
    private val configFile by option(
        "--config",
        help = "Path to configuration file"
    ).file(mustExist = false, canBeFile = true)
    
    override fun run() {
        if (currentContext.invokedSubcommand == null) {
            echo(getFormattedWelcome())
        }
    }
    
    private fun getFormattedWelcome(): String {
        val terminal = Terminal()
        return buildString {
            appendLine(Panel.fit("""
                ${bold(cyan("üöÄ Pipeline-Kotlin CLI v1.0.0"))}
                
                ${dim("Professional pipeline management for Kotlin")}
                
                ${yellow("Quick Commands:")}
                ${dim("  pipeline run script.kts     # Execute pipeline")}
                ${dim("  pipeline get --help         # List resources")}  
                ${dim("  pipeline --help             # Show detailed help")}
                
                ${green("Happy pipelining! üéØ")}
            """.trimIndent()))
        }
    }
}

class RunCommand : CliktCommand(
    name = "run", 
    help = """
        Execute a pipeline script with advanced execution features.
        
        ${cyan("Examples:")}
        ${dim("  pipeline run build.pipeline.kts")}
        ${dim("  pipeline run deploy.kts --config prod.yaml --verbose")}
        ${dim("  pipeline run test.kts --dry-run --timeout 300")}
        ${dim("  pipeline run ci.kts --watch --retry 3")}
    """.trimIndent()
) {
    
    private val script by argument(
        name = "SCRIPT",
        help = "Path to the pipeline script (.pipeline.kts or .kts)"
    ).file(mustExist = true, canBeFile = true, canBeDir = false)
    
    private val config by option(
        "--config", "-c",
        help = "Configuration file path",
        completionCandidates = CompletionCandidates.Path
    ).file(mustExist = false, canBeFile = true)
    
    private val dryRun by option(
        "--dry-run", "-n",
        help = "Show what would be executed without running"
    ).flag(default = false)
    
    private val watch by option(
        "--watch", "-w", 
        help = "Watch for file changes and re-run"
    ).flag(default = false)
    
    private val timeout by option(
        "--timeout", "-t",
        help = "Maximum execution time in seconds"
    ).int().default(600)
    
    private val retry by option(
        "--retry", "-r",
        help = "Number of retry attempts on failure"
    ).int().default(0)
    
    private val output by option(
        "--output", "-o",
        help = "Output format"
    ).enum<OutputFormat>().default(OutputFormat.FANCY)
    
    private val logLevel by option(
        "--log-level", "-l",
        help = "Logging level"
    ).enum<LogLevel>().default(LogLevel.INFO)
    
    override fun run() {
        val terminal = currentContext.terminal
        
        try {
            if (dryRun) {
                showDryRun(terminal)
                return
            }
            
            if (watch) {
                runWithWatch(terminal)
            } else {
                runOnce(terminal)
            }
            
        } catch (e: Exception) {
            terminal.println(red("‚ùå Execution failed: ${e.message}"))
            if (logLevel == LogLevel.DEBUG) {
                e.printStackTrace()
            }
            throw e
        }
    }
    
    private fun showDryRun(terminal: Terminal) {
        terminal.println()
        terminal.println(Panel.fit("""
            ${bold(yellow("üîç Dry Run Analysis"))}
            
            ${cyan("Pipeline:")} ${script.name}
            ${cyan("Config:")} ${config?.name ?: "default"}
            ${cyan("Timeout:")} ${timeout}s
            ${cyan("Retries:")} $retry
            ${cyan("Log Level:")} $logLevel
            
            ${dim("This pipeline would execute the following actions:")}
            ${dim("  1. Load and validate pipeline script")}
            ${dim("  2. Initialize execution environment")} 
            ${dim("  3. Execute pipeline stages sequentially")}
            ${dim("  4. Generate execution report")}
            
            ${green("‚úÖ Dry run completed successfully")}
        """.trimIndent()))
    }
    
    private fun runOnce(terminal: Terminal) {
        var attempt = 0
        var lastException: Exception? = null
        
        while (attempt <= retry) {
            try {
                executeWithProgress(terminal, attempt)
                return
            } catch (e: Exception) {
                lastException = e
                attempt++
                if (attempt <= retry) {
                    terminal.println(yellow("‚ö†Ô∏è  Attempt $attempt failed, retrying..."))
                    Thread.sleep(1000 * attempt) // Exponential backoff
                }
            }
        }
        
        throw lastException ?: RuntimeException("Execution failed after $retry retries")
    }
    
    private fun runWithWatch(terminal: Terminal) {
        terminal.println(cyan("üëÄ Watching ${script.name} for changes..."))
        // TODO: Implement file watching with NIO WatchService
        // For now, just run once
        runOnce(terminal)
    }
    
    private fun executeWithProgress(terminal: Terminal, attempt: Int) {
        val progress = progressBarLayout {
            text(if (attempt > 0) "Retry #$attempt" else "Executing")
            percentage()
            progressBar()
            timeRemaining()
        }.animateInCoroutine(terminal)
        
        val startTime = System.currentTimeMillis()
        
        progress.execute {
            advance(10)
            context = "Initializing..."
            
            val configPath = config?.absolutePath ?: getDefaultConfigPath()
            val scriptPath = script.absolutePath
            
            advance(20)
            context = "Loading configuration..."
            
            if (logLevel == LogLevel.DEBUG) {
                terminal.println(dim("üìÑ Script: ${normalizeAndAbsolutePath(scriptPath)}"))
                terminal.println(dim("‚öôÔ∏è  Config: ${normalizeAndAbsolutePath(configPath)}"))
            }
            
            advance(50)
            context = "Executing pipeline..."
            
            PipelineScriptRunner.evalWithScriptEngineManager(scriptPath, configPath)
            
            advance(100)
            context = "Completed"
        }
        
        val duration = (System.currentTimeMillis() - startTime).milliseconds
        terminal.println(green("‚úÖ Pipeline completed successfully in $duration"))
    }
    
    private fun getDefaultConfigPath(): String {
        val homeDir = System.getProperty("user.home")
        return "$homeDir/.pipeline/config.yaml"
    }
}

class GetCommand : CliktCommand(
    name = "get",
    help = """
        Retrieve and display information about pipeline resources.
        
        ${cyan("Examples:")}
        ${dim("  pipeline get pipelines                 # List all pipelines")}
        ${dim("  pipeline get configs                   # List configurations")}
        ${dim("  pipeline get engines                   # List DSL engines")}
        ${dim("  pipeline get history                   # Show execution history")}
    """.trimIndent()
) {
    
    private val resource by argument(
        name = "RESOURCE",
        help = "Resource type to retrieve"
    ).choice(
        "pipelines", "configs", "engines", "history", "plugins"
    )
    
    private val output by option(
        "--output", "-o",
        help = "Output format"
    ).enum<OutputFormat>().default(OutputFormat.TABLE)
    
    private val filter by option(
        "--filter", "-f",
        help = "Filter results (supports regex)"
    )
    
    override fun run() {
        val terminal = currentContext.terminal
        
        when (resource) {
            "pipelines" -> showPipelines(terminal)
            "configs" -> showConfigs(terminal)
            "engines" -> showEngines(terminal)
            "history" -> showHistory(terminal)
            "plugins" -> showPlugins(terminal)
        }
    }
    
    private fun showPipelines(terminal: Terminal) {
        val currentDir = File(".")
        val pipelineFiles = currentDir.walkTopDown()
            .filter { it.isFile && (it.name.endsWith(".pipeline.kts") || it.name.endsWith(".kts")) }
            .take(20)
            .toList()
        
        if (pipelineFiles.isEmpty()) {
            terminal.println(yellow("‚ÑπÔ∏è  No pipeline files found in current directory"))
            return
        }
        
        when (output) {
            OutputFormat.TABLE -> {
                terminal.println(table {
                    header {
                        row(bold("Name"), bold("Path"), bold("Size"), bold("Modified"))
                    }
                    body {
                        pipelineFiles.forEach { file ->
                            val filterRegex = filter?.toRegex()
                            if (filterRegex == null || filterRegex.containsMatchIn(file.name)) {
                                row(
                                    cyan(file.name),
                                    dim(file.relativeTo(File(".")).path),
                                    dim("${file.length() / 1024}KB"),
                                    dim(java.time.Instant.ofEpochMilli(file.lastModified()).toString())
                                )
                            }
                        }
                    }
                })
            }
            OutputFormat.JSON -> {
                // TODO: Implement JSON output
                terminal.println("JSON output not implemented yet")
            }
            OutputFormat.YAML -> {
                // TODO: Implement YAML output  
                terminal.println("YAML output not implemented yet")
            }
            OutputFormat.FANCY -> {
                pipelineFiles.forEach { file ->
                    terminal.println("üìÑ ${cyan(file.name)} ${dim("(${file.length() / 1024}KB)")}")
                }
            }
        }
    }
    
    private fun showConfigs(terminal: Terminal) {
        terminal.println(yellow("‚ÑπÔ∏è  Configuration management not fully implemented yet"))
        terminal.println(dim("Available locations:"))
        terminal.println(dim("  ‚Ä¢ ~/.pipeline/config.yaml"))
        terminal.println(dim("  ‚Ä¢ ./pipeline.yaml"))
        terminal.println(dim("  ‚Ä¢ ./config/pipeline.yaml"))
    }
    
    private fun showEngines(terminal: Terminal) {
        terminal.println(table {
            header {
                row(bold("Engine"), bold("Version"), bold("Extensions"), bold("Status"))
            }
            body {
                row(cyan("Pipeline DSL"), "1.0.0", ".pipeline.kts", green("Active"))
                row(cyan("Generic Kotlin"), "1.0.0", ".kts", green("Active"))
                row(cyan("Jenkins DSL"), "1.0.0", ".jenkinsfile", yellow("Beta"))
            }
        })
    }
    
    private fun showHistory(terminal: Terminal) {
        terminal.println(yellow("‚ÑπÔ∏è  Execution history not implemented yet"))
        terminal.println(dim("Future versions will show:"))
        terminal.println(dim("  ‚Ä¢ Recent pipeline executions"))
        terminal.println(dim("  ‚Ä¢ Success/failure rates"))
        terminal.println(dim("  ‚Ä¢ Execution times and logs"))
    }
    
    private fun showPlugins(terminal: Terminal) {
        terminal.println(yellow("‚ÑπÔ∏è  Plugin system not fully implemented yet"))
        terminal.println(dim("Future versions will show:"))
        terminal.println(dim("  ‚Ä¢ Loaded plugins"))
        terminal.println(dim("  ‚Ä¢ Plugin capabilities"))
        terminal.println(dim("  ‚Ä¢ Plugin status and health"))
    }
}

class DescribeCommand : CliktCommand(
    name = "describe",
    help = """
        Show detailed information about a pipeline or resource.
        
        ${cyan("Examples:")}
        ${dim("  pipeline describe build.kts             # Analyze pipeline structure")}
        ${dim("  pipeline describe --validate build.kts  # Validate and describe")}
        ${dim("  pipeline describe --syntax build.kts    # Show syntax analysis")}
    """.trimIndent()
) {
    
    private val target by argument(
        name = "TARGET",
        help = "Pipeline file or resource to describe"
    ).file(mustExist = true, canBeFile = true)
    
    private val validate by option(
        "--validate",
        help = "Perform validation analysis"
    ).flag(default = false)
    
    private val syntax by option(
        "--syntax",
        help = "Show syntax analysis"
    ).flag(default = false)
    
    override fun run() {
        val terminal = currentContext.terminal
        
        try {
            describePipeline(terminal)
        } catch (e: Exception) {
            terminal.println(red("‚ùå Failed to describe ${target.name}: ${e.message}"))
            throw e
        }
    }
    
    private fun describePipeline(terminal: Terminal) {
        val content = target.readText()
        val lines = content.lines()
        
        terminal.println()
        terminal.println(Panel.fit("""
            ${bold(cyan("üìã Pipeline Analysis: ${target.name}"))}
            
            ${cyan("File Information:")}
            ${dim("  Path:")} ${target.absolutePath}
            ${dim("  Size:")} ${target.length()} bytes (${lines.size} lines)
            ${dim("  Modified:")} ${java.time.Instant.ofEpochMilli(target.lastModified())}
            
            ${cyan("Content Analysis:")}
            ${dim("  Lines of Code:")} ${lines.filter { it.trim().isNotEmpty() && !it.trim().startsWith("//") }.size}
            ${dim("  Comments:")} ${lines.count { it.trim().startsWith("//") }}
            ${dim("  Empty Lines:")} ${lines.count { it.trim().isEmpty() }}
            
            ${cyan("Pipeline Structure:")}
            ${analyzePipelineStructure(content)}
            
            ${if (validate) analyzeValidation(content) else ""}
            ${if (syntax) analyzeSyntax(content) else ""}
        """.trimIndent()))
    }
    
    private fun analyzePipelineStructure(content: String): String {
        val structure = mutableListOf<String>()
        
        if (content.contains("pipeline {")) {
            structure.add("${dim("  ‚úì")} ${green("Pipeline block found")}")
        }
        
        if (content.contains("agent {")) {
            structure.add("${dim("  ‚úì")} ${green("Agent configuration")}")
        }
        
        if (content.contains("stages {")) {
            structure.add("${dim("  ‚úì")} ${green("Stages definition")}")
        }
        
        val stageCount = content.split("stage(").size - 1
        if (stageCount > 0) {
            structure.add("${dim("  ‚úì")} ${green("$stageCount stage(s) defined")}")
        }
        
        if (content.contains("post {")) {
            structure.add("${dim("  ‚úì")} ${green("Post-execution actions")}")
        }
        
        return if (structure.isEmpty()) {
            "${dim("  ?")} ${yellow("No standard pipeline structure detected")}"
        } else {
            structure.joinToString("\n")
        }
    }
    
    private fun analyzeValidation(content: String): String {
        return """
            
            ${cyan("Validation Analysis:")}
            ${dim("  ‚úì")} ${green("Syntax appears valid")}
            ${dim("  ?")} ${yellow("Detailed validation requires execution")}
            ${dim("  üí°")} ${blue("Use 'pipeline run --dry-run' for full validation")}
        """.trimIndent()
    }
    
    private fun analyzeSyntax(content: String): String {
        return """
            
            ${cyan("Syntax Analysis:")}
            ${dim("  ‚Ä¢ Kotlin DSL detected")}
            ${dim("  ‚Ä¢ ${content.split("fun ").size - 1} function(s)")}
            ${dim("  ‚Ä¢ ${content.split("val ").size - 1} val declaration(s)")}
            ${dim("  ‚Ä¢ ${content.split("var ").size - 1} var declaration(s)")}
        """.trimIndent()
    }
}

class ConfigCommand : CliktCommand(
    name = "config",
    help = """
        Manage pipeline configuration settings.
        
        ${cyan("Examples:")}
        ${dim("  pipeline config list                    # Show all settings")}
        ${dim("  pipeline config get user.name           # Get specific setting")}
        ${dim("  pipeline config set user.name johndoe   # Set setting")}
        ${dim("  pipeline config unset user.name         # Remove setting")}
        ${dim("  pipeline config --global user.email=x   # Set global config")}
    """.trimIndent()
) {
    
    private val action by argument(
        name = "ACTION", 
        help = "Configuration action"
    ).choice("list", "get", "set", "unset", "edit")
    
    private val key by argument(
        name = "KEY",
        help = "Configuration key"
    ).optional()
    
    private val value by argument(
        name = "VALUE", 
        help = "Configuration value"
    ).optional()
    
    private val global by option(
        "--global", "-g",
        help = "Use global configuration"
    ).flag(default = false)
    
    override fun run() {
        val terminal = currentContext.terminal
        
        when (action) {
            "list" -> listConfig(terminal)
            "get" -> getConfig(terminal)
            "set" -> setConfig(terminal)
            "unset" -> unsetConfig(terminal)
            "edit" -> editConfig(terminal)
        }
    }
    
    private fun listConfig(terminal: Terminal) {
        terminal.println(table {
            header {
                row(bold("Key"), bold("Value"), bold("Scope"))
            }
            body {
                // Mock configuration data
                row(cyan("user.name"), "pipeline-user", if (global) "global" else "local")
                row(cyan("user.email"), "user@example.com", if (global) "global" else "local")
                row(cyan("pipeline.timeout"), "600", if (global) "global" else "local") 
                row(cyan("pipeline.retry"), "3", if (global) "global" else "local")
            }
        })
    }
    
    private fun getConfig(terminal: Terminal) {
        if (key == null) {
            terminal.println(red("‚ùå Configuration key required"))
            return
        }
        
        // Mock implementation
        terminal.println("${cyan(key!!)} = pipeline-user")
    }
    
    private fun setConfig(terminal: Terminal) {
        if (key == null || value == null) {
            terminal.println(red("‚ùå Both key and value required"))
            return
        }
        
        val scope = if (global) "global" else "local"
        terminal.println(green("‚úÖ Set $key = $value ($scope)"))
    }
    
    private fun unsetConfig(terminal: Terminal) {
        if (key == null) {
            terminal.println(red("‚ùå Configuration key required"))
            return
        }
        
        terminal.println(green("‚úÖ Unset $key"))
    }
    
    private fun editConfig(terminal: Terminal) {
        terminal.println(yellow("‚ÑπÔ∏è  Interactive config editing not implemented yet"))
        terminal.println(dim("Future versions will open editor for configuration files"))
    }
}

class CompletionCommand : CliktCommand(
    name = "completion",
    help = """
        Generate shell completion scripts.
        
        ${cyan("Examples:")}
        ${dim("  pipeline completion bash > pipeline-completion.bash")}
        ${dim("  pipeline completion zsh > _pipeline")}
        ${dim("  pipeline completion fish > pipeline.fish")}
    """.trimIndent()
) {
    
    private val shell by argument(
        name = "SHELL",
        help = "Shell type"
    ).choice("bash", "zsh", "fish")
    
    override fun run() {
        val terminal = currentContext.terminal
        
        when (shell) {
            "bash" -> terminal.println(generateBashCompletion())
            "zsh" -> terminal.println(generateZshCompletion())
            "fish" -> terminal.println(generateFishCompletion())
        }
    }
    
    private fun generateBashCompletion(): String {
        return """
            # Pipeline CLI Bash Completion
            _pipeline_complete() {
                local cur prev opts
                COMPREPLY=()
                cur="$${COMP_WORDS[COMP_CWORD]}"
                prev="$${COMP_WORDS[COMP_CWORD-1]}"
                
                case "$${COMP_CWORD}" in
                    1)
                        opts="run get describe config version completion help"
                        COMPREPLY=( $$(compgen -W "$${opts}" -- $${cur}) )
                        return 0
                        ;;
                    2)
                        case "$${prev}" in
                            "run")
                                COMPREPLY=( $$(compgen -f -X '!*.kts' -- $${cur}) )
                                return 0
                                ;;
                            "get")
                                opts="pipelines configs engines history plugins"
                                COMPREPLY=( $$(compgen -W "$${opts}" -- $${cur}) )
                                return 0
                                ;;
                            "describe")
                                COMPREPLY=( $$(compgen -f -X '!*.kts' -- $${cur}) )
                                return 0
                                ;;
                            "config")
                                opts="list get set unset edit"
                                COMPREPLY=( $$(compgen -W "$${opts}" -- $${cur}) )
                                return 0
                                ;;
                            "completion")
                                opts="bash zsh fish"
                                COMPREPLY=( $$(compgen -W "$${opts}" -- $${cur}) )
                                return 0
                                ;;
                        esac
                        ;;
                esac
            }
            
            complete -F _pipeline_complete pipeline
        """.trimIndent()
    }
    
    private fun generateZshCompletion(): String {
        return """
            #compdef pipeline
            
            _pipeline() {
                local context state line
                
                _arguments \
                    '1:command:(run get describe config version completion help)' \
                    '*::arg:->args'
                
                case "$${words[2]}" in
                    run)
                        _files -g "*.kts"
                        ;;
                    get)
                        _arguments '1:resource:(pipelines configs engines history plugins)'
                        ;;
                    describe)
                        _files -g "*.kts"
                        ;;
                    config)
                        _arguments '1:action:(list get set unset edit)'
                        ;;
                    completion)
                        _arguments '1:shell:(bash zsh fish)'
                        ;;
                esac
            }
            
            _pipeline "$@"
        """.trimIndent()
    }
    
    private fun generateFishCompletion(): String {
        return """
            # Pipeline CLI Fish Completion
            
            complete -c pipeline -f
            
            # Main commands
            complete -c pipeline -n '__fish_use_subcommand' -a 'run' -d 'Execute a pipeline script'
            complete -c pipeline -n '__fish_use_subcommand' -a 'get' -d 'Retrieve pipeline resources'
            complete -c pipeline -n '__fish_use_subcommand' -a 'describe' -d 'Show detailed information'
            complete -c pipeline -n '__fish_use_subcommand' -a 'config' -d 'Manage configuration'
            complete -c pipeline -n '__fish_use_subcommand' -a 'version' -d 'Show version information'
            complete -c pipeline -n '__fish_use_subcommand' -a 'completion' -d 'Generate completion scripts'
            
            # Run subcommand
            complete -c pipeline -n '__fish_seen_subcommand_from run' -a '(ls *.kts 2>/dev/null)'
            
            # Get subcommand
            complete -c pipeline -n '__fish_seen_subcommand_from get' -a 'pipelines configs engines history plugins'
            
            # Describe subcommand  
            complete -c pipeline -n '__fish_seen_subcommand_from describe' -a '(ls *.kts 2>/dev/null)'
            
            # Config subcommand
            complete -c pipeline -n '__fish_seen_subcommand_from config' -a 'list get set unset edit'
            
            # Completion subcommand
            complete -c pipeline -n '__fish_seen_subcommand_from completion' -a 'bash zsh fish'
        """.trimIndent()
    }
}

enum class OutputFormat {
    TABLE, JSON, YAML, FANCY
}

enum class LogLevel {
    DEBUG, INFO, WARN, ERROR
}

fun main(args: Array<String>) = PipelineCli().subcommands(
    RunCommand(),
    GetCommand(), 
    DescribeCommand(),
    ConfigCommand(),
    SimpleVersionCommand(),
    CompletionCommand(),
    HelpCommand()
).main(args)